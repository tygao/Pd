* 1st DFT
2*2*2 = [9, 9, 9]
3*3*3 = [5, 5, 5] 2GB
4*4*4 = [3, 3, 3] 4GB
** Vacancy
2*2*2 = [9, 9, 9]
3*3*3 = [5, 5, 5] 2GB
4*4*4 = [3, 3, 3] 4GB
*** Primitive
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase import Atoms, Atom
from ase.lattice.cubic import FaceCenteredCubic
from ase.visualize import view
import numpy as np

VASPRC['queue.men'] = '4GB'

#factor = [0.9, 0.95, 1.0, 1.05]
factor = [1.000]
energies = []
for x in factor:

    fcc = FaceCenteredCubic('Pd',
                            directions=[[0, 1, 1],
                                        [1, 0, 1],
                                        [1, 1, 0]],
                            latticeconstant = 3.939)

    delta = np.array([[x, 0., 0.],
                      [0., x, 0.],
                      [0., 0., x]])
    fcc.set_cell(np.dot(fcc.get_cell(), delta),
                       scale_atoms = True)

    atoms = fcc.repeat([4, 4, 4])

    cnt = len(atoms)
    del atoms[0]
    atoms.rattle()
    
    wd = './NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=444/factor={0:1.3f}'.format(x)
    calc = Vasp(wd,
                xc='pbe',
                encut=350,
                kpts = [3, 3, 3],
                ibrion = 2,
                isif = 2,
                nsw = 25,
                atoms = atoms)

    energies.append(calc.potential_energy) 

print energies


#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=444/factor=1.000 submitted: 1428755.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=444/factor=1.000 Queued: 1428755.gilgamesh.cheme.cmu.edu
: [None]

#+BEGIN_SRC python
from vasp import Vasp

factor = [0.9, 0.95, 1.0, 1.05]
nrg, calcs = [], []
for f in factor:
    calc = Vasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=222/factor={0:1.3f}'.format(f))
    calcs  += [calc]
    nrg +=[calc.potential_energy]

Vasp.stop_if(None in nrg)


[calc.write_db('database/master.db', parser='=', overwrite=False) for calc in calcs]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase import Atoms, Atom
from ase.lattice.cubic import FaceCenteredCubic
from ase.visualize import view
import numpy as np
VASPRC['queue.men']='8GB'
#factor = [0.9, 0.95, 1.0, 1.05]
factor = [1.000]
energies = []
for x in factor:

    fcc = FaceCenteredCubic('Pd',
                            directions=[[0, 1, 1],
                                        [1, 0, 1],
                                        [1, 1, 0]],
                            latticeconstant = 3.939)

    delta = np.array([[x, 0., 0.],
                      [0., x, 0.],
                      [0., 0., x]])
    fcc.set_cell(np.dot(fcc.get_cell(), delta),
                       scale_atoms = True)

    atoms = fcc.repeat([5, 5, 5])

    cnt = len(atoms)
    del atoms[0]
    atoms.rattle()
    
    wd = './NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=555/factor={0:1.3f}'.format(x)
    calc = Vasp(wd,
                xc='pbe',
                encut=350,
                kpts = [1, 1, 1],
                ibrion = 2,
                isif = 2,
                nsw = 25,
                atoms = atoms)

 
    calc.potential_energy


#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=555/factor=1.000 submitted: 1449350.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=555/factor=1.000 Queued: 1449350.gilgamesh.cheme.cmu.edu

*** Cubic
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase import Atoms, Atom
from ase.lattice.cubic import FaceCenteredCubic
from ase.visualize import view
import numpy as np

VASPRC['queue.men'] = '4GB'

#factor = [0.95, 1.0, 1.05]
factor=[0.950]
energies = []
calcs = []
for x in factor:

    fcc = FaceCenteredCubic('Pd',
                            directions=[[1, 0, 0],
                                        [0, 1, 0],
                                        [0, 0, 1]],
                            latticeconstant = 3.939)

    delta = np.array([[x, 0., 0.],
                      [0., x, 0.],
                      [0., 0., x]])
    fcc.set_cell(np.dot(fcc.get_cell(), delta),
                       scale_atoms = True)

    atoms = fcc.repeat([2, 2, 2])

    cnt = len(atoms)
    del atoms[0]
    atoms.rattle()

    wd = './NDFT/bulk=fcc/type=vacancy/lattice=cubic/supercell=222/factor={:.3f}'.format(x)
   # wd = './NDFT/bulk=fcc/type=test/factor={:.3f}'.format(x)
    calc = Vasp(wd,
                xc='pbe',
                encut=350,
                kpts=[4]*3,
                #kpts=[2]*3,
                ibrion=2,
                isif=2,
                nsw=25,
                atoms=atoms)

    energies += [calc.potential_energy]
    calcs += [calc]

print energies

#Vasp.stop_if(None in energies)

[calc.write_db('./database/db0.db', parser='=', overwrite=False, keys={'dbkey':0}) for calc in calcs]
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=vacancy/lattice=cubic/supercell=222/factor=0.950 submitted: 1430982.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=vacancy/lattice=cubic/supercell=222/factor=0.950 Queued: 1430982.gilgamesh.cheme.cmu.edu
: [None]

#+BEGIN_SRC python
from vasp import Vasp
calc = Vasp('./NDFT/bulk=fcc/type=vacancy/lattice=cubic/supercell=222/factor=0.950')
calc.qalter('s','walltime=24:00:00')
#+END_SRC

#+RESULTS:

** Vacancy Diffusion NEB
*** 2*2*2
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '8GB'
VASPRC['wall.time'] = '24:00:00'
fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 2, 2])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb-initial',
          xc='pbe',
          kpts=[9, 9, 9],
          encut=350,
          atoms=ini)

fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb-final',
            xc='pbe',
            kpts=[9, 9, 9],
            encut=350,
            atoms=fin)

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb',
            xc='pbe',
            kpts=[9, 9, 9],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/222-NEB.png')
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.675637
:          Iterations: 15
:          Function evaluations: 30

[[./figures/NEB-7.png]]
*** 2*2*3
c0-end
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['wall.time'] = '24:00:00'
fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 2, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-initial',
          xc='pbe',
          kpts=[9, 9, 5],
          encut=350,
          atoms=ini)
c0.calculate()
fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-final',
            xc='pbe',
            kpts=[9, 9, 5],
            encut=350,
            atoms=fin)
cend.calculate()
#+END_SRC

#+RESULTS:
: No calculation_required.
: No calculation_required.


#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '8GB'

fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 2, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-initial',
          xc='pbe',
          kpts=[9, 9, 5],
          encut=350,
          atoms=ini)

fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-final',
            xc='pbe',
            kpts=[9, 9, 5],
            encut=350,
            atoms=fin)

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb',
            xc='pbe',
            kpts=[9, 9, 5],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('.images/223-NEB.png')
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/neb submitted: 1434120.gilgamesh.cheme.cmu.edu

*** 2*3*3
c0-end
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['wall.time'] = '24:00:00'
fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 3, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-initial',
          xc='pbe',
          kpts=[9, 5, 5],
          encut=350,
          atoms=ini)
c0.calculate()
fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-final',
            xc='pbe',
            kpts=[9, 5, 5],
            encut=350,
            atoms=fin)
cend.calculate()
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=233/neb-initial submitted: 1434130.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=233/neb-final submitted: 1434131.gilgamesh.cheme.cmu.edu


#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '8GB'


# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-initial')
ini = c0.get_atoms()

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-final')
fin = cend.get_atoms()

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb',
            xc='pbe',
            kpts=[9, 5, 5],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('.images/233-NEB.png')
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/neb submitted: 1434120.gilgamesh.cheme.cmu.edu

*** 3*3*3
c0-end
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([3, 3, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb-initial',
          xc='pbe',
          kpts=[5, 5, 5],
          encut=350,
          atoms=ini)
c0.calculate()
fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb-final',
            xc='pbe',
            kpts=[5, 5, 5],
            encut=350,
            atoms=fin)
cend.calculate()
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/neb-initial submitted: 1434133.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/neb-final submitted: 1434134.gilgamesh.cheme.cmu.edu


#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '8GB'


# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb-initial')
ini = c0.get_atoms()

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-final')
fin = cend.get_atoms()

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb',
            xc='pbe',
            kpts=[5, 5, 5],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('.images/333-NEB.png')
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/neb submitted: 1434120.gilgamesh.cheme.cmu.edu

** MD0
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
from vasp.vasprc import VASPRC
import matplotlib.pyplot as plt
import jbtools.gilgamesh as jb
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
for i, atoms in enumerate(Trajectory('./networks/db3-v/MD.traj', 'r')):

    calc = Vasp('NDFT/bulk=fcc/type=md/order=md0/v:a=0:8/MD={0}'.format(int(i)),
              xc='PBE',
              kpts=[9, 9, 9],
              encut=350,
              ibrion=-1,
              atoms=atoms)

    calc.calculate()
#+END_SRC

* DB
** write
#+BEGIN_SRC python
from vasp import Vasp

factor = [0.900, 0.950, 1.000, 1.050]
#cells= ['222', '223', '233', '333', '334', '344'] #'444'
cells= ['222', '223', '233', '333', '334']
#cells=['222']
calcs = []
for cell in cells:

    for x in factor:
    
        wd = './NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell={0}/factor={1:.3f}'.format(cell,x)
        
        calc = Vasp(wd)
        calcs += [calc]

[calc.write_db('database/db0/data.db', parser='=', overwrite=False) for calc in calcs]        
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []
for i in range(200):
    wd = './NDFT/bulk=fcc/type=MD0/MD={0}'.format(i)

    calc = Vasp(wd)
    calcs += [calc]
[calc.write_db('database/db0/data.db', parser='=', overwrite=False) for calc in calcs]   
#+END_SRC

#+RESULTS:

** keywords
#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

from ase.db import connect

db = connect('./database/db0/data.db')
data = db.select([])

keys, cnt = {}, 0
for entry in data:
    cnt += 1
    for k, v in entry.key_value_pairs.iteritems():
        
        if k in keys:
            keys[k] += [v]
        else:
            keys[k] = [v]

print ('{0:15s} {1:15s} {2} calculations total'.format('keyword', 'value',cnt))

print('------------------------------------------------------')

for k, v in keys.iteritems():
    vals = list(set(v))
    if len(vals) <= 5:
        val = ", ".join(str(e) for e in vals)
        print('{0:15}: {1}'.format(k, val))

    else:
        val = ", ".join(str(e)[:5] for e in vals[:5])
        print('{0:15s}:{1}, etc...'.format(k, val))
#+END_SRC
#+RESULTS:
: keyword         value           224 calculations total
: ------------------------------------------------------
: MD             :0, 1, 2, 3, 4, etc...
: train_set      : False, True
: bulk           : fcc
: lattice        : primitive
: supercell      :233, 333, 334, 344, 222, etc...
: factor         : 1.05, 0.95, 0.9, 1.0
: type           : vacancy, MD0

* Training
#+BEGIN_SRC python
from ase.db import connect
import os
import random
import numpy as np

db = connect('./database/db0/data.db')

n = db.count()
n_train = int(round(n * 0.9))

n_ids =  np.array(range(n)) + 1

# This will sudo-randomly select 10% of the calculations
# Which is useful for reproducing our results.
random.seed(256)
train_samples = random.sample(n_ids, n_train)
valid_samples = set(n_ids) - set(train_samples)

db.update(list(train_samples), train_set=True)
db.update(list(valid_samples), train_set=False)

with connect('./database/db0/train.db') as db0:
    for d in db.select(['train_set=True']):
        db0.write(d, key_value_pairs=d.key_value_pairs)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *
import os

for n in [20]:
    label = '2-{0}-test'.format(n)
    wd = os.path.join(os.getcwd(), 'database/db0/' + label)

    if not os.path.exists(wd):
        os.makedirs(wd)

    calc = Amp(label="./database/db0/{0}/".format(label),
               descriptor=Behler(cutoff=6.0),
               regression=NeuralNetwork(hiddenlayers=(2, '{0}'.format(n))))


    calc.train('./database/db0/train.db', # The training data
               cores=1,
               extend_variables=False) # feature does not work properly and will crash
#+END_SRC
#+RESULTS:


#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

# We will try an iteration for n nodes with l hidden layers.
for l in [2]:
    #for n in [15, 20, 25]:
    #for n in [10, 15, 16, 18,20, 24, 25, 30]:
    for n in [15, 16, 20, 24, 30]:
        label = '{0}-{1}-1'.format(l,n)
        layer=(l,n)
        wd = os.path.join(home, './database/db0/' + label)

        if not os.path.exists(wd):
            os.makedirs(wd)

        os.chdir(wd)

        run_amp = '''#!/usr/bin/env python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

calc = Amp(label="./",
           descriptor=Behler(cutoff=6.0),
           regression=NeuralNetwork(hiddenlayers={0}))

calc.train("~/Research/Bulk/database/db0/train.db", # The training data
           cores=1,
           extend_variables=False) 
'''.format(layer)

        cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=100:00:00
#PBS -l mem=8GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

        with open('submit.py', 'w') as f:
            f.write(run_amp)
        os.chmod('submit.py', 0777)

        with open('submit.sh', 'w') as f:
            f.write(cmd)

        subprocess.call(['qsub', 'submit.sh'])
        time.sleep(5)
        os.unlink('submit.sh')
        os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1428600.gilgamesh.cheme.cmu.edu
: 1428601.gilgamesh.cheme.cmu.edu
: 1428602.gilgamesh.cheme.cmu.edu
: 1428603.gilgamesh.cheme.cmu.edu
: 1428604.gilgamesh.cheme.cmu.edu
: 1428605.gilgamesh.cheme.cmu.edu
: 1428606.gilgamesh.cheme.cmu.edu
: 1428607.gilgamesh.cheme.cmu.edu

** Update

#+BEGIN_SRC python
from ase.db import connect
from amp import Amp

db = connect('./database/db0/data.db')
calc1 = Amp(load = './database/db0/2-20/-parameters-checkpoint-0.json')
calc2 = Amp(load = './database/db0/2-25/-parameters-checkpoint-0.json')

for d in db.select():
    atoms = db.get_atoms(d.id)
    atoms.set_calculator(calc1)
    nrg1 = atoms.get_potential_energy()

    atoms.set_calculator(calc2)
    nrg2 = atoms.get_potential_energy()
    db.update(d.id, NN20 = nrg1, NN25 = nrg2)
#+END_SRC

#+RESULTS:

** Residual
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from ase.db import connect
from amp import Amp
import os

db = connect('database/db0/data.db')

fig, ax = plt.subplots(1, 2, sharey=True, figsize=(8, 4))

for i, n in enumerate([20, 18]):

    E, nnE, var, ind = [], [], [], []
    for j, d in enumerate(db.select('')):# dbkey=0
	E += [d.energy / d.natoms]
	nnE += [d['NN{}'.format(n)]/ d.natoms]
	var += [j]
	ind += [d.train_set]

    res = np.array(nnE) - np.array(E)
    mask = np.array(ind)
    valid = np.ma.masked_array(res, mask)
    train = np.ma.masked_array(res, ~mask)
    vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
    tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))

    ax[i].text(5, -0.010,
               'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
               color='b', ha='left')
    ax[i].text(5, -0.012,
               'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
               color='r', ha='left')

    ax[i].scatter(var, train, color='b')
    ax[i].scatter(var, valid, color='r')
    ax[i].plot([min(var), max(var)], [0, 0], 'k--')
    ax[i].set_xlim(min(var), max(var))

    ax[i].set_xlabel('Calculation ID')
    ax[i].set_title('8-{0}-{0}-1 framework'.format(n))

ax[0].set_ylim(-0.015, 0.015)
ax[0].set_ylabel('Residual error (eV/atom)')
plt.tight_layout()
plt.savefig('./figures/residual-1.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/residual-1.png]]

* Application
** Vacancy formation
*** 222
     
#+BEGIN_SRC python
from jasp import *
with jasp('./DFT/relaxed=True/bulk=fcc/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    E0 = E0 * 8

with jasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=222/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E1 = atoms.get_potential_energy()
    
print E1 - E0*7/8.0
print E0
print E1
#+END_SRC

#+RESULTS:
: 1.06876678
: -41.71703416
: -35.43363811


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 2, 2)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (7/8.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  16:17:22      -35.425995       0.0000
: Vacancy formation energy with NN is: 1.233 eV
: -41.8964497535
: -35.4259953432

*** 223
     
#+BEGIN_SRC python
from jasp import *
with jasp('./DFT/relaxed=True/bulk=fcc/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    E0 = E0 * 12

with jasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=223/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E1 = atoms.get_potential_energy()
    
print E1 - E0*11/12.0
print E0
print E1
#+END_SRC

#+RESULTS:
: 1.13686192
: -62.57555124
: -56.22406005


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 2, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (11/12.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  16:01:25      -56.223696       0.0612
BFGS:   1  16:01:28      -56.223950       0.0614
BFGS:   2  16:01:34      -55.888867       1.2340
BFGS:   3  16:01:37      -56.224515       0.1683
BFGS:   4  16:01:41      -56.225162       0.0664
BFGS:   5  16:01:46      -56.223440       0.5872
BFGS:   6  16:01:49      -55.881439       1.8661
BFGS:   7  16:01:52      -56.195122       2.7989
BFGS:   8  16:01:56      -56.200861       2.8939
BFGS:   9  16:01:59      -56.147653       2.9650
BFGS:  10  16:02:04      -56.083272       0.9322
BFGS:  11  16:02:07      -56.083548       0.8520
BFGS:  12  16:02:11      -56.072413       0.1074
BFGS:  13  16:02:14      -56.072930       0.0848
BFGS:  14  16:02:19      -56.077142       0.1149
BFGS:  15  16:02:22      -56.084386       0.1064
BFGS:  16  16:02:25      -56.089207       0.0856
BFGS:  17  16:02:28      -56.090064       0.3287
BFGS:  18  16:02:32      -56.094426       0.3931
BFGS:  19  16:02:35      -56.096148       2.0402
BFGS:  20  16:02:38      -56.101788       0.1326
BFGS:  21  16:02:41      -56.102540       0.2125
BFGS:  22  16:02:44      -56.054526       5.2848
BFGS:  23  16:02:48      -56.104337       0.1582
BFGS:  24  16:02:52      -56.106317       0.1397
BFGS:  25  16:02:56      -56.110466       1.4389
BFGS:  26  16:03:00      -56.111091       0.1313
BFGS:  27  16:03:03      -56.114277       0.1625
BFGS:  28  16:03:07      -56.086505       3.8736
BFGS:  29  16:03:11      -56.116809       0.1662
BFGS:  30  16:03:14      -56.118950       0.1784
BFGS:  31  16:03:17      -56.123206       1.2603
BFGS:  32  16:03:21      -56.124143       0.2465
BFGS:  33  16:03:24      -56.125957       0.3256
BFGS:  34  16:03:27      -56.126528       0.9731
BFGS:  35  16:03:31      -56.128367       0.3836
BFGS:  36  16:03:34      -56.129191       0.3385
BFGS:  37  16:03:38      -56.131701       0.3101
BFGS:  38  16:03:41      -56.132418       0.2366
BFGS:  39  16:03:44      -56.133312       0.1430
BFGS:  40  16:03:49      -56.133836       0.1258
BFGS:  41  16:03:52      -56.134794       0.0830
BFGS:  42  16:03:55      -56.135290       0.0766
BFGS:  43  16:03:59      -56.136382       0.1018
BFGS:  44  16:04:03      -56.137074       0.1014
BFGS:  45  16:04:06      -56.140119       0.0794
BFGS:  46  16:04:09      -56.142184       0.0833
BFGS:  47  16:04:13      -56.143207       0.0508
BFGS:  48  16:04:16      -56.142751       0.2729
BFGS:  49  16:04:19      -56.142639       0.0728
BFGS:  50  16:04:22      -56.143307       0.0532
BFGS:  51  16:04:26      -56.144844       0.0418
Vacancy formation energy with NN is: 1.463 eV
-62.8446746302
-56.1448437589
#+end_example

*** 233
     
#+BEGIN_SRC python
from jasp import *
with jasp('./DFT/relaxed=True/bulk=fcc/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    E0 = E0 * 18

with jasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=233/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E1 = atoms.get_potential_energy()
    
print E1 - E0*17/18.0
print E0
print E1
#+END_SRC

#+RESULTS:
: 1.15787387
: -93.86332686
: -87.49082372


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 3, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (17/18.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  16:20:19      -87.440575       1.1271
: BFGS:   1  16:20:26      -87.453983       0.0311
: Vacancy formation energy with NN is: 1.576 eV
: -94.2670119454
: -87.4539826064

*** 333
     
#+BEGIN_SRC python
from jasp import *
with jasp('./DFT/relaxed=True/bulk=fcc/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    E0 = E0 * 27

with jasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=333/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E1 = atoms.get_potential_energy()
    
print E1 - E0*26/27.0
print E0
print E1
#+END_SRC

#+RESULTS:
: 1.10490713
: -140.79499029
: -134.47545389


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (3, 3, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (26/27.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  16:24:51     -134.477875       0.3992
BFGS:   1  16:25:09     -134.468405       0.8071
BFGS:   2  16:25:25     -134.464655       0.5516
BFGS:   3  16:25:40     -134.467827       0.3581
BFGS:   4  16:25:55     -134.429471       1.4055
BFGS:   5  16:26:11     -134.395081       5.4958
BFGS:   6  16:26:25     -134.440105       1.9102
BFGS:   7  16:26:40     -134.455258       1.4404
BFGS:   8  16:26:54     -134.286076       2.2246
BFGS:   9  16:27:09     -134.457750       0.7766
BFGS:  10  16:27:23     -134.453631       0.9435
BFGS:  11  16:27:37     -134.391792       3.5046
BFGS:  12  16:27:52     -134.457622       1.2063
BFGS:  13  16:28:06     -134.467813       0.3232
BFGS:  14  16:28:20     -134.416929       2.7551
BFGS:  15  16:28:35     -134.475881       0.1593
BFGS:  16  16:28:49     -134.479074       0.1322
BFGS:  17  16:29:03     -134.243555       5.7355
BFGS:  18  16:29:18     -134.481547       0.0978
BFGS:  19  16:29:32     -134.483571       0.0799
BFGS:  20  16:29:46     -134.520602       0.3048
BFGS:  21  16:30:01     -134.278988       4.6688
BFGS:  22  16:30:15     -134.527945       4.1324
BFGS:  23  16:30:29     -134.512940       0.1768
BFGS:  24  16:30:44     -134.526350       0.2272
BFGS:  25  16:30:59     -134.496047       2.0505
BFGS:  26  16:31:13     -134.546638       0.4713
BFGS:  27  16:31:27     -134.561798       0.5825
BFGS:  28  16:31:41     -134.056127       5.7977
BFGS:  29  16:31:56     -134.567987       0.8830
BFGS:  30  16:32:10     -134.561362       1.0052
BFGS:  31  16:32:24     -134.388341       2.9986
BFGS:  32  16:32:39     -134.523007       0.9711
BFGS:  33  16:32:53     -134.507802       0.5886
BFGS:  34  16:33:08     -134.460927       1.5441
BFGS:  35  16:33:22     -134.478955       0.3877
BFGS:  36  16:33:37     -134.483606       0.2983
BFGS:  37  16:33:51     -134.409312       3.3928
BFGS:  38  16:34:06     -134.492459       0.3363
BFGS:  39  16:34:21     -134.497496       0.3425
BFGS:  40  16:34:36     -134.452054      10.4915
BFGS:  41  16:34:51     -134.504803       0.3159
BFGS:  42  16:35:06     -134.507730       0.6701
BFGS:  43  16:35:21     -134.510506       1.3799
BFGS:  44  16:35:35     -134.529125       0.7931
BFGS:  45  16:35:50     -134.556153       1.6488
BFGS:  46  16:36:05     -134.673846       1.5687
BFGS:  47  16:36:20     -134.266504       9.3334
BFGS:  48  16:36:34     -134.703085       0.6334
BFGS:  49  16:36:49     -134.706754       0.2829
BFGS:  50  16:37:04     -134.711601       0.0826
BFGS:  51  16:37:19     -134.713086       1.0839
BFGS:  52  16:37:34     -134.716229       0.1208
BFGS:  53  16:37:49     -134.718122       0.1076
BFGS:  54  16:38:03     -134.710053       1.1629
BFGS:  55  16:38:18     -134.720366       0.1541
BFGS:  56  16:38:33     -134.721177       0.1858
BFGS:  57  16:38:48     -134.321413       9.8658
BFGS:  58  16:39:03     -134.723118       0.1084
BFGS:  59  16:39:18     -134.723746       0.0811
BFGS:  60  16:39:32     -134.724334       0.3969
BFGS:  61  16:39:47     -134.724603       0.3455
BFGS:  62  16:40:02     -134.725103       0.1563
BFGS:  63  16:40:17     -134.725705       0.0778
BFGS:  64  16:40:32     -134.726632       0.0702
BFGS:  65  16:40:47     -134.727600       0.1388
BFGS:  66  16:41:02     -134.727469       0.3088
BFGS:  67  16:41:17     -134.727953       0.1155
BFGS:  68  16:41:31     -134.728402       0.0425
Vacancy formation energy with NN is: 1.435 eV
-141.400517918
-134.728401597
#+end_example

** MD
*** Bulk
**** 2000
#+BEGIN_SRC python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

# Set up a crystal
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 2, 2))

# Describe the interatomic interactions with the Effective Medium Theory
atoms.set_calculator(Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json'))
# We want to run MD with constant energy using the Langevin algorithm
# with a time step of 5 fs, the temperature T and the friction
# coefficient to 0.02 atomic units.
dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):  # store a reference to atoms in the definition.
    """Function to print the potential, kinetic and total energy."""
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

# We also want to save the positions of all atoms after every time step.
traj = Trajectory('./database/db0/MD.traj', 'w', atoms)
dyn.attach(traj.write, interval=10)

# Now run the dynamics
dyn.run(2000)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
import jbtools.gilgamesh as jb

Ne = []
for i, atoms in enumerate(Trajectory('./database/db0/MD.traj', 'r')):

    Ne += [atoms.get_potential_energy()]

plt.plot(range(len(Ne)), Ne, 'bo')
#plt.savefig('./images/MD-NN.png')
plt.show()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db0/2-20/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db0/MD.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
#plt.show()
plt.xlabel('MD Step')
plt.ylabel('Energy eV')
plt.legend()
plt.savefig('./figures/MD-1.png')

#+END_SRC

#+RESULTS:

[[./figures/MD-1.png]]
**** 4000
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db0')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 2, 2))

atoms.set_calculator(Amp(load="./2-18/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=20)

traj = Trajectory("./MD-0:8.traj", "w", atoms)
dyn.attach(traj.write, interval=20)

dyn.run(4000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=8GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('0:8')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1429517.gilgamesh.cheme.cmu.edu
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db0/2-20/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db0/MD-0:8.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
#plt.show()
plt.xlabel('MD Step')
plt.ylabel('Energy eV')
plt.legend()
plt.savefig('./figures/0:8-md1.png')
#plt.show()

#+END_SRC

#+RESULTS:

[[./figures/0:8-md1.png]]

*** Vacancy
**** 1:8
#+BEGIN_SRC python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

# Set up a crystal
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 2, 2))

del atoms[0]
# Describe the interatomic interactions with the Effective Medium Theory
atoms.set_calculator(Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json'))
# We want to run MD with constant energy using the Langevin algorithm
# with a time step of 5 fs, the temperature T and the friction
# coefficient to 0.02 atomic units.
dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):  # store a reference to atoms in the definition.
    """Function to print the potential, kinetic and total energy."""
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

# We also want to save the positions of all atoms after every time step.
traj = Trajectory('./database/db0/MD-1:8.traj', 'w', atoms)
dyn.attach(traj.write, interval=10)

# Now run the dynamics
dyn.run(2000)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db0/2-20/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db0/MD-1:8.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,100])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/MD-2.png')
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne,Ne0, nrg, res, s = [], [], [], [], []
calcs = []
images = Trajectory('./database/db0/MD-1:8.traj', 'r')
Ne0 = [images[i].get_potential_energy() for i in range(0, 200)]
for i in np.arange(0, len(images), 4):
    if i != 60:
        Ne +=[Ne0[i]]
        
        calc = Vasp('NDFT/bulk=fcc/type=MD1/MD={}'.format(i),
                     xc='pbe',
                     kpts=[5]*3,
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)

#res = [r for i, r in enumerate(Ne) if i in
#       np.arange(0, len(images), 4) and i != 60]
res = abs(np.array(Ne) - np.array(nrg))

fig, ax = plt.subplots(figsize=(6, 4))
ax.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
ax.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='b', label='DFT prediction')

#ax.set_xlim(min(s), max(s))
ax.set_ylabel('Potential energy (eV)', color='b')
ax.tick_params(axis='y', colors='b')
#ax.set_ylim(-141, -130)
ax.set_xlabel('Time step')
ax.legend(loc=2)

ax1 = ax.twinx()

ax1.scatter(range(len(res)), res, color='r')
ax1.set_ylabel('Absolute residual error (eV)', color='r')
#ax1.set_xlim(min(s), max(s))
ax1.tick_params(axis='y', colors='r')
ax1.set_ylim(0.0, 7.0)

plt.tight_layout()
plt.show()
#+END_SRC

#+RESULTS:

The energy of MD=60 is too high to calculate.

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db0/MD-1:8.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(0, 50)]

calcs = [Vasp('NDFT/bulk=fcc/type=md/order=md1/v:a=1:7/MD={}'.format(i),
            xc='pbe',
            kpts=[9]*3,
            encut=350,
            nsw=0,
            atoms=images[i]) for i in range(50)]

[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)

#res = [r for i, r in enumerate(Ne) if i in
#       np.arange(0, len(images), 4) and i != 60]
res = abs(np.array(Ne) - np.array(nrg))

fig, ax = plt.subplots(figsize=(6, 4))
ax.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
ax.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='b', label='DFT prediction')

#ax.set_xlim(min(s), max(s))
ax.set_ylabel('Potential energy (eV)', color='b')
ax.tick_params(axis='y', colors='b')
#ax.set_ylim(-141, -130)
ax.set_xlabel('Time step')
ax.legend(loc=2)

ax1 = ax.twinx()

ax1.scatter(range(len(res)), res, color='r')
ax1.set_ylabel('Absolute residual error (eV)', color='r')
#ax1.set_xlim(min(s), max(s))
ax1.tick_params(axis='y', colors='r')
ax1.set_ylim(0.0, 7.0)

plt.tight_layout()
plt.show()
#+END_SRC

#+RESULTS:

**** 1:12
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db0')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 2, 3))

del atoms[0]

atoms.set_calculator(Amp(load="./2-18/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=5)

traj = Trajectory("./MD-1:12.traj", "w", atoms)
dyn.attach(traj.write, interval=5)

dyn.run(500)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=8GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('1:12')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1429794.gilgamesh.cheme.cmu.edu

**** 1:18
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db0')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 3, 3))

del atoms[0]

atoms.set_calculator(Amp(load="./2-18/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=5)

traj = Trajectory("./MD-1:18.traj", "w", atoms)
dyn.attach(traj.write, interval=5)

dyn.run(200)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=8GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('1:18')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC
#+RESULTS:
: 1429515.gilgamesh.cheme.cmu.edu

**** 1:27
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db0')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(3, 3, 3))

del atoms[0]

atoms.set_calculator(Amp(load="./2-18/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=5)

traj = Trajectory("./MD-1:27.traj", "w", atoms)
dyn.attach(traj.write, interval=5)

dyn.run(100)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=8GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1429514.gilgamesh.cheme.cmu.edu

**** 1:36
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db0')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(3, 3, 4))

del atoms[0]

atoms.set_calculator(Amp(load="./2-18/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=5)

traj = Trajectory("./MD-1:36.traj", "w", atoms)
dyn.attach(traj.write, interval=5)

dyn.run(50)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=8GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1429513.gilgamesh.cheme.cmu.edu

**** 1:48
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db0')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(3, 4, 4))

del atoms[0]

atoms.set_calculator(Amp(load="./2-18/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=5)

traj = Trajectory("./MD-1:48.traj", "w", atoms)
dyn.attach(traj.write, interval=5)

dyn.run(50)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=8GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1429512.gilgamesh.cheme.cmu.edu

**** 1:64
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db0')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(4, 4, 4))

del atoms[0]

atoms.set_calculator(Amp(load="./2-18/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=5)

traj = Trajectory("./MD-1:64.traj", "w", atoms)
dyn.attach(traj.write, interval=5)

dyn.run(50)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=8GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1429511.gilgamesh.cheme.cmu.edu


* 2nd DFT
** Bulk
*** fcc
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
VASPRC['queue.walltime'] = '24:00:00'

# Fraction of equilibrium lattice constant to be calculated
factor = np.append(np.arange(0.85, 1.2, 0.01),
                   np.arange(1.2, 2.125, 0.05))
#factor = np.delete(factor, 15)

fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)

nrg, calcs = [], []
for f in factor:
    atoms = fcc.copy()

    delta = np.array([[f, 0., 0.],
                      [0., f, 0.],
                      [0., 0., f]])
    atoms.set_cell(np.dot(atoms.get_cell(), delta),
                   scale_atoms=True)

    calc = Vasp('./NDFT/bulk=fcc/type=eos/factor={:.2f}'.format(f),
                xc='pbe',
                kpts=[14]*3,
                encut=350,
                nsw=0,
                atoms=atoms)
    calcs += [calc]
    nrg += [calc.potential_energy]
Vasp.stop_if(None in nrg)

plt.plot(factor, nrg)

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=eos/factor=1.00 submitted: 1443243.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=eos/factor=1.00 Queued: 1443243.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
from ase.db import connect
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState
from ase.units import kJ
import numpy as np
from vasp import Vasp

nrg, t, vol = [], [], []

factor = np.arange(0.85, 1.2, 0.01)
             #      np.arange(1.2, 2.125, 0.05))


for f in factor:
    calc = Vasp('./NDFT/bulk=fcc/type=eos/factor={:.2f}'.format(f))
    atoms = calc.get_atoms()
    nrg += [atoms.get_potential_energy()]
    vol += [atoms.get_volume()]

vol = np.array(vol)
nrg = np.array(nrg)

# Fit the data to SJEOS
eos = EquationOfState(vol, nrg)
v0, e0, B = eos.fit()

x = np.linspace(vol.min(), vol.max(), 250)

plt.scatter(vol, nrg, color='r')
plt.plot(x, eos.fit0(x**-(1.0 / 3)), 'b-')

plt.xlim(vol.min(), vol.max())
plt.ylabel('Potential energy (eV)')

plt.text(vol.max() - 6, nrg.max(),
	 'V$_{0}$={1:1.3f}'.format('{min}', v0),
	 va='center', ha='left')
plt.text(vol.max() - 6, nrg.max() - 0.3,
	 'E$_{0}$={1:1.3f}'.format('{min}', e0),
	 va='center', ha='left')
plt.text(vol.max() - 6, nrg.max() - 0.6,
	 #'B={0:1.0f}'.format(B  / kJ * 1.0e24),
         'B={0:1.3f}'.format(B),
	 va='center', ha='left')


plt.xlabel('Volume ($\AA^{3}$/atom)')
plt.tight_layout()
plt.savefig('./figures/eosfcc.png')
#+END_SRC

#+RESULTS:

[[./figures/eosfcc.png]]

#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState

# Fraction of equilibrium lattice constant to be calculated
factor = np.append(np.arange(0.85, 1.2, 0.01),
                   np.arange(1.2, 2.125, 0.05))
factor = np.delete(factor, 15)

nrg, vol = [], []

for f in factor:
    calc = Vasp('./NDFT/bulk=fcc/type=eos/factor={:.2f}'.format(f))
    atoms = calc.get_atoms()
    nrg += [atoms.get_potential_energy()]
    vol += [atoms.get_volume()]

eos = EquationOfState(vol, nrg)
v0, e0, B0 = eos.fit()
eos.plot('./figures/eos-fcc.png')

ind = np.argmin(nrg)
print 3.939 * factor[ind]
#+END_SRC

#+RESULTS:
: 3.97839


[[./figures/eos-fcc.png]]
**** cutoff
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
VASPRC['queue.walltime'] = '24:00:00'

# Fraction of equilibrium lattice constant to be calculated
factor = np.arange(2.1, 2.6, 0.05)

fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


nrg, calcs = [], []

for f in factor:
    atoms = fcc.copy()

    delta = np.array([[f, 0., 0.],
                      [0., f, 0.],
                      [0., 0., f]])
    atoms.set_cell(np.dot(atoms.get_cell(), delta),
                   scale_atoms=True)

    calc = Vasp('./NDFT/bulk=fcc/type=test/factor={:.2f}'.format(f),
                xc='pbe',
                kpts=[14]*3,
                encut=350,
                nsw=0,
                atoms=atoms)
    calcs += [calc]
    nrg += [calc.potential_energy]


#+END_SRC

#+RESULTS:
#+begin_example
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.10 submitted: 1443893.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.10 Queued: 1443893.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.15 submitted: 1443894.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.15 Queued: 1443894.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.20 submitted: 1443895.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.20 Queued: 1443895.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.25 submitted: 1443896.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.25 Queued: 1443896.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.30 submitted: 1443897.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.30 Queued: 1443897.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.35 submitted: 1443898.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.35 Queued: 1443898.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.40 submitted: 1443899.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.40 Queued: 1443899.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.45 submitted: 1443900.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.45 Queued: 1443900.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.50 submitted: 1443901.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.50 Queued: 1443901.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.55 submitted: 1443902.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.55 Queued: 1443902.gilgamesh.cheme.cmu.edu
#+end_example

*** bcc
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
import numpy as np
from ase.lattice.cubic import BodyCenteredCubic
import matplotlib.pyplot as plt
VASPRC['queue.walltime'] = '24:00:00'

# Fraction of equilibrium lattice constant to be calculated
factor = np.append(np.arange(0.85, 1.2, 0.01),
                   np.arange(1.2, 2.125, 0.05))

bcc = BodyCenteredCubic('Pd',
                        directions=[[-1, 1, 1],
                                    [1, -1, 1],
                                    [1, 1, -1]],
                        latticeconstant = 3.136)

nrg, calcs = [], []
for f in factor:
    atoms = bcc.copy()

    delta = np.array([[f, 0., 0.],
                      [0., f, 0.],
                      [0., 0., f]])
    atoms.set_cell(np.dot(atoms.get_cell(), delta),
                   scale_atoms=True)

    calc = Vasp('./NDFT/bulk=bcc/type=eos/factor={:.2f}'.format(f),
                xc='pbe',
                kpts=[14]*3,
                encut=350,
                nsw=0,
                atoms=atoms)
    calcs += [calc]
    nrg += [calc.potential_energy]
Vasp.stop_if(None in nrg)

plt.plot(factor, nrg)
plt.show()
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=bcc/type=eos/factor=1.00 submitted: 1443249.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=bcc/type=eos/factor=1.00 Queued: 1443249.gilgamesh.cheme.cmu.edu

*** hcp
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
import numpy as np
from ase.lattice.hexagonal import HexagonalClosedPacked
import matplotlib.pyplot as plt
VASPRC['queue.walltime'] = '24:00:00'

# Fraction of equilibrium lattice constant to be calculated
factor = np.append(np.arange(0.85, 1.2, 0.01),
                   np.arange(1.2, 2.125, 0.05))


hcp = HexagonalClosedPacked('Pd',
                            latticeconstant = {'a':2.767, 'c/a':1.674})

nrg, calcs = [], []
for f in factor:
    atoms = hcp.copy()

    delta = np.array([[f, 0., 0.],
                      [0., f, 0.],
                      [0., 0., f]])
    atoms.set_cell(np.dot(atoms.get_cell(), delta),
                   scale_atoms=True)

    calc = Vasp('./NDFT/bulk=hcp/type=eos/factor={:.2f}'.format(f),
                xc='pbe',
                kpts=[14]*3,
                encut=350,
                nsw=0,
                atoms=atoms)
    calcs += [calc]
    nrg += [calc.potential_energy]
Vasp.stop_if(None in nrg)

plt.plot(factor, nrg)
plt.show()
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=hcp/type=eos/factor=1.00 submitted: 1443253.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=hcp/type=eos/factor=1.00 Queued: 1443253.gilgamesh.cheme.cmu.edu

*** sc
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
import numpy as np
from ase.lattice.cubic import SimpleCubic
import matplotlib.pyplot as plt
VASPRC['queue.walltime'] = '24:00:00'

# Fraction of equilibrium lattice constant to be calculated
factor = np.append(np.arange(0.85, 1.2, 0.01),
                   np.arange(1.2, 2.125, 0.05))

sc = SimpleCubic('Pd',
                  latticeconstant=2.612)

nrg, calcs = [], []
for f in factor:
    atoms = sc.copy()

    delta = np.array([[f, 0., 0.],
                      [0., f, 0.],
                      [0., 0., f]])
    atoms.set_cell(np.dot(atoms.get_cell(), delta),
                   scale_atoms=True)

    calc = Vasp('./NDFT/bulk=sc/type=eos/factor={:.2f}'.format(f),
                xc='pbe',
                kpts=[14]*3,
                encut=350,
                nsw=0,
                atoms=atoms)
    calcs += [calc]
    nrg += [calc.potential_energy]
Vasp.stop_if(None in nrg)

plt.plot(factor, nrg)
plt.show()
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=sc/type=eos/factor=1.00 submitted: 1443254.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=sc/type=eos/factor=1.00 Queued: 1443254.gilgamesh.cheme.cmu.edu

*** diam
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
import numpy as np
from ase.lattice.cubic import Diamond
import matplotlib.pyplot as plt
VASPRC['queue.walltime'] = '24:00:00'

# Fraction of equilibrium lattice constant to be calculated
#factor = np.append(np.arange(0.85, 1.2, 0.01),
#                   np.arange(1.2, 2.125, 0.05))
factor = [1.00]

diam = Diamond('Pd',
                latticeconstant=5.800)

nrg, calcs = [], []
for f in factor:
    atoms = diam.copy()

    delta = np.array([[f, 0., 0.],
                      [0., f, 0.],
                      [0., 0., f]])
    atoms.set_cell(np.dot(atoms.get_cell(), delta),
                   scale_atoms=True)

    calc = Vasp('./NDFT/bulk=diam/type=eos/factor={:.2f}'.format(f),
                xc='pbe',
                kpts=[9]*3,
                encut=350,
                nsw=0,
                atoms=atoms)
    calcs += [calc]
    nrg += [calc.potential_energy]
Vasp.stop_if(None in nrg)

plt.plot(factor, nrg)
plt.show()

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=diam/type=eos/factor=1.00 submitted: 1443255.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=diam/type=eos/factor=1.00 Queued: 1443255.gilgamesh.cheme.cmu.edu

*** all
#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState
from ase.units import kJ


factor = np.append(np.arange(0.85, 1.2, 0.01),
                   np.arange(1.2, 2.125, 0.05))
factor = np.delete(factor, 15)

E_fcc, E_bcc, E_hcp, E_sc, E_diamond = [], [], [], [], []
Energy = [E_fcc, E_bcc, E_hcp, E_sc, E_diamond]

V_fcc, V_bcc, V_hcp, V_sc, V_diamond = [], [], [], [], []
Volume = [V_fcc, V_bcc, V_hcp, V_sc, V_diamond]

structure = ['fcc', 'bcc', 'hcp', 'sc','diam']

for i, struc in enumerate(structure):
    
    for j,x in enumerate(factor):
        wd = 'NDFT/bulk={0}/type=eos/factor={1:1.2f}'.format(struc,x)

        calc = Vasp(wd)
        atoms = calc.get_atoms()

        Energy[i].append(atoms.get_potential_energy()/len(atoms))
        Volume[i].append(atoms.get_volume()/len(atoms))

'''
if ready:
    for i in range (4):
        eos = EquationOfState(Volume[i], Energy[i])
        eos.plot('images/eos-{0}.png'.format(structure[i]))
     
'''

for i in range(5):
    plt.plot(Volume[i], Energy[i], label='{0}'.format(structure[i]))
    plt.legend()
    plt.xlim([5, 40])
    plt.xlabel('Volume $\AA^3$/Atom')
    plt.ylabel('Energy eV/Atom')
    
    eos = EquationOfState(Volume[i], Energy[i])
    v0, e0, B = eos.fit()
    print v0
plt.savefig('figures/eos-DFT.png')
            

#+END_SRC

#+RESULTS:
: 16.1590488245
: 16.2672564781
: 16.2287594512
: 18.706797844
: 25.477211224

[[./figures/eos-DFT.png]]
#+BEGIN_SRC python
from ase.db import connect
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState
from ase.units import kJ
import numpy as np
from vasp import Vasp

factor = np.arange(0.85, 1.2, 0.01)
             #      np.arange(1.2, 2.125, 0.05))
configs = ['fcc', 'bcc', 'hcp', 'sc', 'diam']

for config in configs:
    nrg, vol = [], []
    for f in factor:
        calc = Vasp('./NDFT/bulk={0}/type=eos/factor={1:.2f}'.format(config,f))
        atoms = calc.get_atoms()
        nrg += [atoms.get_potential_energy()]
        vol += [atoms.get_volume()]

    vol = np.array(vol)
    nrg = np.array(nrg)

# Fit the data to SJEOS
    eos = EquationOfState(vol, nrg)
    v0, e0, B = eos.fit()
    print '{0}'.format(config)
    print v0, e0, B
#+END_SRC

#+RESULTS:
#+begin_example
fcc
15.2979724806 -5.22438476072 1.09507457295
bcc
15.4257962561 -5.18249419589 1.06469804063
hcp
30.7291538438 -10.3875916525 1.08254355793
sc
17.8024966568 -4.72110919112 0.782438954048
diam
194.846481429 -32.6504639127 0.428150007251
#+end_example

** MD
*** 0:8
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
from vasp import Vasp
from vasp.vasprc import VASPRC

VASPRC['queue.walltime'] = '24:00:00'

calc1 = Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db0/2-20/-parameters-checkpoint-0.json')
images = Trajectory('./database/db0/MD-0:8.traj', 'r')
E1, E2 = [], []

for atoms in images:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in images:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)
res = E1-E2
res = np.array(res)
x = np.absolute(res)
t = []

for i in range(len(x)):
    if x[i] > 0.002:
        t += [i]



Ne, nrg, res, s = [], [], [], []
calcs = []

Ne = [images[i].get_potential_energy() for i in t]

for i in t:        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=0_8/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9]*3,
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy/8.0 for calc in calcs]
Vasp.stop_if(None in nrg)

plt.plot(range(len(E1)), E1, 'b-', label='NN prediction')
plt.plot(range(len(E2)), E2, 'r--', label='NN prediction')
plt.scatter(t, nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(E1)))
plt.ylabel('Potential energy (eV)')

plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/0-8md-1.png')

#+END_SRC

#+RESULTS:

[[./figures/0-8md-1.png]]
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
from vasp import Vasp
from vasp.vasprc import VASPRC

VASPRC['queue.walltime'] = '24:00:00'

images = Trajectory('./database/db0/MD-0:8.traj', 'r')

calcs = []
Ne = [images[i].get_potential_energy() for i in range(200)]

for i in range(200):        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=0_8/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9]*3,
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy/8.0 for calc in calcs]
Vasp.stop_if(None in nrg)

plt.plot(range(len(Ne)), E1, 'b-', label='NN prediction')
plt.scatter(t, nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(E1)))
plt.ylabel('Potential energy (eV)')

plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.show()

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory

from vasp import Vasp
from vasp.vasprc import VASPRC

VASPRC['queue.walltime'] = '24:00:00'
calcs = []
for i in range(200):        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=0_8/MD={}'.format(i))
        calcs +=[calc] 
        calc.set_memory()
        calc.calculate()

#+END_SRC
#+RESULTS:

*** 1:7
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db0/MD-1:8.traj', 'r')
#Ne = [images[i].get_potential_energy() for i in range(0, 100)]
Ne = [images[i].get_potential_energy() for i in range(0, 51)]
#for i in np.arange(0, 100, 4):
for i in range(51):        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_7/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9]*3,
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)

plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-7md-1.png')
#+END_SRC

#+RESULTS:

[[./figures/1-7md-1.png]]

*** 1:11
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne,Ne0, nrg, res, s = [], [], [], [], []
calcs = []
images = Trajectory('./database/db0/MD-1:12.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(0, 22)]
for i in np.arange(0, 22):

        calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_11/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9,9,5],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)

plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-11md-1.png')
#+END_SRC

#+RESULTS:

[[./figures/1-11md-1.png]]

*** 1:17
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db0/MD-1:18.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(38)]
for i in np.arange(0, 38):
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_17/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9, 5, 5],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)

plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-17md-1.png')
#+END_SRC

#+RESULTS:

[[./figures/1-17md-1.png]]
*** 1:26
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db0/MD-1:27.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(16)]
for i in np.arange(0, 16):
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_26/MD={}'.format(i),
                     xc='pbe',
                     kpts=[5, 5, 5],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)


plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-26md-1.png')
#+END_SRC

#+RESULTS:

[[./figures/1-26md-1.png]]

*** 1:35
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db0/MD-1:36.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(0, len(images))]
for i in np.arange(0, len(images)):
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_35/MD={}'.format(i),
                     xc='pbe',
                     kpts=[5, 5, 3],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)


plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-35md-1.png')
#+END_SRC

#+RESULTS:

[[./figures/1-35md-1.png]]
*** 1:47
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db0/MD-1:48.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(0, len(images))]
for i in np.arange(0, len(images)):
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_47/MD={}'.format(i),
                     xc='pbe',
                     kpts=[5, 3, 3],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)


plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-47md-1.png')
#+END_SRC

#+RESULTS:

[[./figures/1-47md-1.png]]

*** 1:63
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db0/MD-1:64.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(0, len(images))]
for i in np.arange(0, len(images)):
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_63/MD={}'.format(i),
                     xc='pbe',
                     kpts=[3, 3, 3],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)

plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-63md-1.png')
#+END_SRC

#+RESULTS:

[[./figures/1-63md-1.png]]

** Vacancy Diffusion NEB
*** 2*2*2
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '8GB'
VASPRC['wall.time'] = '24:00:00'
fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 2, 2])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb-initial',
          xc='pbe',
          kpts=[9, 9, 9],
          encut=350,
          atoms=ini)

fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb-final',
            xc='pbe',
            kpts=[9, 9, 9],
            encut=350,
            atoms=fin)

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb',
            xc='pbe',
            kpts=[9, 9, 9],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/222-NEB.png')
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.675637
:          Iterations: 15
:          Function evaluations: 30

[[./figures/NEB-7.png]]

#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d
from ase.calculators.singlepoint import SinglePointCalculator as SPC

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
images, energies = calc.get_neb()

En, E = [], []
calc2 = Amp('./database/db1/2-24-2/-parameters-checkpoint-0.json')

for atoms in images:
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

En = np.array(En)
E = En-En[0]
x = range(len(images))
xarray = np.linspace(0, len(images))
f1 = interp1d(x, energies, kind='cubic', bounds_error=False)
f2 = interp1d(x, E, kind='cubic', bounds_error=False)
plt.plot(x, energies, 'bo', label = 'NEB')
plt.plot(x, E, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')

plt.savefig('./figures/NEB-NN-222.png')

#+END_SRC

#+RESULTS:

[[./figures/NEB-NN-222.png]]
#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
from ase.calculators.singlepoint import SinglePointCalculator as SPC
from ase.db import connect

db = connect('database/db2/data.db')
E0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb-initial').potential_energy
E = []
calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
images, energies = calc.get_neb()


[atoms.set_calculator(SPC(atoms, energy=energies[i]))
for i, atoms in enumerate(images)]

for i, atoms in enumerate(images):
    E += [atoms.get_potential_energy()+E0]

for i, image in enumerate (images):

    db.write(atoms, {'bulk':'fcc', 'dbkey':2, 'type':'neb', 'supercell':222})
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d
from ase.calculators.singlepoint import SinglePointCalculator as SPC

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
calc.view()
#+END_SRC

#+RESULTS:

**** MD for NEB
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db1')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from vasp import Vasp

calc = Vasp("../../NDFT/bulk=fcc/type=neb/supercell=222/neb")
images, energies = calc.get_neb()


atoms = images[4]

atoms.set_calculator(Amp(load="./2-24-2/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MDimage4.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('image4')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1444076.gilgamesh.cheme.cmu.edu

*** 2*2*3
c0-end
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['wall.time'] = '24:00:00'
fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 2, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-initial',
          xc='pbe',
          kpts=[9, 9, 5],
          encut=350,
          atoms=ini)
c0.calculate()
fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-final',
            xc='pbe',
            kpts=[9, 9, 5],
            encut=350,
            atoms=fin)
cend.calculate()
#+END_SRC

#+RESULTS:
: No calculation_required.
: No calculation_required.


#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '8GB'

fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 2, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-initial',
          xc='pbe',
          kpts=[9, 9, 5],
          encut=350,
          atoms=ini)

fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-final',
            xc='pbe',
            kpts=[9, 9, 5],
            encut=350,
            atoms=fin)

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb',
            xc='pbe',
            kpts=[9, 9, 5],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/223-NEB.png')
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.752733
:          Iterations: 15
:          Function evaluations: 30

[[./figures/223-NEB.png]]
#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb')
images, energies = calc.get_neb()
En, E = [], []
calc2 = Amp('./database/db1/2-24-2/-parameters-checkpoint-0.json')

for atoms in images:
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

En = np.array(En)
E = En-En[0]
x = range(len(images))
xarray = np.linspace(0, len(images))
f1 = interp1d(x, energies, kind='cubic', bounds_error=False)
f2 = interp1d(x, E, kind='cubic', bounds_error=False)
plt.plot(x, energies, 'bo', label = 'NEB')
plt.plot(x, E, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')

plt.savefig('./figures/NEB-NN-223.png')
#+END_SRC

#+RESULTS:

[[./figures/NEB-NN-223.png]]

**** MD
#+BEGIN_SRC python
,#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

for n in [1, 2, 3, 4]:
    label = '223-Image{0}'.format(n)
    wd = os.path.join(home, './database/db1/' + label)

    if not os.path.exists(wd):
        os.makedirs(wd)

    os.chdir(wd)
    run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from vasp import Vasp

calc = Vasp("../../../NDFT/bulk=fcc/type=neb/supercell=223/neb")
images, energies = calc.get_neb()


atoms = images[{0}]

atoms.set_calculator(Amp(load="../2-24-2/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./{1}.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''.format(n, label)

    cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

    with open('submit.py', 'w') as f:
        f.write(run_md)
    os.chmod('submit.py', 0777)

    with open('submit.sh', 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', 'submit.sh'])
    time.sleep(5)
    os.unlink('submit.sh')
    os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1444078.gilgamesh.cheme.cmu.edu
: 1444079.gilgamesh.cheme.cmu.edu
: 1444080.gilgamesh.cheme.cmu.edu
: 1444081.gilgamesh.cheme.cmu.edu

#+END_SRC
**** test
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['wall.time'] = '24:00:00'
fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 2, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=test/supercell=223/neb-initial',
          xc='pbe',
          kpts=[9, 9, 5],
          encut=350,
          atoms=ini)
c0.calculate()
fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=test/supercell=223/neb-final',
            xc='pbe',
            kpts=[9, 9, 5],
            encut=350,
            atoms=fin)
cend.calculate()
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/supercell=223/neb-initial submitted: 1447139.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/supercell=223/neb-final submitted: 1447140.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python

from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '8GB'

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=test/supercell=223/neb-initial')
ini = c0.get_atoms()

cend = Vasp('NDFT/bulk=fcc/type=test/supercell=223/neb-final')
fin = cend.get_atoms()

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=test/supercell=223/neb',
            xc='pbe',
            kpts=[9, 9, 5],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/223-NEB-test.png')
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.752733
:          Iterations: 15
:          Function evaluations: 30

[[./figures/223-NEB-test.png]]
*** 2*3*3
c0-end
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['wall.time'] = '24:00:00'
fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 3, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-initial',
          xc='pbe',
          kpts=[9, 5, 5],
          encut=350,
          atoms=ini)
c0.calculate()
fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-final',
            xc='pbe',
            kpts=[9, 5, 5],
            encut=350,
            atoms=fin)
cend.calculate()
#+END_SRC

#+RESULTS:
: No calculation_required.
: No calculation_required.


#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '8GB'


# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-initial')
ini = c0.get_atoms()

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-final')
fin = cend.get_atoms()

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb',
            xc='pbe',
            kpts=[9, 5, 5],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/233-NEB.png')
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.711185
:          Iterations: 15
:          Function evaluations: 30

[[./figures/233-NEB.png]]

#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb')
images, energies = calc.get_neb()
En, E = [], []
calc2 = Amp('./database/db1/2-24-2/-parameters-checkpoint-0.json')

for atoms in images:
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

En = np.array(En)
E = En-En[0]
x = range(len(images))
xarray = np.linspace(0, len(images))
f1 = interp1d(x, energies, kind='cubic', bounds_error=False)
f2 = interp1d(x, E, kind='cubic', bounds_error=False)
plt.plot(x, energies, 'bo', label = 'NEB')
plt.plot(x, E, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')

plt.savefig('./figures/NEB-NN-233.png')
#+END_SRC

#+RESULTS:

[[./figures/NEB-NN-233.png]]
*** 3*3*3
c0-end
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
				    latticeconstant = 3.939)


atoms = fcc.repeat([3, 3, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb-initial',
          xc='pbe',
          kpts=[5, 5, 5],
          encut=350,
          atoms=ini)
c0.calculate()
fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb-final',
            xc='pbe',
            kpts=[5, 5, 5],
            encut=350,
            atoms=fin)
cend.calculate()
#+END_SRC

#+RESULTS:
: No calculation_required.
: No calculation_required.


#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '8GB'


# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb-initial')
ini = c0.get_atoms()

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb-final')
fin = cend.get_atoms()

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb',
            xc='pbe',
            kpts=[5, 5, 5],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/333-NEB.png')
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.745283
:          Iterations: 15
:          Function evaluations: 30

[[./images/333-NEB.png]]

#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d
from ase.calculators.singlepoint import SinglePointCalculator as SPC

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb')
images, energies = calc.get_neb()

En, E = [], []
calc2 = Amp('./database/db1/2-24-2/-parameters-checkpoint-0.json')

for atoms in images:
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

En = np.array(En)
E = En-En[0]
x = range(len(images))
xarray = np.linspace(0, len(images))
f1 = interp1d(x, energies, kind='cubic', bounds_error=False)
f2 = interp1d(x, E, kind='cubic', bounds_error=False)
plt.plot(x, energies, 'bo', label = 'NEB')
plt.plot(x, E, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')

plt.savefig('./figures/NEB-NN-333.png')

#+END_SRC

#+RESULTS:

[[./figures/NEB-NN-333.png]]

**** MD
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

for n in [1, 2, 3, 4]:
    label = '333-Image{0}'.format(n)
    wd = os.path.join(home, './database/db1/' + label)

    if not os.path.exists(wd):
        os.makedirs(wd)

    os.chdir(wd)
    run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from vasp import Vasp

calc = Vasp("../../../NDFT/bulk=fcc/type=neb/supercell=223/neb")
images, energies = calc.get_neb()


atoms = images[{0}]

atoms.set_calculator(Amp(load="../2-24-2/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./{1}.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''.format(n, label)

    cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

    with open('submit.py', 'w') as f:
        f.write(run_md)
    os.chmod('submit.py', 0777)

    with open('submit.sh', 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', 'submit.sh'])
    time.sleep(5)
    os.unlink('submit.sh')
    os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1446868.gilgamesh.cheme.cmu.edu
: 1446869.gilgamesh.cheme.cmu.edu
: 1446870.gilgamesh.cheme.cmu.edu
: 1446871.gilgamesh.cheme.cmu.edu

#+END_SRC
*** Comparison
#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d
from ase.calculators.singlepoint import SinglePointCalculator as SPC

calc1 = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
images1, energies1 = calc1.get_neb()

calc2 = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb')
images2, energies2 = calc2.get_neb()

calc3 = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb')
images3, energies3 = calc3.get_neb()

calc4 = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb')
images4, energies4 = calc4.get_neb()

x = range(len(images1))
xarray = np.linspace(0, len(images1))
f1 = interp1d(x, energies1, kind='cubic', bounds_error=False)
f2 = interp1d(x, energies2, kind='cubic', bounds_error=False)
f3 = interp1d(x, energies3, kind='cubic', bounds_error=False)
f4 = interp1d(x, energies4, kind='cubic', bounds_error=False)


plt.plot(x, energies1, 'bo', label='222')
plt.plot(x, energies2, 'ro', label='223')
plt.plot(x, energies3, 'co', label='233')
plt.plot(x, energies4, 'mo', label='333')


plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.plot(xarray, f3(xarray), 'c-')
plt.plot(xarray, f4(xarray), 'm-')

plt.annotate('',xy=(1,0.03),xytext=((1,0.1)),arrowprops=dict(arrowstyle="->",connectionstyle="arc3"))
plt.annotate('',xy=(4,0.67),xytext=((4,0.6)),arrowprops=dict(arrowstyle="->",connectionstyle="arc3"))

plt.xlabel('Images')
plt.ylabel('Reference Potential Energy(eV/atom)')
plt.legend(loc = 'best')
plt.legend()
plt.savefig('./figures/NEB-all.png')
#+END_SRC

#+RESULTS:

[[./figures/NEB-all.png]]

#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d
from ase.calculators.singlepoint import SinglePointCalculator as SPC

calc1 = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
calc0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb-initial')
E0 = calc0.potential_energy
images1, energies1 = calc1.get_neb()
energies1 = energies1 + E0

calc2 = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb')
images2, energies2 = calc2.get_neb()
calc0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-initial')
E0 = calc0.potential_energy
energies2 = energies2 + E0


calc3 = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb')
images3, energies3 = calc3.get_neb()
calc0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-initial')
E0 = calc0.potential_energy
energies3 = energies3 + E0

calc4 = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb')
images4, energies4 = calc4.get_neb()
calc0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb-initial')
E0 = calc0.potential_energy
energies4 = energies4 + E0

x = range(len(images1))
xarray = np.linspace(0, len(images1))
f1 = interp1d(x, energies1, kind='cubic', bounds_error=False)
f2 = interp1d(x, energies2, kind='cubic', bounds_error=False)
f3 = interp1d(x, energies3, kind='cubic', bounds_error=False)
f4 = interp1d(x, energies4, kind='cubic', bounds_error=False)


plt.plot(x, energies1, 'bo', label='222')
plt.plot(x, energies2, 'ro', label='223')
plt.plot(x, energies3, 'co', label='233')
plt.plot(x, energies4, 'mo', label='333')


plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.plot(xarray, f3(xarray), 'c-')
plt.plot(xarray, f4(xarray), 'm-')

#plt.annotate('',xy=(1,0.03),xytext=((1,0.1)),arrowprops=dict(arrowstyle="->",connectionstyle="arc3"))
#plt.annotate('',xy=(4,0.67),xytext=((4,0.6)),arrowprops=dict(arrowstyle="->",connectionstyle="arc3"))

plt.xlabel('Images')
plt.ylabel('Reference Potential Energy(eV/atom)')
plt.legend(loc = 'best')
plt.legend()
plt.savefig('./figures/NEB-all-2.png')
#+END_SRC

#+RESULTS:

[[./figures/NEB-all-2.png]]

* DB
** write
#+BEGIN_SRC python
from vasp import Vasp

factor = [0.900, 0.950, 1.000, 1.050]
#factor = [0.900, 0.950, 1.050]
#cells= ['222', '223', '233', '333', '334', '344', '444'] 
cells = ['222']
calcs = []
for cell in cells:

    for x in factor:
    
        #wd = './NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell={0}/factor={1:.3f}'.format(cell,x)
        wd = './NDFT/bulk=fcc/type=vacancy/lattice=cubic/supercell={0}/factor={1:.3f}'.format(cell,x)
        calc = Vasp(wd)

        calc.write_db('./database/db1/data.db', parser='=', overwrite=False, keys={'dbkey':0}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []
for i in range(200):
    wd = './NDFT/bulk=fcc/type=md/order=md0/v_a=0_8/MD={0}'.format(i)

    calc = Vasp(wd)
    calcs += [calc]
    calc.write_db('database/db1/data.db', parser='=', overwrite=False, keys={'dbkey':0}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
import numpy as np

factor = np.append(np.arange(0.85, 1.2, 0.01),
                   np.arange(1.2, 2.125, 0.05))
factor = np.delete(factor, 15)

cells = ['fcc', 'bcc', 'hcp', 'sc', 'diam']
for cell in cells:

    for x in factor:
    
   
        wd = './NDFT/bulk={0}/type=eos/factor={1:.2f}'.format(cell,x)
        calc = Vasp(wd)

        calc.write_db('./database/db1/data.db', parser='=', overwrite=False, keys={'dbkey':0}) 
#+END_SRC

#+RESULTS:
*** MD
*** 0:8
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
from vasp import Vasp
from vasp.vasprc import VASPRC

VASPRC['queue.walltime'] = '24:00:00'

calc1 = Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db0/2-20/-parameters-checkpoint-0.json')
images = Trajectory('./database/db0/MD-0:8.traj', 'r')
E1, E2 = [], []

for atoms in images:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in images:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)
res = E1-E2
res = np.array(res)
x = np.absolute(res)
t = []

for i in range(len(x)):
    if x[i] > 0.002:
        t += [i]


for i in t:        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=0_8/MD={}'.format(i))
    calc.write_db('./database/db1/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

*** 1:7
#+BEGIN_SRC python
from vasp import Vasp

for i in range(51):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_7/MD={}'.format(i))
    calc.write_db('./database/db1/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

*** 1:11
#+BEGIN_SRC python
from vasp import Vasp

for i in range(22):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_11/MD={}'.format(i))
    calc.write_db('./database/db1/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

*** 1:17
#+BEGIN_SRC python
from vasp import Vasp

for i in range(38):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_17/MD={}'.format(i))
    calc.write_db('./database/db1/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

*** 1:26
#+BEGIN_SRC python
from vasp import Vasp

for i in range(16):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_26/MD={}'.format(i))
    calc.write_db('./database/db1/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

*** 1:35
#+BEGIN_SRC python
from vasp import Vasp

for i in range(10):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_35/MD={}'.format(i))
    calc.write_db('./database/db1/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

*** 1:47
#+BEGIN_SRC python
from vasp import Vasp

for i in range(10):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_47/MD={}'.format(i))
    calc.write_db('./database/db1/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

*** 1:63
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db0/MD-1:64.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(0, len(images))]
for i in np.arange(0, len(images)):
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_63/MD={}'.format(i),
                     xc='pbe',
                     kpts=[3, 3, 3],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)

#res = [r for i, r in enumerate(Ne) if i in
#       np.arange(0, len(images), 4) and i != 60]
res = abs(np.array(Ne) - np.array(nrg))

fig, ax = plt.subplots(figsize=(6, 4))
ax.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
ax.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='b', label='DFT prediction')

#ax.set_xlim(min(s), max(s))
ax.set_ylabel('Potential energy (eV)', color='b')
ax.tick_params(axis='y', colors='b')
#ax.set_ylim(-141, -130)
ax.set_xlabel('Time step')
ax.legend(loc=2)

ax1 = ax.twinx()

ax1.scatter(range(len(res)), res, color='r')
ax1.set_ylabel('Absolute residual error (eV)', color='r')
#ax1.set_xlim(min(s), max(s))
ax1.tick_params(axis='y', colors='r')
ax1.set_ylim(0.0, 7.0)

plt.tight_layout()
plt.show()
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md1/v_a=1_63/MD=1 submitted: 1432098.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md1/v_a=1_63/MD=1 Queued: 1432098.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md1/v_a=1_63/MD=3 submitted: 1432099.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md1/v_a=1_63/MD=3 Queued: 1432099.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md1/v_a=1_63/MD=5 submitted: 1432100.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md1/v_a=1_63/MD=5 Queued: 1432100.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md1/v_a=1_63/MD=9 submitted: 1432101.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md1/v_a=1_63/MD=9 Queued: 1432101.gilgamesh.cheme.cmu.edu

** keywords
#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

from ase.db import connect

db = connect('./database/db1/data.db')
data = db.select([])

keys, cnt = {}, 0
for entry in data:
    cnt += 1
    for k, v in entry.key_value_pairs.iteritems():
        
        if k in keys:
            keys[k] += [v]
        else:
            keys[k] = [v]

print ('{0:15s} {1:15s} {2} calculations total'.format('keyword', 'value',cnt))

print('------------------------------------------------------')

for k, v in keys.iteritems():
    vals = list(set(v))
    if len(vals) <= 5:
        val = ", ".join(str(e) for e in vals)
        print('{0:15}: {1}'.format(k, val))

    else:
        val = ", ".join(str(e)[:5] for e in vals[:5])
        print('{0:15s}:{1}, etc...'.format(k, val))
#+END_SRC

#+RESULTS:
#+begin_example
keyword         value           704 calculations total
------------------------------------------------------
MD             :0, 1, 2, 3, 4, etc...
train_set      : False, True
dbkey          : 0, 1
bulk           : sc, hcp, fcc, diam, bcc
lattice        : primitive, cubic
supercell      :233, 333, 334, 344, 444, etc...
v_a            :1_26, 1_47, 1_11, 1_17, 1_7, etc...
factor         :1.25, 1.0, 2.0, 1.45, 0.94, etc...
type           : vacancy, md, eos
order          : md0, md1
#+end_example

* Training
#+BEGIN_SRC python
from ase.db import connect
import os
import random
import numpy as np

db = connect('./database/db1/data.db')

n = db.count()
n_train = int(round(n * 0.9))

n_ids =  np.array(range(n)) + 1

# This will sudo-randomly select 10% of the calculations
# Which is useful for reproducing our results.
random.seed(256)
train_samples = random.sample(n_ids, n_train)
valid_samples = set(n_ids) - set(train_samples)

db.update(list(train_samples), train_set=True)
db.update(list(valid_samples), train_set=False)

with connect('./database/db1/train.db') as db0:
    for d in db.select(['train_set=True']):
        db0.write(d, key_value_pairs=d.key_value_pairs)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *
import os

for n in [18]:
    label = '2-{0}-test'.format(n)
    wd = os.path.join(os.getcwd(), 'database/db1/' + label)

    if not os.path.exists(wd):
        os.makedirs(wd)

    calc = Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json',
               label="./database/db1/{0}/".format(label),
               descriptor=Behler(cutoff=6.0),
               regression=NeuralNetwork(hiddenlayers=(2, '{0}'.format(n))))


    calc.train('./database/db1/data.db', # The training data
               cores=1,
               extend_variables=False) # feature does not work properly and will crash
#+END_SRC

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

# We will try an iteration for n nodes with l hidden layers.
for l in [2]:
    
    #for n in [10, 15, 18, 20, 24, 25, 30]:
    #for n in [15]:
    #for n in [10, 15, 18, 20]:
    for n in [17, 24, 28, 30]:
        label = '{0}-{1}-new'.format(l,n)
        layer=(l,n)
        wd = os.path.join(home, './database/db1/' + label)

        if not os.path.exists(wd):
            os.makedirs(wd)

        os.chdir(wd)

        run_amp = '''#!/usr/bin/env python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

calc = Amp(label="./",
           descriptor=Behler(cutoff=6.0),
           regression=NeuralNetwork(hiddenlayers={0}))

calc.train("~/Research/Bulk/database/db1/train.db", # The training data
           cores=1,
           extend_variables=False) 
'''.format(layer)

        cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=60:00:00
#PBS -l mem=4GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

        with open('submit.py', 'w') as f:
            f.write(run_amp)
        os.chmod('submit.py', 0777)

        with open('submit.sh', 'w') as f:
            f.write(cmd)

        subprocess.call(['qsub', 'submit.sh'])
        time.sleep(5)
        os.unlink('submit.sh')
        os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1432806.gilgamesh.cheme.cmu.edu
: 1432809.gilgamesh.cheme.cmu.edu
: 1432813.gilgamesh.cheme.cmu.edu
: 1432817.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

# We will try an iteration for n nodes with l hidden layers.
for l in [2]:
    
    #for n in [10, 15, 18, 20, 24, 25, 30]:
    #for n in [15]:
    #for n in [10, 15, 18, 20]:
    for n in [18]:
        label = '{0}-{1}-1'.format(l,n)
        layer=(l,n)
        wd = os.path.join(home, './database/db1/' + label)

        if not os.path.exists(wd):
            os.makedirs(wd)

        os.chdir(wd)

        run_amp = '''#!/usr/bin/env python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

calc = Amp(load="../../db0/2-18/",
           label="./",
           descriptor=Behler(cutoff=6.0),
           regression=NeuralNetwork(hiddenlayers={0}))

calc.train("~/Research/Bulk/database/db1/train.db", # The training data
           cores=1,
           extend_variables=False) 

'''.format(layer)

        cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=60:00:00
#PBS -l mem=4GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

        with open('submit.py', 'w') as f:
            f.write(run_amp)
        os.chmod('submit.py', 0777)

        with open('submit.sh', 'w') as f:
            f.write(cmd)

        subprocess.call(['qsub', 'submit.sh'])
        time.sleep(5)
        os.unlink('submit.sh')
        os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1433029.gilgamesh.cheme.cmu.edu
*** 28
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

# We will try an iteration for n nodes with l hidden layers.
for l in [2]:
    
    #for n in [10, 15, 18, 20, 24, 25, 30]:
    #for n in [15]:
    #for n in [10, 15, 18, 20]:
    for n in [24, 28, 30]:
        label = '{0}-{1}-2'.format(l,n)
        layer=(l,n)
        wd = os.path.join(home, './database/db1/' + label)

        if not os.path.exists(wd):
            os.makedirs(wd)

        os.chdir(wd)
        #print os.getcwd()

        run_amp = '''#!/usr/bin/env python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

calc = Amp(load="../2-{0}-new/-parameters-checkpoint-0.json",
           label="./",
           descriptor=Behler(cutoff=6.0),
           regression=NeuralNetwork(hiddenlayers={1}))

calc.train("~/Research/Bulk/database/db1/train.db", # The training data
           cores=1,
           extend_variables=False) 

'''.format(n, layer)

        cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=64:00:00
#PBS -l mem=2GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

        with open('submit.py', 'w') as f:
            f.write(run_amp)
        os.chmod('submit.py', 0777)

        with open('submit.sh', 'w') as f:
            f.write(cmd)

        subprocess.call(['qsub', 'submit.sh'])
        time.sleep(5)
        os.unlink('submit.sh')
        os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1434201.gilgamesh.cheme.cmu.edu
: 1434202.gilgamesh.cheme.cmu.edu
: 1434203.gilgamesh.cheme.cmu.edu
#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *
import os

for n in [28]:
    label = '2-{0}-test'.format(n)
    wd = os.path.join(os.getcwd(), 'database/db1/' + label)

    if not os.path.exists(wd):
        os.makedirs(wd)
    print os.getcwd()

    calc = Amp(load='./database/db1/2-28-new/-parameters-checkpoint-0.json',
               label="./database/db1/{0}/".format(label),
               descriptor=Behler(cutoff=6.0),
               regression=NeuralNetwork(hiddenlayers=(2, '{0}'.format(n))))


    calc.train('./database/db1/data.db', # The training data
               cores=1,
               extend_variables=False) # feature does not work properly and will crash

#+END_SRC

#+RESULTS:

** Update

#+BEGIN_SRC python
from ase.db import connect
from amp import Amp

db = connect('./database/db1/data.db')
calc1 = Amp(load = './database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load = './database/db1/2-30-2/-parameters-checkpoint-0.json')

for d in db.select():
    atoms = db.get_atoms(d.id)
    atoms.set_calculator(calc1)
    nrg1 = atoms.get_potential_energy()

    atoms.set_calculator(calc2)
    nrg2 = atoms.get_potential_energy()
    db.update(d.id, NN24 = nrg1, NN30 = nrg2)
#+END_SRC

#+RESULTS:

** Residual
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from ase.db import connect
from amp import Amp
import os

db = connect('database/db1/data.db')

fig, ax = plt.subplots(1, 2, sharey=True, figsize=(8, 4))

for i, n in enumerate([24, 30]):

    E, nnE, var, ind = [], [], [], []
    for j, d in enumerate(db.select('')):# dbkey=0
	E += [d.energy / d.natoms]
	nnE += [d['NN{}'.format(n)]/ d.natoms]
	var += [j]
	ind += [d.train_set]

    res = np.array(nnE) - np.array(E)
    mask = np.array(ind)
    valid = np.ma.masked_array(res, mask)
    train = np.ma.masked_array(res, ~mask)
    vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
    tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))

    ax[i].text(5, -0.050,
               'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
               color='b', ha='left')
    ax[i].text(5, -0.055,
               'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
               color='r', ha='left')

    ax[i].scatter(var, train, color='b')
    ax[i].scatter(var, valid, color='r')
    ax[i].plot([min(var), max(var)], [0, 0], 'k--')
    ax[i].set_xlim(min(var), max(var))

    ax[i].set_xlabel('Calculation ID')
    ax[i].set_title('8-{0}-{0}-1 framework'.format(n))

ax[0].set_ylim(-0.060, 0.060)
ax[0].set_ylabel('Residual error (eV/atom)')
plt.tight_layout()
plt.savefig('./figures/residual-1.png')
#plt.show()
#+END_SRC

#+RESULTS:

c[[./figures/residual-1.png]]

#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db1/data.db')

S, Qe, Ne = [], [], []

for d in db.select(['type=eos']):
    S += [d.bulk]
    Qe += [d.energy/d.natoms]
    Ne += [d.NN24/d.natoms]
    
S = np.array(S)
Qe = np.array(Qe)
Ne = np.array(Ne)

cmap, hdl = {}, []

#print Ne
for s, c in zip(set(S), ['b', 'r', 'g', 'c', 'm']):
    cmap[s] = c
    hdl +=[mpatches.Patch(color = c, label = s)]

c = []
for s in S:
    c +=[cmap[s]]

RMSE = np.sqrt(sum((Ne-Qe)** 2) / len(Ne - Qe))

(mu, sigma) = norm.fit(Ne- Qe)

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
ax0.plot([min(Qe), 0], [0,0], 'k--', lw =2)
ax0.scatter(Qe, Ne-Qe, marker = 'o', color = c)
ax0.text(min(Qe) + 0.1, 0.14,
         'RMSE: {0:1.3f}'.format(RMSE),
         fontsize = 12, va = 'top', ha = 'left')
ax0.set_xlim(min(Qe), 0)
ax0.set_ylim(-0.02, 0.02)
ax0.set_xlabel('DFT potential energy (eV/atom)')
ax0.set_ylabel('Rsidual error (eV/atom)')
ax0.legend(loc = 'best', handles =hdl, fontsize = 8, frameon = False)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(Ne-Qe, 50,
                            range = (-0.01, 0.01),
                            weights = np.ones_like(Ne-Qe)/ len(Ne),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.05, 0.142, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.05, 0.122, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.01, 0.01)
ax1.set_xlim(0, 0.3)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
plt.tight_layout(w_pad = -0.5)
#plt.savefig('./images/fig-neural-train.png')
plt.show()
#+END_SRC

#+RESULTS:

* Application
** Vacancy formation
*** 222
     
#+BEGIN_SRC python
from jasp import *
with jasp('./DFT/relaxed=True/bulk=fcc/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    E0 = E0 * 8

with jasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=222/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E1 = atoms.get_potential_energy()
    
print E1 - E0*7/8.0
print E0
print E1
#+END_SRC

#+RESULTS:
: 1.06876678
: -41.71703416
: -35.43363811


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 2, 2)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (7/8.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  16:13:13      -35.328610       0.0000
: Vacancy formation energy with NN is: 1.181 eV
: -41.724773802
: -35.3286100665

*** 223
     
#+BEGIN_SRC python
from jasp import *
with jasp('./DFT/relaxed=True/bulk=fcc/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    E0 = E0 * 12

with jasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=223/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E1 = atoms.get_potential_energy()
    
print E1 - E0*11/12.0
print E0
print E1
#+END_SRC

#+RESULTS:
: 1.13686192
: -62.57555124
: -56.22406005


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 2, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (11/12.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  16:14:32      -56.072172       0.5309
BFGS:   1  16:14:36      -56.091612       0.4435
BFGS:   2  16:14:39      -56.145801       0.0936
BFGS:   3  16:14:43      -56.147244       0.0692
BFGS:   4  16:14:47      -56.147925       0.0645
BFGS:   5  16:14:50      -56.148946       0.0661
BFGS:   6  16:14:53      -56.149129       0.0671
BFGS:   7  16:14:56      -56.148790       0.0606
BFGS:   8  16:15:01      -56.148096       0.0570
BFGS:   9  16:15:04      -56.146863       0.0510
BFGS:  10  16:15:08      -56.145654       0.0501
BFGS:  11  16:15:11      -56.145074       0.0409
Vacancy formation energy with NN is: 1.226 eV
-62.587160703
-56.1450743192
#+end_example

*** 233
     
#+BEGIN_SRC python
from jasp import *
with jasp('./DFT/relaxed=True/bulk=fcc/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    E0 = E0 * 18

with jasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=233/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E1 = atoms.get_potential_energy()
    
print E1 - E0*17/18.0
print E0
print E1
#+END_SRC

#+RESULTS:
: 1.15787387
: -93.86332686
: -87.49082372


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 3, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (17/18.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  16:18:08      -87.329792       0.5731
BFGS:   1  16:18:15      -87.362468       0.4904
BFGS:   2  16:18:22      -87.442982       0.1443
BFGS:   3  16:18:29      -87.444341       0.1215
BFGS:   4  16:18:36      -87.444076       0.1065
BFGS:   5  16:18:43      -87.441991       0.0644
BFGS:   6  16:18:50      -87.440384       0.0644
BFGS:   7  16:18:57      -87.438787       0.0587
BFGS:   8  16:19:04      -87.436955       0.0554
BFGS:   9  16:19:11      -87.434154       0.0499
Vacancy formation energy with NN is: 1.231 eV
-93.8807410545
-87.4341539619
#+end_example

*** 333
     
#+BEGIN_SRC python
from jasp import *
with jasp('./DFT/relaxed=True/bulk=fcc/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    E0 = E0 * 27

with jasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=333/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E1 = atoms.get_potential_energy()
    
print E1 - E0*26/27.0
print E0
print E1
#+END_SRC

#+RESULTS:
: 1.10490713
: -140.79499029
: -134.47545389


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (3, 3, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (26/27.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  16:33:47     -134.239261       0.5460
: BFGS:   1  16:34:02     -134.280402       0.4683
: BFGS:   2  16:34:18     -134.379524       0.0728
: BFGS:   3  16:34:37     -134.379948       0.0593
: BFGS:   4  16:34:53     -134.380447       0.0588
: BFGS:   5  16:35:11     -134.382432       0.0477
: Vacancy formation energy with NN is: 1.223 eV
: -140.821111582
: -134.382431999

*** 444
     
#+BEGIN_SRC python
from jasp import *
with jasp('./DFT/relaxed=True/bulk=fcc/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    E0 = E0 * 64

with jasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=444/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E1 = atoms.get_potential_energy()
    
print E1 - E0*63/64.0
print E0
print E1
#+END_SRC

#+RESULTS:
: 0.97281115
: -333.73627328
: -327.54883286


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (4, 4, 4)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (63/64.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  16:16:34     -327.252829       0.2666
: BFGS:   1  16:17:23     -327.264397       0.2274
: BFGS:   2  16:18:20     -327.257182       0.0925
: BFGS:   3  16:19:17     -327.262939       0.0809
: BFGS:   4  16:20:16     -327.300969       0.0292
: Vacancy formation energy with NN is: 1.282 eV
: -333.798190416
: -327.300969026

*** Dilute limitation
#+BEGIN_SRC python
from jasp import *
with jasp('./DFT/relaxed=True/bulk=fcc/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    E0 = E0 * 64

with jasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=444/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E1 = atoms.get_potential_energy()
    
print E1 - E0*63/64.0
#+END_SRC

#+RESULTS:
: 0.97281115

#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
import matplotlib.pyplot as plt
Ev = []
con = []

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=444/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev += [E1 - E0*63]
con +=[1.0/63]

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=344/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev += [E1 - E0*47]
con +=[1.0/47]

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=334/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev += [E1 - E0*35]
con +=[1.0/35]

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=333/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev += [E1 - E0*26]
con +=[1.0/26]

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=233/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev += [E1 - E0*17]
con +=[1.0/17]

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=223/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev += [E1 - E0*11]
con +=[1.0/11]

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=222/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev += [E1 - E0*7]
con +=[1.0/7]

'''
calc = Vasp('./NDFT/bulk=fcc/type=vacancy/lattice=cubic/supercell=222/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev += [E1 - E0*31]
con +=[1.0/31]
'''

print Ev
print con
plt.plot(con, Ev, 'o')
plt.xlabel('Vacancy Concentration')
plt.ylabel('Vacacny formation energy/eV')
plt.savefig('./figures/vac-dil.png')
#+END_SRC

#+RESULTS:
: [0.962775879999981, 1.0137826999999788, 1.0703328399999918, 1.1007655899999804, 1.1551659400000034, 1.1351097299999964, 1.0676517500000031]
: [0.015873015873015872, 0.02127659574468085, 0.02857142857142857, 0.038461538461538464, 0.058823529411764705, 0.09090909090909091, 0.14285714285714285]

[[./figures/vac-dil.png]]
**** 222
#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 2, 2)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (7/8.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print 1.0/7
print ve
#+END_SRC

#+RESULTS:
: BFGS:   0  10:50:20      -35.328610       0.0000
: Vacancy formation energy with NN is: 1.181 eV
: 0.142857142857
: 1.18056701029

**** 223
#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 2, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (11/12.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print 1.0/11
print ve
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  10:50:59      -56.072172       0.5309
BFGS:   1  10:51:02      -56.091612       0.4435
BFGS:   2  10:51:06      -56.145801       0.0936
BFGS:   3  10:51:10      -56.147244       0.0692
BFGS:   4  10:51:13      -56.147925       0.0645
BFGS:   5  10:51:16      -56.148946       0.0661
BFGS:   6  10:51:19      -56.149129       0.0671
BFGS:   7  10:51:23      -56.148790       0.0606
BFGS:   8  10:51:27      -56.148096       0.0570
BFGS:   9  10:51:30      -56.146863       0.0510
BFGS:  10  10:51:34      -56.145654       0.0501
BFGS:  11  10:51:38      -56.145074       0.0409
Vacancy formation energy with NN is: 1.226 eV
0.0909090909091
1.22648965859
#+end_example

**** 233
#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 3, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (17/18.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print 1.0/7
print ve
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  10:53:19      -87.329792       0.5731
BFGS:   1  10:53:26      -87.362468       0.4904
BFGS:   2  10:53:33      -87.442982       0.1443
BFGS:   3  10:53:40      -87.444341       0.1215
BFGS:   4  10:53:47      -87.444076       0.1065
BFGS:   5  10:53:54      -87.441991       0.0644
BFGS:   6  10:54:01      -87.440384       0.0644
BFGS:   7  10:54:08      -87.438787       0.0587
BFGS:   8  10:54:15      -87.436955       0.0554
BFGS:   9  10:54:21      -87.434154       0.0499
Vacancy formation energy with NN is: 1.231 eV
0.142857142857
1.23099036736
#+end_example

** MD
*** Bulk
**** 8000
#+BEGIN_SRC python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

# Set up a crystal
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 2, 2))

# Describe the interatomic interactions with the Effective Medium Theory
atoms.set_calculator(Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json'))
# We want to run MD with constant energy using the Langevin algorithm
# with a time step of 5 fs, the temperature T and the friction
# coefficient to 0.02 atomic units.
dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):  # store a reference to atoms in the definition.
    """Function to print the potential, kinetic and total energy."""
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=20)

# We also want to save the positions of all atoms after every time step.
traj = Trajectory('./database/db1/MD0-8-0.traj', 'w', atoms)
dyn.attach(traj.write, interval=20)

# Now run the dynamics
dyn.run(8000)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db1')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 2, 2))

atoms.set_calculator(Amp(load="./2-24-2/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=20)

traj = Trajectory("./MD0-8.traj", "w", atoms)
dyn.attach(traj.write, interval=20)

dyn.run(8000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('0-8')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1439388.gilgamesh.cheme.cmu.edu


#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
import jbtools.gilgamesh as jb

Ne = []
for i, atoms in enumerate(Trajectory('./database/db0/MD.traj', 'r')):

    Ne += [atoms.get_potential_energy()]

plt.plot(range(len(Ne)), Ne, 'bo')
#plt.savefig('./images/MD-NN.png')
plt.show()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db1/MD0-8-0.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
#plt.show()
plt.xlabel('MD Step')
plt.ylabel('Energy eV')
plt.legend()
plt.savefig('./figures/MD0-8-2.png')

#+END_SRC

#+RESULTS:

[[./figures/MD0-8-2.png]]
**** 4000
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db0')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 2, 2))

atoms.set_calculator(Amp(load="./2-18/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=20)

traj = Trajectory("./MD-0:8.traj", "w", atoms)
dyn.attach(traj.write, interval=20)

dyn.run(4000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=8GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('0:8')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1429517.gilgamesh.cheme.cmu.edu
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db0/2-20/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db0/MD-0:8.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
#plt.show()
plt.xlabel('MD Step')
plt.ylabel('Energy eV')
plt.legend()
plt.savefig('./figures/0:8-md1.png')
#plt.show()

#+END_SRC

#+RESULTS:

[[./figures/0:8-md1.png]]

*** Vacancy
**** 1:7
#+BEGIN_SRC python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

# Set up a crystal
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 2, 2))

del atoms[0]
# Describe the interatomic interactions with the Effective Medium Theory
atoms.set_calculator(Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json'))
# We want to run MD with constant energy using the Langevin algorithm
# with a time step of 5 fs, the temperature T and the friction
# coefficient to 0.02 atomic units.
dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):  # store a reference to atoms in the definition.
    """Function to print the potential, kinetic and total energy."""
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

# We also want to save the positions of all atoms after every time step.
traj = Trajectory('./database/db1/MD1-8-0.traj', 'w', atoms)
dyn.attach(traj.write, interval=10)

# Now run the dynamics
dyn.run(2000)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db1/MD1-7-0.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/MD1-7-2.png')
#+END_SRC

#+RESULTS:

[[./figures/MD1-7-2.png]]

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db1')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 2, 2))

del atoms[0]

atoms.set_calculator(Amp(load="./2-24-2/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD1-7.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('1:7')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1439389.gilgamesh.cheme.cmu.edu


The energy of MD=60 is too high to calculate.

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db0/MD-1:8.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(0, 50)]

calcs = [Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_7/MD={}'.format(i),
            xc='pbe',
            kpts=[9]*3,
            encut=350,
            nsw=0,
            atoms=images[i]) for i in range(50)]

[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)

#res = [r for i, r in enumerate(Ne) if i in
#       np.arange(0, len(images), 4) and i != 60]
res = abs(np.array(Ne) - np.array(nrg))

fig, ax = plt.subplots(figsize=(6, 4))
ax.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
ax.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='b', label='DFT prediction')

#ax.set_xlim(min(s), max(s))
ax.set_ylabel('Potential energy (eV)', color='b')
ax.tick_params(axis='y', colors='b')
#ax.set_ylim(-141, -130)
ax.set_xlabel('Time step')
ax.legend(loc=2)

ax1 = ax.twinx()

ax1.scatter(range(len(res)), res, color='r')
ax1.set_ylabel('Absolute residual error (eV)', color='r')
#ax1.set_xlim(min(s), max(s))
ax1.tick_params(axis='y', colors='r')
ax1.set_ylim(0.0, 7.0)

plt.tight_layout()
plt.show()
#+END_SRC

#+RESULTS:

**** 1:11
#+BEGIN_SRC python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

# Set up a crystal
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 2, 3))

del atoms[0]
# Describe the interatomic interactions with the Effective Medium Theory
atoms.set_calculator(Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json'))
# We want to run MD with constant energy using the Langevin algorithm
# with a time step of 5 fs, the temperature T and the friction
# coefficient to 0.02 atomic units.
dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):  # store a reference to atoms in the definition.
    """Function to print the potential, kinetic and total energy."""
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

# We also want to save the positions of all atoms after every time step.
traj = Trajectory('./database/db1/MD1-11-0.traj', 'w', atoms)
dyn.attach(traj.write, interval=10)

# Now run the dynamics
dyn.run(2000)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db1')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 2, 3))

del atoms[0]

atoms.set_calculator(Amp(load="./2-24-2/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD1-11.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('1-11')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1439390.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db1/MD1-11-0.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/MD1-11-2.png')
#+END_SRC

#+RESULTS:

[[./figures/MD1-11-2.png]]

**** 1:17
#+BEGIN_SRC python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

# Set up a crystal
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 3, 3))

del atoms[0]
# Describe the interatomic interactions with the Effective Medium Theory
atoms.set_calculator(Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json'))
# We want to run MD with constant energy using the Langevin algorithm
# with a time step of 5 fs, the temperature T and the friction
# coefficient to 0.02 atomic units.
dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):  # store a reference to atoms in the definition.
    """Function to print the potential, kinetic and total energy."""
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

# We also want to save the positions of all atoms after every time step.
traj = Trajectory('./database/db1/MD1-17-0.traj', 'w', atoms)
dyn.attach(traj.write, interval=10)

# Now run the dynamics
dyn.run(2000)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db1')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 3, 3))

del atoms[0]

atoms.set_calculator(Amp(load="./2-24-2/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD1-17.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(1000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('1-17')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC
#+RESULTS:
: 1439391.gilgamesh.cheme.cmu.edu
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db1/MD1-17-0.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/MD1-17-2.png')
#+END_SRC

#+RESULTS:

[[./figures/MD1-17-2.png]]
**** 1:26
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db1')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(3, 3, 3))

del atoms[0]

atoms.set_calculator(Amp(load="./2-24-2/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD1-26.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('1-26')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1442443.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db1/MD1-26.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)
res = E1-E2
res = np.array(res)
x = np.absolute(res)

t = []

for i in range(len(x)):
    if x[i] > 0.002:
        t += [i]

print t
plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,50])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/MD1-26-2.png')
#+END_SRC

#+RESULTS:
: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 198, 199]

[[./figures/MD1-26-2.png]]
**** 1:35
#+BEGIN_SRC python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

# Set up a crystal
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(3, 3, 4))

del atoms[0]
# Describe the interatomic interactions with the Effective Medium Theory
atoms.set_calculator(Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json'))
# We want to run MD with constant energy using the Langevin algorithm
# with a time step of 5 fs, the temperature T and the friction
# coefficient to 0.02 atomic units.
dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):  # store a reference to atoms in the definition.
    """Function to print the potential, kinetic and total energy."""
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

# We also want to save the positions of all atoms after every time step.
traj = Trajectory('./database/db1/MD1-35-0.traj', 'w', atoms)
dyn.attach(traj.write, interval=10)

# Now run the dynamics
dyn.run(1000)
#+END_SRC

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db1')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(3, 3, 4))

del atoms[0]

atoms.set_calculator(Amp(load="./2-24-2/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD1-35-1.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(1000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('1-35')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1442929.gilgamesh.cheme.cmu.edu
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db1')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(3, 3, 4))

del atoms[0]

atoms.set_calculator(Amp(load="./2-24-2/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD1-35-0.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(1000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('1-35-0')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1443163.gilgamesh.cheme.cmu.edu

**** 1:47
#+BEGIN_SRC python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

# Set up a crystal
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(3, 4, 4))

del atoms[0]
# Describe the interatomic interactions with the Effective Medium Theory
atoms.set_calculator(Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json'))
# We want to run MD with constant energy using the Langevin algorithm
# with a time step of 5 fs, the temperature T and the friction
# coefficient to 0.02 atomic units.
dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):  # store a reference to atoms in the definition.
    """Function to print the potential, kinetic and total energy."""
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

# We also want to save the positions of all atoms after every time step.
traj = Trajectory('./database/db1/MD1-47-0.traj', 'w', atoms)
dyn.attach(traj.write, interval=10)

# Now run the dynamics
dyn.run(1000)
#+END_SRC

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db1')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(3, 4, 4))

del atoms[0]

atoms.set_calculator(Amp(load="./2-24-2/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD1-47-1.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(1000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('1-47')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1442936.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db1/MD1-47.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,100])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/MD1-47-2.png')
#+END_SRC

#+RESULTS:

[[./figures/MD1-47-2.png]]
**** 1:63
#+BEGIN_SRC python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

# Set up a crystal
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(4, 4, 4))

del atoms[0]
# Describe the interatomic interactions with the Effective Medium Theory
atoms.set_calculator(Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json'))
# We want to run MD with constant energy using the Langevin algorithm
# with a time step of 5 fs, the temperature T and the friction
# coefficient to 0.02 atomic units.
dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):  # store a reference to atoms in the definition.
    """Function to print the potential, kinetic and total energy."""
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

# We also want to save the positions of all atoms after every time step.
traj = Trajectory('./database/db1/MD1-63-0.traj', 'w', atoms)
dyn.attach(traj.write, interval=10)

# Now run the dynamics
dyn.run(500)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db1')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(4, 4, 4))

del atoms[0]

atoms.set_calculator(Amp(load="./2-24-2/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD1-63-1.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(500)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('1-63')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1440295.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db1/MD1-63-1.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)
res = E1-E2
res = np.array(res)
x = np.absolute(res)
print x
t = []

for i in range(len(x)):
    if x[i] > 0.002:
        t += [i]

print t
plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,50])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/MD1-63-2.png')
#+END_SRC

#+RESULTS:
: [ 0.     0.     0.     0.     0.001  0.001  0.001  0.002  0.001  0.     0.
:   0.     0.001  0.001  0.001  0.001  0.     0.001  0.002  0.003  0.002  0.
:   0.     0.001  0.002  0.003  0.002  0.     0.001  0.003  0.003  0.002
:   0.001  0.001  0.002  0.003  0.002  0.001  0.001  0.002  0.003  0.002
:   0.002  0.002  0.002  0.002  0.003  0.002  0.002  0.002]
: [19, 25, 29, 30, 31, 35, 36, 39, 40, 41, 46, 48]

[[./figures/MD1-63-2.png]]
** EOS
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState
from ase.db import connect
from amp import Amp
from ase.visualize import view
import os
import json
import time
from ase.units import kJ

db = connect('./database/db1/data.db')

f, ax = plt.subplots(1, 5, figsize = (12, 5))
tag = ['FCC', 'BCC', 'HCP', 'SC', 'Diamond']

for i, key in enumerate(['fcc', 'bcc', 'hcp', 'sc', 'diam']):

    V, Qe, Re, Ne = [], [], [], []

    for d in db.select(['bulk={0}'.format(key), 'type=eos']):
        V += [d.volume / d.natoms]
        Qe += [d.energy / d.natoms]
        Ne += [d.NN24 / d.natoms]

    srt = [j[0] for j in sorted(enumerate(V), key = lambda x:x[1])]
    V = np.array(V)[srt]
    Qe = np.array(Qe)[srt]
    Ne = np.array(Ne)[srt]

    ax[i].plot(V, Qe, 'k-', lw=2, label = 'DFT')
    ax[i].plot(V, Ne, 'r--', lw=2, label = 'Neural')

    if i >0:
        ax[i].set_yticklabels([])

    ax[i].set_ylim(-6 , 0)
    ax[i].set_xlim(0, 150)
    ax[i].set_xticks([0, 40, 80, 120])
    ax[i].set_title('{0}'.format(tag[i]))

ax[0].set_ylabel('Potantial energy (eV/atom)')
ax[2].set_xlabel('Volume ($\AA$/atom)')
ax[4].legend(loc = 'best', fontsize = 12)
plt.tight_layout(w_pad=-1.3)
plt.savefig('./figures/eos-NN.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/eos-NN.png]]

#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt


E1, E2 = [], []

factor = np.linspace(0.85, 2.5, 1000)
for x in factor :

    atoms = FaceCenteredCubic('Pd',
                              directions=[[0, 1, 1],
                                          [1, 0, 1],
                                          [1, 1, 0]],
                              latticeconstant=3.933)
    
    delta = np.array([[x, 0., 0.],
                      [0., x, 0.],
                      [0., 0., x]])
    atoms.set_cell(np.dot(atoms.get_cell(), delta),
                   scale_atoms=True)
    calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
    calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
    
    atoms.set_calculator(calc1)
    E1 += [atoms.get_potential_energy()]

    atoms.set_calculator(calc2)
    E2 += [atoms.get_potential_energy()]

E1 = np.array(E1)
E2 = np.array(E2)
res = abs(E1 - E2)
#print E1


f, ax = plt.subplots(2, 1, sharex=True)
ax[0].plot(factor, E1, 'b', lw=2, label='2-24')
ax[0].plot(factor, E2, 'r', lw=2, label='2-30')
ax[0].plot([0.85, 0.85], [2, -6], 'k--')
ax[0].plot([2.1, 2.1], [2, -6], 'k--')
ax[0].set_ylabel('Potential energy (eV)')
ax[0].set_xlim(0.6, 2.5)
ax[0].set_ylim(-6, 2)
ax[0].legend(loc='best')
ax[1].plot(factor, res)
ax[1].plot([0.85, 0.85], [0, 0.5], 'k--')
ax[1].plot([2.07, 2.1], [0, 0.5], 'k--')
ax[1].set_ylabel('NN energy difference (eV)')
ax[1].set_ylim(0, 0.5)
ax[1].set_xlabel('Strain/stretch factor (%)')
plt.tight_layout(w_pad=0.0)
plt.savefig('./figures/app-eos.png')
#+END_SRC

#+RESULTS:

[[./figures/app-eos.png]]

** Bulk Properties
*** Cohesive energy
Atomic energy
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase import Atoms, Atom
from ase.visualize import view
VASPRC['queue.walltime'] = '24:00:00'

atoms = Atoms([Atom('Pd', [5, 5, 5])],
              cell = (7, 8, 9))

calc = Vasp('NDFT/atomic-Pd',
          xc = 'pbe',
          encut = 350,
          kpts = [1]*3,
          atoms = atoms) 

calc.calculate()

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/atomic-Pd submitted: 1442984.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
from vasp import Vasp
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')

calc = Vasp ('./NDFT/atomic-Pd') 
Eatom = calc.potential_energy
 
calc = Vasp ('./NDFT/bulk=fcc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEfcc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEfcc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=bcc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEbcc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEbcc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=hcp/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEhcp = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEhcp = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=sc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEsc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEsc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=diam/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEdiam = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEdiam = atoms.get_potential_energy()/len(atoms)
print DEfcc-Eatom, NEfcc-Eatom
print DEbcc-Eatom, NEbcc-Eatom
print DEhcp-Eatom, NEhcp-Eatom
print DEsc-Eatom, NEsc-Eatom
print DEdiam-Eatom, NEdiam-Eatom
#+END_SRC

#+RESULTS:
: -3.75476834 -3.75589508423
: -3.71312559 -3.73790838482
: -3.72459561 -3.76095602827
: -3.2532599 -3.26704062214
: -2.6162620675 -2.61824650251

*** Bulk Modulus
#+BEGIN_SRC python
from ase.db import connect
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState
from ase.units import kJ
import numpy as np
from vasp import Vasp
from amp import Amp

factor = np.arange(0.85, 1.2, 0.01)
calc2 = Amp(load = './database/db1/2-24-2/-parameters-checkpoint-0.json')
             #      np.arange(1.2, 2.125, 0.05))
configs = ['fcc', 'bcc', 'hcp', 'sc', 'diam']

for config in configs:
    nrg, vol = [], []
    nn = []
    for f in factor:
        calc = Vasp('./NDFT/bulk={0}/type=eos/factor={1:.2f}'.format(config,f))
        atoms = calc.get_atoms()
        nrg += [atoms.get_potential_energy()/len(atoms)]
        vol += [atoms.get_volume()/len(atoms)]
        atoms.set_calculator(calc2)
        nn +=[atoms.get_potential_energy()/len(atoms)]
        

    vol = np.array(vol)
    nrg = np.array(nrg)
    nn = np.array(nn)
# Fit the data to SJEOS
    eos = EquationOfState(vol, nrg)
    v0, e0, B0 = eos.fit()
    eos = EquationOfState(vol, nn)
    v1, e1, B1 = eos.fit()
    print '{0}'.format(config)
    print v0, e0, B0
    print v1, e1, B1
#+END_SRC

#+RESULTS:
#+begin_example
fcc
15.2979724806 -5.22438476072 1.09507457295
15.3564270183 -5.21520156705 1.07945263208
bcc
15.4257962561 -5.18249419589 1.06469804063
15.3991596967 -5.19211684448 1.08071951009
hcp
15.3645769219 -5.19379582623 1.08254355793
15.3341063992 -5.21621811798 1.09987534388
sc
17.8024966568 -4.72110919112 0.782438954048
17.8334288446 -4.71777979115 0.775358668286
diam
24.3558101786 -4.08130798908 0.428150007251
24.346708419 -4.08117208591 0.428715107213
#+end_example

*** Elastic Constant
**** 11, 12
#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.04, 41)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=11/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
    #calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
#+END_SRC

#+RESULTS:
: [ 2.21553499 -0.34127471]
: [ 2.91735716 -0.34129709]

**** 44
#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.04, 41)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=44/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
    #calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
#+END_SRC

#+RESULTS:
: [ 0.66616554 -0.34127543]
: [ 0.89696565 -0.34135456]

**** calculation
#+BEGIN_SRC python
B = 1.09507457295
a = 2.21553499/6
b = 0.66616554

C4 = b/2
C2 = (3*B - 2*a)/3
C1 = 2*a + C2

print C1, C2, C4
print C1 * 160.2177
print C2 * 160.2177
print C4 * 160.2177
#+END_SRC

#+RESULTS:
: 1.58741568184 0.848904018506 0.33308277
: 254.332089488
: 136.009449366
: 53.365755319

**** reference 
#+BEGIN_SRC python
from vasp import Vasp
calc = Vasp('~/Research/Bulk/DFT/bulk=fcc/type=elastic/elastic')

EM = calc.get_elastic_moduli()

print EM
#+END_SRC

#+RESULTS:
: [[ 206.71093  155.54113  155.54113    0.         0.         0.     ]
:  [ 155.54113  206.71093  155.54113    0.         0.         0.     ]
:  [ 155.54113  155.54113  206.71093    0.         0.         0.     ]
:  [   0.         0.         0.        59.78395    0.         0.     ]
:  [   0.         0.         0.         0.        59.78395    0.     ]
:  [   0.         0.         0.         0.         0.        59.78395]]

** NEB-MD
*** 222 image1
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db1/MDimage1.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)
res = E1-E2
res = np.array(res)
x = np.absolute(res)
t = []

for i in range(len(x)):
    if x[i] > 0.002:
        t += [i]
print t
plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/222-MD1.png')
#+END_SRC

#+RESULTS:
: [20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 86, 87, 88, 89, 90, 91, 92, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199]

[[./figures/222-MD1.png]]

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db1/MDimage1.traj', 'r')
#Ne = [images[i].get_potential_energy() for i in range(0, 100)]
Ne = [images[i].get_potential_energy() for i in range(0, 200)]
#for i in np.arange(0, 100, 4):
for i in range(200):        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=1/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9]*3,
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
#+END_SRC

*** 222 image2
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db1/MDimage2.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)
res = E1-E2
res = np.array(res)
x = np.absolute(res)
t = []

for i in range(len(x)):
    if x[i] > 0.002:
        t += [i]
print t
plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/222-MD2.png')
#+END_SRC

#+RESULTS:
: [0, 1, 5, 6, 7, 8, 12, 13, 14, 15, 16, 17, 20, 21, 22, 23, 24, 25, 26, 28, 29, 30, 31, 32, 33, 34, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 108, 109, 110, 111, 112, 113, 114, 116, 117, 118, 119, 120, 121, 126, 127, 128, 129, 132, 134, 135, 136, 138, 144, 145, 149, 159, 160, 161, 164, 167, 172, 174, 175, 177, 178, 179, 180, 183, 184, 185, 186, 187, 188, 189, 190, 192, 193, 195, 196, 197, 198, 199]

[[./figures/222-MD2.png]]

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db1/MDimage2.traj', 'r')


for i in range(50):        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=2/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9]*3,
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
#+END_SRC

*** 222 image3
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db1/MDimage3.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)
res = E1-E2
res = np.array(res)
x = np.absolute(res)
t = []

for i in range(len(x)):
    if x[i] > 0.002:
        t += [i]
print t
plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/222-MD3.png')
#+END_SRC

#+RESULTS:
: [0, 1, 2, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199]

[[./figures/222-MD3.png]]

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db1/MDimage3.traj', 'r')


for i in range(50):        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=3/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9]*3,
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
#+END_SRC

*** 222 image4
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db1/MDimage4.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)
res = E1-E2
res = np.array(res)
x = np.absolute(res)
t = []

for i in range(len(x)):
    if x[i] > 0.002:
        t += [i]
print t
plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/222-MD4.png')
#+END_SRC

#+RESULTS:
: [0, 1, 2, 3, 4, 5, 6, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199]

[[./figures/222-MD4.png]]

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db1/MDimage4.traj', 'r')

for i in range(50):        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=4/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9]*3,
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
#+END_SRC


* 3rd DFT
** MD
*** 1:7
#+BEGIN_SRC python
a = range(200)
print a
del a[168]
del a[190]
print a

[168, 190]
#+END_SRC

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db1/MD1-7-0.traj')
E1, E2 = [], []
ind = []
for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)

E = abs(E1-E2)
for i, e in enumerate(E):
    if e > 0.02:
        ind += [i]

print ind
print len(ind)
#+END_SRC

#+RESULTS:
: [86, 87, 88, 90, 91, 92, 97, 98, 99, 100, 101, 106, 107, 108, 109, 111, 112, 116, 117, 118, 120, 121, 122, 123, 129, 130, 131, 132, 133, 134, 141, 142, 143, 144, 145, 150, 151, 152, 153, 176, 177, 178, 179, 180, 181, 182, 183, 184, 188, 189, 190, 191, 196, 197, 198, 199]
: 56

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db1/MD1-7-0.traj', 'r')
#Ne = [images[i].get_potential_energy() for i in range(0, 100)]
Ne = [images[i].get_potential_energy() for i in range(0, 200)]
#for i in np.arange(0, 100, 4):
for i in range(200):        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9]*3,
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)

plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-7md-2.png')
#+END_SRC


#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp

Ne, nrg, res, s = [], [], [], []
calcs = []
a = range(200)
#del a[168]
#del a[189]
images = Trajectory('./database/db1/MD1-7-0.traj', 'r')

calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
#Ne = [images[i].get_potential_energy() for i in range(0, 100)]
E1, E2 = [], []


#for i in np.arange(0, 100, 4):
for i in a:        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/MD={}'.format(i))

        nrg += [calc.potential_energy]
        
        atoms = images[i]

        atoms.set_calculator(calc1)
        E1.append(atoms.get_potential_energy())

        atoms.set_calculator(calc2)
        E2.append(atoms.get_potential_energy())

plt.plot(range(len(E1)), E1, 'b-', label='NN1')
plt.plot(range(len(E2)), E2, 'r--', label='NN2')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT')

plt.xlim((0, len(E1)))
plt.ylabel('Potential energy (eV)')

plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-7md-2.png')
#+END_SRC

#+RESULTS:

[[./figures/1-7md-2.png]]

*** 1:11
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne,Ne0, nrg, res, s = [], [], [], [], []
calcs = []
images = Trajectory('./database/db1/MD1-11-0.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(len(images))]
for i in range(len(images)):

        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_11/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9,9,5],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)

plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-11md-2.png')
#+END_SRC

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp

Ne, nrg, res, s = [], [], [], []
calcs = []
a = range(200)
#del a[168]
#del a[189]
images = Trajectory('./database/db1/MD1-11-0.traj', 'r')

calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
#Ne = [images[i].get_potential_energy() for i in range(0, 100)]
E1, E2 = [], []


#for i in np.arange(0, 100, 4):
for i in a:        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_11/MD={}'.format(i))

        nrg += [calc.potential_energy]
        
        atoms = images[i]

        atoms.set_calculator(calc1)
        E1.append(atoms.get_potential_energy())

        atoms.set_calculator(calc2)
        E2.append(atoms.get_potential_energy())

plt.plot(range(len(E1)), E1, 'b-', label='NN1')
plt.plot(range(len(E2)), E2, 'r--', label='NN2')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT')

plt.xlim((0, len(E1)))
plt.ylabel('Potential energy (eV)')

plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-11md-2.png')
#+END_SRC

#+RESULTS:

[[./figures/1-11md-2.png]]

*** 1:17
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db1/MD1-17-0.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(len(images))]
for i in range(len(images)):
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_17/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9, 5, 5],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_17/MD=151 submitted: 1443166.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_17/MD=151 Queued: 1443166.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_17/MD=174 submitted: 1443167.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_17/MD=174 Queued: 1443167.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp

Ne, nrg, res, s = [], [], [], []
calcs = []
a = range(200)
#del a[168]
#del a[189]
images = Trajectory('./database/db1/MD1-17-0.traj', 'r')

calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
#Ne = [images[i].get_potential_energy() for i in range(0, 100)]
E1, E2 = [], []


#for i in np.arange(0, 100, 4):
for i in a:        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_17/MD={}'.format(i))

        nrg += [calc.potential_energy]
        
        atoms = images[i]

        atoms.set_calculator(calc1)
        E1.append(atoms.get_potential_energy())

        atoms.set_calculator(calc2)
        E2.append(atoms.get_potential_energy())

plt.plot(range(len(E1)), E1, 'b-', label='NN1')
plt.plot(range(len(E2)), E2, 'r--', label='NN2')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT')

plt.xlim((0, len(E1)))
plt.ylabel('Potential energy (eV)')

plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-17md-2.png')
#+END_SRC

#+RESULTS:


[[./figures/1-17md-2.png]]
*** 1:26
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
#VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db1/MD1-26.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(200)]
for i in range(200):
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD={}'.format(i),
                     xc='pbe',
                     kpts=[5, 5, 5],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)


plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-26md-2.png')
#+END_SRC

#+RESULTS:
#+begin_example
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD=70 submitted: 1443232.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD=70 Queued: 1443232.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD=77 submitted: 1443233.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD=77 Queued: 1443233.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD=81 submitted: 1443234.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD=81 Queued: 1443234.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD=88 submitted: 1443235.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD=88 Queued: 1443235.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD=90 submitted: 1443236.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD=90 Queued: 1443236.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD=142 submitted: 1443237.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD=142 Queued: 1443237.gilgamesh.cheme.cmu.edu
#+end_example

[[./figures/1-26md-2.png]]

*** 1:35
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db1/MD1-35-0.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(0, len(images))]
for i in np.arange(0, len(images)):
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD={}'.format(i),
                     xc='pbe',
                     kpts=[5, 5, 3],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)


plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-35md-1.png')
#+END_SRC

#+RESULTS:
#+begin_example
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=0 submitted: 1443256.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=0 Queued: 1443256.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=1 submitted: 1443257.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=1 Queued: 1443257.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=2 submitted: 1443258.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=2 Queued: 1443258.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=3 submitted: 1443259.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=3 Queued: 1443259.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=4 submitted: 1443260.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=4 Queued: 1443260.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=5 submitted: 1443261.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=5 Queued: 1443261.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=6 submitted: 1443262.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=6 Queued: 1443262.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=7 submitted: 1443263.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=7 Queued: 1443263.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=8 submitted: 1443264.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=8 Queued: 1443264.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=9 submitted: 1443265.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=9 Queued: 1443265.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=10 submitted: 1443266.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=10 Queued: 1443266.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=11 submitted: 1443267.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=11 Queued: 1443267.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=12 submitted: 1443268.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=12 Queued: 1443268.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=13 submitted: 1443269.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=13 Queued: 1443269.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=14 submitted: 1443270.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=14 Queued: 1443270.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=15 submitted: 1443271.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=15 Queued: 1443271.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=16 submitted: 1443272.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=16 Queued: 1443272.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=17 submitted: 1443273.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=17 Queued: 1443273.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=18 submitted: 1443274.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=18 Queued: 1443274.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=19 submitted: 1443275.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=19 Queued: 1443275.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=20 submitted: 1443276.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=20 Queued: 1443276.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=21 submitted: 1443277.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=21 Queued: 1443277.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=22 submitted: 1443278.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=22 Queued: 1443278.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=23 submitted: 1443279.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=23 Queued: 1443279.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=24 submitted: 1443280.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=24 Queued: 1443280.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=25 submitted: 1443281.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=25 Queued: 1443281.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=26 submitted: 1443282.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=26 Queued: 1443282.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=27 submitted: 1443283.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=27 Queued: 1443283.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=28 submitted: 1443284.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=28 Queued: 1443284.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=29 submitted: 1443285.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=29 Queued: 1443285.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=30 submitted: 1443286.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=30 Queued: 1443286.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=31 submitted: 1443287.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=31 Queued: 1443287.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=32 submitted: 1443288.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=32 Queued: 1443288.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=33 submitted: 1443289.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=33 Queued: 1443289.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=34 submitted: 1443290.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=34 Queued: 1443290.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=35 submitted: 1443291.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=35 Queued: 1443291.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=36 submitted: 1443292.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=36 Queued: 1443292.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=37 submitted: 1443293.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=37 Queued: 1443293.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=38 submitted: 1443294.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=38 Queued: 1443294.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=39 submitted: 1443295.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=39 Queued: 1443295.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=40 submitted: 1443296.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=40 Queued: 1443296.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=41 submitted: 1443297.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=41 Queued: 1443297.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=42 submitted: 1443298.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=42 Queued: 1443298.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=43 submitted: 1443299.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=43 Queued: 1443299.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=44 submitted: 1443300.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=44 Queued: 1443300.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=45 submitted: 1443301.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=45 Queued: 1443301.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=46 submitted: 1443302.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=46 Queued: 1443302.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=47 submitted: 1443303.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=47 Queued: 1443303.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=48 submitted: 1443304.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=48 Queued: 1443304.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=49 submitted: 1443305.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=49 Queued: 1443305.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=50 submitted: 1443306.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=50 Queued: 1443306.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=51 submitted: 1443307.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=51 Queued: 1443307.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=52 submitted: 1443308.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=52 Queued: 1443308.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=53 submitted: 1443309.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=53 Queued: 1443309.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=54 submitted: 1443310.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=54 Queued: 1443310.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=55 submitted: 1443311.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=55 Queued: 1443311.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=56 submitted: 1443312.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=56 Queued: 1443312.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=57 submitted: 1443313.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=57 Queued: 1443313.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=58 submitted: 1443314.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=58 Queued: 1443314.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=59 submitted: 1443315.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=59 Queued: 1443315.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=60 submitted: 1443316.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=60 Queued: 1443316.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=61 submitted: 1443317.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=61 Queued: 1443317.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=62 submitted: 1443318.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=62 Queued: 1443318.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=63 submitted: 1443319.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=63 Queued: 1443319.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=64 submitted: 1443320.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=64 Queued: 1443320.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=65 submitted: 1443321.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=65 Queued: 1443321.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=66 submitted: 1443322.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=66 Queued: 1443322.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=67 submitted: 1443323.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=67 Queued: 1443323.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=68 submitted: 1443324.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=68 Queued: 1443324.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=69 submitted: 1443325.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=69 Queued: 1443325.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=70 submitted: 1443326.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=70 Queued: 1443326.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=71 submitted: 1443327.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=71 Queued: 1443327.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=72 submitted: 1443328.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=72 Queued: 1443328.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=73 submitted: 1443329.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=73 Queued: 1443329.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=74 submitted: 1443330.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=74 Queued: 1443330.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=75 submitted: 1443331.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=75 Queued: 1443331.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=76 submitted: 1443332.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=76 Queued: 1443332.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=77 submitted: 1443333.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=77 Queued: 1443333.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=78 submitted: 1443334.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=78 Queued: 1443334.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=79 submitted: 1443335.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=79 Queued: 1443335.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=80 submitted: 1443336.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=80 Queued: 1443336.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=81 submitted: 1443337.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=81 Queued: 1443337.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=82 submitted: 1443338.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=82 Queued: 1443338.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=83 submitted: 1443339.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=83 Queued: 1443339.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=84 submitted: 1443340.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=84 Queued: 1443340.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=85 submitted: 1443341.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=85 Queued: 1443341.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=86 submitted: 1443342.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=86 Queued: 1443342.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=87 submitted: 1443343.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=87 Queued: 1443343.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=88 submitted: 1443344.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=88 Queued: 1443344.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=89 submitted: 1443345.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=89 Queued: 1443345.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=90 submitted: 1443346.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=90 Queued: 1443346.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=91 submitted: 1443347.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=91 Queued: 1443347.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=92 submitted: 1443348.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=92 Queued: 1443348.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=93 submitted: 1443349.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=93 Queued: 1443349.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=94 submitted: 1443350.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=94 Queued: 1443350.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=95 submitted: 1443351.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=95 Queued: 1443351.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=96 submitted: 1443352.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=96 Queued: 1443352.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=97 submitted: 1443353.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=97 Queued: 1443353.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=98 submitted: 1443354.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=98 Queued: 1443354.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=99 submitted: 1443355.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=99 Queued: 1443355.gilgamesh.cheme.cmu.edu
#+end_example

[[./figures/1-35md-1.png]]
*** 1:47
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db1/MD1-47-0.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(0, len(images))]
for i in np.arange(0, len(images)):
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_47/MD={}'.format(i),
                     xc='pbe',
                     kpts=[5, 3, 3],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)


plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-47md-1.png')
#+END_SRC

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC


Ne, nrg, res, s = [], [], [], []
calcs = []

a = range(200)

for i in a 
:
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_47/MD={}'.format(i))
  
        nrg += [calc.potential_energy]

#+END_SRC

#+RESULTS:



[[./figures/1-47md-1.png]]

*** 1:63
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC

Ne, nrg, res, s = [], [], [], []
calcs = []

a = range(50)
del a[9]
images = Trajectory('./database/db1/MD1-63-1.traj', 'r')
Ne = [images[i].get_potential_energy() for i in a]
for i in a:
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_63/MD={}'.format(i),
                     xc='pbe',
                     kpts=[3, 3, 3],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)

plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-63md-2.png')
#+END_SRC

#+RESULTS:

[[./figures/1-63md-2.png]]

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC

Ne, nrg, res, s = [], [], [], []
calcs = []

a = [9]
images = Trajectory('./database/db1/MD1-63-1.traj', 'r')
Ne = [images[i].get_potential_energy() for i in a]
for i in a:
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_63/MD={}'.format(i),
                     xc='pbe',
                     kpts=[3, 3, 3],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_63/MD=9 submitted: 1446539.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_63/MD=9 Queued: 1446539.gilgamesh.cheme.cmu.edu

** NEB-MD
*** 222 image1
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db1/MDimage1.traj', 'r')
#Ne = [images[i].get_potential_energy() for i in range(0, 100)]
Ne = [images[i].get_potential_energy() for i in [22]]
#for i in np.arange(0, 100, 4):
for i in [22]:        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=1/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9]*3,
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=1/MD=22 submitted: 1446559.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=1/MD=22 Queued: 1446559.gilgamesh.cheme.cmu.edu

*** 222 image2
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db1/MDimage2.traj', 'r')


for i in range(50):        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=2/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9]*3,
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
#+END_SRC

*** 222 image3
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db1/MDimage3.traj', 'r')


for i in range(50):        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=3/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9]*3,
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
#+END_SRC

*** 222 image4
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db1/MDimage4.traj', 'r')

for i in range(50):        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=4/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9]*3,
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
#+END_SRC

** Elastic Constant
*** C11, C12
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.cubic import FaceCenteredCubic
from ase.lattice.cubic import BodyCenteredCubic
from ase.lattice.cubic import SimpleCubic
from ase.lattice.hexagonal import HexagonalClosedPacked
from ase.lattice.cubic import Diamond
from ase.visualize import view
import numpy as np

VASPRC['queue.walltime'] = '24:00:00'

factor = np.linspace(0, 0.04, 41)

#factor = np.linspace(0.85, 1.2, 10)

Energy = []

Volume = []

# FCC
for x in factor:
    fcc = FaceCenteredCubic('Pd',
                            directions = [[0, 1, 1],
                                          [1, 0, 1],
                                          [1, 1, 0]],
                            latticeconstant = 3.939)
    atoms = fcc
#Vary the cell   '     
    delta = np.array([[1.0+x, 0., 0.],
                      [0., 1.0+x, 0.],
                      [0., 0., 1.0/(1.0+x)**2]])
    atoms.set_cell(np.dot(atoms.get_cell(), delta),
                       scale_atoms = True)

    wd = './NDFT/bulk=fcc/type=elastic/dirs=11/factor={:.3f}'.format(x)
       
    calc = Vasp(wd,
              xc = 'PBE',
              kpts = [14]*3,
              encut = 350,
              nsw = 0,
              atoms = atoms)

            
    calc.calculate()


#+END_SRC

#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.04, 41)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=11/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
    #calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')

    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
plt.plot(factor, Ed/Vd[0], 'bo', label = 'DFT')
plt.plot(factor, En/Vd[0], 'ro', label = 'NN')
plt.plot(factor, func(factor, *poptd), 'b-', label = 'DFT fit')
plt.plot(factor, func(factor, *poptn), 'r-', label = 'NN fit')

plt.xlabel('Strain')
plt.ylabel('Energy Density [eV/$\AA^3$]')
plt.legend(loc='best')
plt.savefig('./figures/elastic-1.png')
#plt.show()
#+END_SRC

#+RESULTS:
: [ 2.21553499 -0.34127471]
: [ 2.91735716 -0.34129709]

[[./figures/elastic-1.png]]

*** C44
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.cubic import FaceCenteredCubic
from ase.visualize import view
import numpy as np

VASPRC['queue.walltime'] = '24:00:00'

factor = np.linspace(0, 0.04, 41)

#factor = np.linspace(0.85, 1.2, 10)

Energy = []

Volume = []

# FCC
for x in factor:
    fcc = FaceCenteredCubic('Pd',
                            directions = [[0, 1, 1],
                                          [1, 0, 1],
                                          [1, 1, 0]],
                            latticeconstant = 3.939)
    atoms = fcc
#Vary the cell   '     
    delta = np.array([[1.0, x, 0.],
                      [x, 1.0, 0.],
                      [0., 0., 1.0/(1.0-x**2)]])
    atoms.set_cell(np.dot(atoms.get_cell(), delta),
                       scale_atoms = True)

    wd = 'NDFT/bulk=fcc/type=elastic/dirs=44/factor={0:1.3f}'.format(x)
       
    calc = Vasp(wd,
              xc = 'PBE',
              kpts = [14]*3,
              encut = 350,
              nsw = 0,
              atoms = atoms) 

	      
    calc.calculate()


#+END_SRC

#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.04, 41)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=44/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

    #calc2 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
    calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
plt.plot(factor, Ed/Vd[0], 'bo', label = 'DFT')
plt.plot(factor, En/Vd[0], 'ro', label = 'NN')
plt.plot(factor, func(factor, *poptd), 'b-', label = 'DFT fit')
plt.plot(factor, func(factor, *poptn), 'r-', label = 'NN fit')

plt.xlabel('Strain')
plt.ylabel('Energy Density [eV/$\AA^3$]')
plt.legend(loc='best')
plt.savefig('./figures/elastic-2.png')
#plt.show()
#+END_SRC

#+RESULTS:
: [ 0.66616554 -0.34127543]
: [ 0.72645129 -0.34129566]

[[./figures/elastic-2.png]]
** Vacancy Diffusion NEB
*** 2*2*2
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic
VASPRC['wall.time'] = '24:00:00'
fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 2, 2])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/order=neb1/supercell=222/neb-initial',
          xc='pbe',
          kpts=[9, 9, 9],
          encut=350,
          atoms=ini)
c0.calculate()

fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/order=neb1/supercell=222/neb-final',
            xc='pbe',
            kpts=[9, 9, 9],
            encut=350,
            atoms=fin)
cend.calculate()
#+END_SRC

#+RESULTS:
: No calculation_required.
: No calculation_required.

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '16GB'
#VASPRC['wall.time'] = '24:00:00'
fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 2, 2])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/order=neb1/supercell=222/neb-initial',
          xc='pbe',
          kpts=[9, 9, 9],
          encut=350,
          atoms=ini)

fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/order=neb1/supercell=222/neb-final',
            xc='pbe',
            kpts=[9, 9, 9],
            encut=350,
            atoms=fin)

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(9)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=neb/order=neb1/supercell=222/neb',
            xc='pbe',
            kpts=[9, 9, 9],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/222-NEB-13.png')
#+END_SRC

#+RESULTS:


[[./figures/222-NEB-13.png]]

#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d
from ase.calculators.singlepoint import SinglePointCalculator as SPC

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
images, energies = calc.get_neb()

En, E = [], []
calc2 = Amp('./database/db1/2-24-2/-parameters-checkpoint-0.json')

for atoms in images:
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

En = np.array(En)
E = En-En[0]
x = range(len(images))
xarray = np.linspace(0, len(images))
f1 = interp1d(x, energies, kind='cubic', bounds_error=False)
f2 = interp1d(x, E, kind='cubic', bounds_error=False)
plt.plot(x, energies, 'bo', label = 'NEB')
plt.plot(x, E, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')

plt.savefig('./figures/NEB-NN-222.png')

#+END_SRC

#+RESULTS:

[[./figures/NEB-NN-222.png]]
#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
from ase.calculators.singlepoint import SinglePointCalculator as SPC
from ase.db import connect

db = connect('database/db2/data.db')
E0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb-initial').potential_energy
E = []
calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
images, energies = calc.get_neb()


[atoms.set_calculator(SPC(atoms, energy=energies[i]))
for i, atoms in enumerate(images)]

for i, atoms in enumerate(images):
    E += [atoms.get_potential_energy()+E0]

for i, image in enumerate (images):

    db.write(atoms, {'bulk':'fcc', 'dbkey':2, 'type':'neb', 'supercell':222})
#+END_SRC

#+RESULTS:

*** 2*2*3
c0-end
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['wall.time'] = '24:00:00'
fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 2, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-initial',
          xc='pbe',
          kpts=[9, 9, 5],
          encut=350,
          atoms=ini)
c0.calculate()
fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-final',
            xc='pbe',
            kpts=[9, 9, 5],
            encut=350,
            atoms=fin)
cend.calculate()
#+END_SRC

#+RESULTS:
: No calculation_required.
: No calculation_required.


#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '8GB'

fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 2, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-initial',
          xc='pbe',
          kpts=[9, 9, 5],
          encut=350,
          atoms=ini)

fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-final',
            xc='pbe',
            kpts=[9, 9, 5],
            encut=350,
            atoms=fin)

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb',
            xc='pbe',
            kpts=[9, 9, 5],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/223-NEB.png')
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.752733
:          Iterations: 15
:          Function evaluations: 30

[[./figures/223-NEB.png]]
#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb')
images, energies = calc.get_neb()
En, E = [], []
calc2 = Amp('./database/db1/2-24-2/-parameters-checkpoint-0.json')

for atoms in images:
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

En = np.array(En)
E = En-En[0]
x = range(len(images))
xarray = np.linspace(0, len(images))
f1 = interp1d(x, energies, kind='cubic', bounds_error=False)
f2 = interp1d(x, E, kind='cubic', bounds_error=False)
plt.plot(x, energies, 'bo', label = 'NEB')
plt.plot(x, E, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')

plt.savefig('./figures/NEB-NN-223.png')
#+END_SRC

#+RESULTS:

[[./figures/NEB-NN-223.png]]
*** 2*3*3
c0-end
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['wall.time'] = '24:00:00'
fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 3, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-initial',
          xc='pbe',
          kpts=[9, 5, 5],
          encut=350,
          atoms=ini)
c0.calculate()
fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-final',
            xc='pbe',
            kpts=[9, 5, 5],
            encut=350,
            atoms=fin)
cend.calculate()
#+END_SRC

#+RESULTS:
: No calculation_required.
: No calculation_required.


#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '8GB'


# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-initial')
ini = c0.get_atoms()

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-final')
fin = cend.get_atoms()

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb',
            xc='pbe',
            kpts=[9, 5, 5],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/233-NEB.png')
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.711185
:          Iterations: 15
:          Function evaluations: 30

[[./figures/233-NEB.png]]

#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb')
images, energies = calc.get_neb()
En, E = [], []
calc2 = Amp('./database/db1/2-24-2/-parameters-checkpoint-0.json')

for atoms in images:
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

En = np.array(En)
E = En-En[0]
x = range(len(images))
xarray = np.linspace(0, len(images))
f1 = interp1d(x, energies, kind='cubic', bounds_error=False)
f2 = interp1d(x, E, kind='cubic', bounds_error=False)
plt.plot(x, energies, 'bo', label = 'NEB')
plt.plot(x, E, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')

plt.savefig('./figures/NEB-NN-233.png')
#+END_SRC

#+RESULTS:

[[./figures/NEB-NN-233.png]]
*** 3*3*3
c0-end
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
				    latticeconstant = 3.939)


atoms = fcc.repeat([3, 3, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb-initial',
          xc='pbe',
          kpts=[5, 5, 5],
          encut=350,
          atoms=ini)
c0.calculate()
fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb-final',
            xc='pbe',
            kpts=[5, 5, 5],
            encut=350,
            atoms=fin)
cend.calculate()
#+END_SRC

#+RESULTS:
: No calculation_required.
: No calculation_required.


#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '8GB'


# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb-initial')
ini = c0.get_atoms()

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb-final')
fin = cend.get_atoms()

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(7)]dd
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb',
            xc='pbe',
            kpts=[5, 5, 5],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('.images/333-NEB.png')
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/neb submitted: 1443516.gilgamesh.cheme.cmu.edu

** Surface
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc111
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

#VASPRC['queue.walltime'] = '24:00:00'

factor = [1.00]
a0 = 3.939
nrg = []

atoms = fcc111('Pd', size=(3, 3, 5), a = a0,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)


calc = Vasp('NDFT/surface=fcc111//type=relaxation/supercell=33/factor=1.00',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=2,
            nsw=25,
            atoms=atoms)
		

calc.set_memory()
nrg += [calc.potential_energy]
slab = calc.get_atoms()
view(slab)
print nrg
#+END_SRC

#+RESULTS:

* DB
** write
*** DBkey0
#+BEGIN_SRC python
from vasp import Vasp

factor = [0.900, 0.950, 1.000, 1.050]
#factor = [0.900, 0.950, 1.050]
cells= ['222', '223', '233', '333', '334', '344', '444'] 
#cells = ['222']
calcs = []
for cell in cells:

    for x in factor:
    
        wd = './NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell={0}/factor={1:.3f}'.format(cell,x)
        #wd = './NDFT/bulk=fcc/type=vacancy/lattice=cubic/supercell={0}/factor={1:.3f}'.format(cell,x)
        calc = Vasp(wd)

        calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':0}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []
for i in range(200):
    wd = './NDFT/bulk=fcc/type=md/order=md0/v_a=0_8/MD={0}'.format(i)

    calc = Vasp(wd)
    calcs += [calc]
    calc.write_db('database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':0}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
import numpy as np

factor = np.append(np.arange(0.85, 1.2, 0.01),
                   np.arange(1.2, 2.125, 0.05))


cells = ['fcc', 'bcc', 'hcp', 'sc', 'diam']
for cell in cells:

    for x in factor:
    
   
        wd = './NDFT/bulk={0}/type=eos/factor={1:.2f}'.format(cell,x)
        calc = Vasp(wd)

        calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':0}) 
#+END_SRC

#+RESULTS:

*** DBkey1
**** 0:8
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
from vasp import Vasp
from vasp.vasprc import VASPRC

VASPRC['queue.walltime'] = '24:00:00'

calc1 = Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db0/2-20/-parameters-checkpoint-0.json')
images = Trajectory('./database/db0/MD-0:8.traj', 'r')
E1, E2 = [], []

for atoms in images:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in images:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)
res = E1-E2
res = np.array(res)
x = np.absolute(res)
t = []

for i in range(len(x)):
    if x[i] > 0.002:
        t += [i]


for i in t:        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=0_8/MD={}'.format(i))
    calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp

for i in range(200):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=0_8/MD={}'.format(i))
    calc.write_db('./database/db2/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

**** 1:7
#+BEGIN_SRC python
from vasp import Vasp

for i in range(51):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_7/MD={}'.format(i))
    calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

**** 1:11
#+BEGIN_SRC python
from vasp import Vasp

for i in range(22):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_11/MD={}'.format(i))
    calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

**** 1:17
#+BEGIN_SRC python
from vasp import Vasp

for i in range(38):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_17/MD={}'.format(i))
    calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

**** 1:26
#+BEGIN_SRC python
from vasp import Vasp

for i in range(16):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_26/MD={}'.format(i))
    calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

**** 1:35
#+BEGIN_SRC python
from vasp import Vasp

for i in range(10):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_35/MD={}'.format(i))
    calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

**** 1:47
#+BEGIN_SRC python
from vasp import Vasp

for i in range(10):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_47/MD={}'.format(i))
    calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

**** 1:63
#+BEGIN_SRC python
from vasp import Vasp

for i in range(10):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_63/MD={}'.format(i))
    calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':1})
#+END_SRC

#+RESULTS:

*** DBkey2
#+BEGIN_SRC python
from vasp import Vasp
import numpy as np

factor = np.linspace(0, 0.04, 41)

for x in factor:
    wd = './NDFT/bulk=fcc/type=elastic/dirs=11/factor={:.3f}'.format(x)

    calc = Vasp(wd)
    calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
import numpy as np

factor = np.linspace(0, 0.04, 41)

for x in factor: 
    wd = './NDFT/bulk=fcc/type=elastic/dirs=44/factor={:.3f}'.format(x)

    calc = Vasp(wd)
    calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC


#+RESULTS:

#+BEGIN_SRC python
'''
from vasp import Vasp
import numpy as np
from ase.calculators.singlepoint import SinglePointCalculator as SPC
from ase.db import connect

db = connect('database/db2/data.db')
E0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-initial').potential_energy
E = []
calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb')
images, energies = calc.get_neb()

E = E0 + energies


[atoms.set_calculator(SPC(atoms, energy=E[i]))
for i, atoms in enumerate(images)]

#for i, atoms in enumerate(images):
#    E += [atoms.get_potential_energy()]


for i, atoms in enumerate (images):
    db.write(atoms, {'bulk':'fcc', 'dbkey':2, 'type':'neb', 'supercell':223})
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
'''
from vasp import Vasp
import numpy as np
from ase.calculators.singlepoint import SinglePointCalculator as SPC
from ase.db import connect

db = connect('database/db2/data.db')
E0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-initial').potential_energy
E = []
calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb')
images, energies = calc.get_neb()

E = E0 + energies


[atoms.set_calculator(SPC(atoms, energy=E[i]))
for i, atoms in enumerate(images)]

#for i, atoms in enumerate(images):
#    E += [atoms.get_potential_energy()]


for i, atoms in enumerate (images):
    db.write(atoms, {'bulk':'fcc', 'dbkey':2, 'type':'neb', 'supercell':233})
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp

for cell in ['222', '223', '233', '333']:

    for i in range(9):
        wd = './NDFT/bulk=fcc/type=neb/supercell={0}/image={1}'.format(cell, i)
        calc = Vasp(wd)
        calc.write_db('database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []
for i in range(200):
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/MD={0}'.format(i)
    calc = Vasp(wd)
    
    calc.write_db('database/db2/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []
for i in range(200):
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_11/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db2/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []
for i in range(200):
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_17/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db2/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []
for i in range(200):
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db2/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []
for i in range(100):
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_47/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db2/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)
del a[9]
for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_63/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db2/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (100)

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db2/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []

#a = range(0, 21)
#a = range (23, 50)
a = range(0, 50)
del a[11]
del a[21]
#print a

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=1/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db2/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 


#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=2/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db2/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=3/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db2/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=4/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db2/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:
*** Chose data
**** 1-7
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db1/MD1-7-0.traj')
E1, E2 = [], []
ind = []
for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)

E = abs(E1-E2)
for i, e in enumerate(E):
    if e > 0.02:
        ind += [i]

print ind
print len(ind)
#+END_SRC

#+RESULTS:
: [86, 87, 88, 90, 91, 92, 97, 98, 99, 100, 101, 106, 107, 108, 109, 111, 112, 116, 117, 118, 120, 121, 122, 123, 129, 130, 131, 132, 133, 134, 141, 142, 143, 144, 145, 150, 151, 152, 153, 176, 177, 178, 179, 180, 181, 182, 183, 184, 188, 189, 190, 191, 196, 197, 198, 199]
: 56

**** 1-11
#+BEGIN_SRC python
import numpy as np
from amp import Amp
from vasp import Vasp

error = []
for i in range(200):

    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_11/MD={0}'.format(i)
    calc = Vasp(wd)
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    
    calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc1)
    E1 = atoms.get_potential_energy()

    error += [abs(E0 - E1)]


print  error
#+END_SRC

#+BEGIN_SRC python
import numpy as np

a = np.array([0.058930826630614774, 0.002797799755789754, 0.049353207615304484, 0.08088517666350725, 0.020742698756016864, 0.03774100445641437, 0.021176475719471455, 0.08406015176426962, 0.05529908636516012, 0.0010132526513331186, 0.013631783940482478, 0.05386039548609034, 0.06722637299041168, 0.025011465383471432, 0.007759523127084833, 0.022841862746773245, 0.03933754893682817, 0.0040137937735025275, 0.03216590957350718, 0.0026933239847295454, 0.058383660434678575, 0.061395195223880705, 0.01988222824208208, 0.005017412456751913, 0.02808666016517236, 0.02186687770961271, 0.01906674500084904, 0.0018946514851378993, 0.05350734851131733, 0.044710030207284035, 0.045768506648620644, 0.04571212012583459, 0.014673922653912541, 0.0222965601121885, 0.01214436226133131, 0.0016589837150391418, 0.006374694609071696, 0.04317113640203729, 0.04372613039753759, 0.0602538019776091, 0.019777123248303496, 0.003883295502909334, 0.0461764243217786, 0.05556203386262126, 0.011158986809149951, 0.00520698296175226, 0.08803559229279045, 0.020147647367871002, 0.03154981138066404, 0.04870710463049477, 0.1011242990015333, 0.06879541096351005, 0.03942277507218961, 0.09306624527260965, 0.08294646934503902, 0.03501480560091608, 0.035075986534536696, 0.07316637890220079, 0.12058382244847365, 0.1018721991645819, 0.12626653145019162, 0.04316692934868627, 0.008020505460699212, 0.02928194701528497, 0.10149802393249985, 0.116905008974733, 0.06090711967781459, 0.104154797434731, 0.09490780850769909, 0.05728763275044457, 0.008625945211910846, 0.11510500183192107, 0.1339858571534407, 0.07744055559573582, 0.005004334820561951, 0.03397482193817325, 0.047761066574253164, 0.04222248452243349, 0.016105877721052764, 0.098616281884496, 0.07650739094347614, 0.005555724921137539, 0.012586243825083443, 0.010134395006225816, 0.013919680484512753, 0.03343942359853713, 0.025447690972924875, 0.00957924212840311, 0.0653095888906563, 0.002659831945514668, 0.004175673127214452, 0.07348261293842029, 0.10445565935074086, 0.004219894108032918, 0.03931177563854504, 0.028420679387792802, 0.023160298925169798, 0.04211545287329699, 0.13186199191484604, 0.09280054579372887, 0.04321948527693564, 0.09758092350647729, 0.03256877495534383, 0.03997388670831725, 0.1549021765639651, 0.15193571724099542, 0.059218750697432654, 0.1459158547668764, 0.16385856465031878, 0.14863360681558646, 0.09709691272610144, 0.05511218596510048, 0.07693573655842556, 0.09851334329440675, 0.1359569085429797, 0.12207552283310719, 0.08451025780760091, 0.03686960737043421, 0.12313150965349706, 0.0879444727958969, 0.055582584882237995, 0.05578366261977408, 0.05803627256860722, 0.08066834282421098, 0.12464740876335156, 0.07131460594776229, 0.026440002067808166, 0.08430845617622396, 0.13938113144460118, 0.0972221062678571, 0.027891137823694123, 0.05266643400597104, 0.13984115877133263, 0.11897820055162356, 0.07208143834481717, 0.12378146767209586, 0.21478702415044637, 0.21057450970089064, 0.0951827807741239, 0.026971722032911316, 0.03521492631026746, 0.04674843360520242, 0.06380920020597358, 0.15790467151539644, 0.14524179569906437, 0.06705954117118296, 0.0292927735383941, 0.08984606029451214, 0.052150572889992475, 0.2009288877317701, 0.18882646144296444, 0.1638528338883205, 0.15733377122401038, 0.15501595671691604, 0.10151102097696452, 0.07608093511731084, 0.13636127164519252, 0.13531417014473135, 0.19056617716165647, 0.21959086957559748, 0.12917841832454968, 0.23316878944169872, 0.2124454596048082, 0.1508990520660376, 0.1207200066109948, 0.06333826370667595, 0.0036077794261970553, 0.0012459540238651812, 0.17828442142744905, 0.21248007499914934, 0.27399457625461565, 0.1809788531464136, 0.1119335081578825, 0.16607237778961093, 0.11439675200676902, 0.09551741773731948, 0.08455162693086038, 0.18622833116679516, 0.2289454709928762, 0.06996560126466989, 0.14369725363260244, 0.1664691894350696, 0.03607570936417659, 0.008303758544229822, 0.1765608549179234, 0.07099050375339999, 0.16514947595435103, 0.14286582102297984, 0.15114425196522063, 0.23231234590099348, 0.12766094204331324, 0.1849425032798493, 0.1820415220153606, 0.037647419451850794, 0.0669375255203164, 0.11571275369113465, 0.21402825266284964, 0.11377855264904468, 0.09255268772342617, 0.09822172999381706])


ind = []
for i, n in enumerate(a):
    if n > 0.05:
        ind += [i]

print ind
print len(ind)

#+END_SRC

#+RESULTS:
: [0, 3, 7, 8, 11, 12, 20, 21, 28, 39, 43, 46, 50, 51, 53, 54, 57, 58, 59, 60, 64, 65, 66, 67, 68, 69, 71, 72, 73, 79, 80, 88, 91, 92, 98, 99, 101, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 118, 119, 120, 121, 122, 123, 124, 125, 127, 128, 129, 131, 132, 133, 134, 135, 136, 137, 138, 142, 143, 144, 145, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 184, 185, 186, 187, 188, 189, 190, 191, 192, 194, 195, 196, 197, 198, 199]
: 121

**** 1-17
#+BEGIN_SRC python
import numpy as np
from amp import Amp
from vasp import Vasp

error = []
for i in range(200):

    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_17/MD={0}'.format(i)
    calc = Vasp(wd)
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    
    calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc1)
    E1 = atoms.get_potential_energy()

    error += [abs(E0 - E1)]


print  error
#+END_SRC

#+BEGIN_SRC python
import numpy as np

a = np.array([0.02816583686801266, 0.024573757311642908, 0.005468077361328483, 0.04561606107424154, 0.016222527966419875, 0.04944255969910216, 0.006731893422326607, 0.05441287928712768, 0.01881057730535929, 0.04242075492163622, 0.01899994364197255, 0.04178542395391105, 0.025039922483017563, 0.034619051823909786, 0.04530585277875332, 0.0053666283740057, 0.00838275603101124, 0.03480479206115206, 0.030115794468201784, 0.021187367045172323, 0.03688493771385026, 0.02863624406870713, 0.04046800502605663, 0.035289133990247024, 0.02930099368801109, 0.04948951344098873, 0.045491235486011306, 0.03568735258212996, 0.005857757493458848, 0.009877355891362072, 0.037213862776852125, 0.042802340851551435, 0.027444790265704455, 0.024586892709024255, 0.03937551795834793, 0.036603318691561526, 0.03016182713743376, 0.008202819852414223, 0.020199412249255033, 0.02655354015745104, 0.003402967996606776, 0.0279773431519601, 0.0401439421041232, 0.07540075104328992, 0.041058752193322334, 0.017619943869291887, 0.026605003600195687, 0.06595203296588181, 0.0022779928679454997, 0.05709405737664497, 0.02154128641414843, 0.06439210141665797, 0.04803111112535419, 0.004943930886057046, 0.011626708419527176, 0.05469898418130015, 0.04256502248287575, 0.021974740436789375, 0.014051506608183217, 0.03999138260799384, 0.01086187733049826, 0.028113232235170926, 0.0672113593040109, 0.007545306435289945, 0.023337024488412794, 0.01673928378342282, 0.09732613415570768, 0.03230042462537597, 0.03193474460059065, 0.023126640051529535, 0.06026887638617495, 0.0384707231713719, 0.001439460135586046, 0.009609980840622256, 0.08468126755315097, 0.12697178760885208, 0.01586657629800925, 0.021173325849716207, 0.03657013860745906, 0.08818585958553626, 0.05578068755578158, 0.06407813286152475, 0.0669466816182478, 0.035836217214296084, 0.01107208678345728, 0.04666735630893015, 0.013554704617746438, 0.048246401796887994, 0.06299719773046775, 0.0859522478814796, 0.07450152432234347, 0.006807591237816268, 0.012656778637094135, 0.03789040357573015, 0.07494441171878918, 0.13485661784973502, 0.13502420902102585, 0.07579299371016646, 0.003440401989209363, 0.025389727655991123, 0.019146719292237435, 0.08444424948163487, 0.08368932738443391, 0.005504874190449982, 0.04621050758649403, 0.02233045296307523, 0.05668117337519618, 0.0214376319263323, 0.042289173707928285, 0.06227649206968522, 0.038426893823654495, 0.02754487456506638, 0.04699807900205144, 0.11260842782735381, 0.0531213347052244, 0.02502216294601567, 0.03622393668652535, 0.060881787082948335, 0.06642744352647867, 0.07932654026375019, 0.03815120409413453, 0.0011010819677608197, 0.04465726754895627, 0.09665519550969748, 0.05372528229759155, 0.05158087982680115, 0.06882325327289607, 0.1580774680622028, 0.11506156247354227, 0.015635255205239673, 0.008615812922272426, 0.10369220605865337, 0.12519467337465073, 0.031062072166662347, 0.08326444283976286, 0.12542275354410037, 0.11367988488009928, 0.0021547121081084697, 0.01817775694316026, 0.07681928728138132, 0.1062251001378911, 0.05259009070206844, 0.07410909234960172, 0.13246774110915283, 0.0004668140151125044, 0.057560959861291394, 0.08931109806707127, 0.14392107630729356, 0.018872523846127365, 0.05800733569732586, 0.11823794958117162, 0.13318045218882446, 0.044574834133385366, 0.02524271639241249, 0.03311223909200578, 0.11272276981914331, 0.009715796905354068, 0.1171635019061199, 0.16566144423239848, 0.14709390330267524, 0.12629360042204496, 0.12037687075505232, 0.10062518734333992, 0.0811791545339986, 0.004896477749284145, 0.14804194608714738, 0.1373672464456206, 0.14197243564240125, 0.12648142308837862, 0.15803260285868248, 0.12008537461656488, 0.027123007142392908, 0.10028491854163235, 0.21417725743357607, 0.1816869513299082, 0.08821036567725571, 0.1771000008817083, 0.21223333124264343, 0.14395344360822548, 0.04414173977700386, 0.06643376370014664, 0.13107927692169596, 0.07903761431882117, 0.12407484807485503, 0.07976722469328479, 0.15920616732172732, 0.17146415634873335, 0.2115311840208136, 0.06478848391748215, 0.01486509898757049, 0.13578149060347755, 0.18596497296512382, 0.1464823091530434, 0.2533628418810707, 0.1935636593391905, 0.039757432904337975, 0.031174975424491436, 0.1731009344610328, 0.15095530127553047, 0.07153561629543503])


ind = []
for i, n in enumerate(a):
    if n > 0.05:
        ind += [i]

print ind
print len(ind)

#+END_SRC

#+RESULTS:
: [7, 43, 47, 49, 51, 55, 62, 66, 70, 74, 75, 79, 80, 81, 82, 88, 89, 90, 94, 95, 96, 97, 101, 102, 106, 109, 113, 114, 117, 118, 119, 123, 124, 125, 126, 127, 128, 131, 132, 134, 135, 136, 139, 140, 141, 142, 143, 145, 146, 147, 149, 150, 151, 155, 157, 158, 159, 160, 161, 162, 163, 165, 166, 167, 168, 169, 170, 172, 173, 174, 175, 176, 177, 178, 180, 181, 182, 183, 184, 185, 186, 187, 188, 190, 191, 192, 193, 194, 197, 198, 199]
: 91

**** 1-26
#+BEGIN_SRC python
import numpy as np
from amp import Amp
from vasp import Vasp

error = []
for i in range(200):

    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD={0}'.format(i)
    calc = Vasp(wd)
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    
    calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc1)
    E1 = atoms.get_potential_energy()

    error += [abs(E0 - E1)]


print  error
#+END_SRC

#+BEGIN_SRC python
import numpy as np

a = np.array([0.07411741149203976, 0.02954248750253896, 0.05583655460068826, 0.12697752313405886, 0.08098504961668596, 0.016990457595170483, 0.03563260670222235, 0.11077077446347516, 0.08531393519771768, 0.013401119621505586, 0.04121413728123002, 0.12191980282904069, 0.08851825544311964, 0.02528018192072068, 0.030149338133753645, 0.11507037835883693, 0.08105568470659819, 0.022278911218023723, 0.0430003221677282, 0.0908711705565679, 0.10244451902036644, 0.03235398769439257, 0.027027856101341285, 0.06595270509876627, 0.06739241046241773, 0.024779021585658256, 0.010647396740921522, 0.0522197161506881, 0.09074182220649618, 0.023593334612172612, 0.002048417108397871, 0.02322071939710213, 0.07719600729100762, 0.038158121303183634, 0.034285149829884176, 0.022338563267965128, 0.08104493780396638, 0.03990929510348451, 0.004162690562651505, 0.000182724354488073, 0.06043476901740519, 0.06737634367615897, 0.004366739324154878, 0.00171733850623923, 0.03100175128781757, 0.12883206399271785, 0.058525082751316404, 0.018981388337209637, 0.008602832570261398, 0.05931051648562402, 0.0025830500864856276, 0.01642836983091911, 0.05545640558295872, 0.05344401022651368, 0.0010300690867666162, 0.01775248570223198, 0.08379144407294348, 0.07271990305997633, 0.013216321045035784, 0.03741004072287524, 0.05778818257451235, 0.013622924590833918, 0.008402347103469765, 0.03342147160094555, 0.03414680056209818, 0.06614635877460273, 0.028660334551688038, 0.05003520436906683, 0.04771003442297683, 0.06860512835706345, 0.04164648398946724, 0.04948778622159011, 0.04914712955661571, 0.031638571946245975, 0.03426126579790889, 0.051505544591918806, 0.01697431065272781, 0.08414890084992521, 0.011355779533744226, 0.05888907188187886, 0.018581007761895307, 0.010359027698171985, 0.042060677930692236, 0.04281902596036957, 0.0026024686598304925, 0.017942331711992665, 0.05386280216387718, 0.0542231430444815, 0.003100420216128441, 0.019453144447965087, 0.06552383956764629, 0.07983723800273879, 0.010469918272292489, 0.014206184627767016, 0.020328607839417145, 0.016456712142542074, 0.018284806395513442, 0.05666578239413411, 0.008236877919358676, 0.020920803764283846, 0.013879251315302099, 0.04505862810799499, 0.005900560825608636, 0.04890307075558553, 0.012004700593081452, 0.0017546156170169525, 0.04204038444677849, 0.03858926451155753, 0.051368303329383025, 0.002157165800014127, 0.03517882991198462, 0.03538939282387332, 0.005747300610153161, 0.04079020780994824, 0.06156640138360103, 0.00965281271678009, 0.08625128479826571, 0.07508717281820054, 0.10203376117581797, 0.02348609354331188, 0.0654295555210922, 0.04835409663411383, 0.01987808065868535, 0.006697800275503596, 0.08404754145468019, 0.09283929878662889, 0.044580743461665406, 0.026248031435898156, 0.053506710821096704, 0.0593759733789625, 0.10197394922204239, 0.0406337331288853, 0.04282631250890745, 0.009022186748694594, 0.03601108609964854, 0.06139667760922407, 0.07083634096176183, 0.05515165554322721, 0.06100923554868132, 0.016923049625773956, 0.08987913275390724, 0.025042202162381955, 0.05641271061031716, 0.06212734655352392, 0.08630623991123798, 0.019120571744224435, 0.026493967035435162, 0.001239155912287515, 0.016059538676529428, 0.11814775047761827, 0.1352135031850139, 0.0327498897363796, 0.0051148577206561185, 0.0008889118671788765, 0.11606743662866847, 0.14439844469711716, 0.0613640638532047, 0.001586847901563715, 0.014964570635612517, 0.045599351854463066, 0.059079007025985675, 0.1201003536581311, 0.006707994740850154, 0.021911256730135165, 0.06968839920699565, 0.05722772914998586, 0.010284158120157372, 0.05804763296055171, 0.071494618597427, 0.0864365071828388, 0.06040696459336914, 0.06848851565226255, 0.026595772395296535, 0.019942937809531713, 0.05707330535079791, 0.0391890406848745, 0.03686919118840137, 0.04565923196753374, 0.015683793239617216, 0.08586323411947205, 0.05376864628425437, 0.062239232923559484, 0.13128933167726586, 0.0907316383128034, 0.037513866236025706, 0.04639628468501655, 0.05772162953428506, 0.07420482757194691, 0.05183514829889191, 0.030984867342880307, 0.060469153143969834, 0.03144705483987309, 0.0705135487817472, 0.05061525049160309, 0.07667590347199393, 0.0034034921438319543, 0.04589374172988414, 0.05780838692496104, 0.012138759791611164, 0.06101772815608797])


ind = []
for i, n in enumerate(a):
    if n > 0.05:
        ind += [i]

print ind
print len(ind)

#+END_SRC

#+RESULTS:
: [0, 2, 3, 4, 7, 8, 11, 12, 15, 16, 19, 20, 23, 24, 27, 28, 32, 36, 40, 41, 45, 46, 49, 52, 53, 56, 57, 60, 65, 67, 69, 75, 77, 79, 86, 87, 90, 91, 97, 108, 114, 116, 117, 118, 120, 124, 125, 128, 129, 130, 135, 136, 137, 138, 140, 142, 143, 144, 149, 150, 154, 155, 156, 160, 161, 164, 165, 167, 168, 169, 170, 171, 174, 179, 180, 181, 182, 183, 186, 187, 188, 190, 192, 193, 194, 197, 199]
: 87

**** 1-35
#+BEGIN_SRC python
import numpy as np
from amp import Amp
from vasp import Vasp

error = []
for i in range(100):

    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD={0}'.format(i)
    calc = Vasp(wd)
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    
    calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc1)
    E1 = atoms.get_potential_energy()

    error += [abs(E0 - E1)]


print  error
#+END_SRC


#+BEGIN_SRC python
import numpy as np

a = np.array([0.08796965805677814, 0.058057593859729195, 0.0710059713752571, 0.11434034124707182, 0.10058972905684982, 0.055661099799408476, 0.06743993893093148, 0.11584842232224446, 0.09414328552054485, 0.058747140353631266, 0.07873765673718935, 0.1363054833003332, 0.10656323506694321, 0.04649455074175535, 0.03518726010153728, 0.09132132578341157, 0.16066269795618382, 0.10790728180131737, 0.06398119128974145, 0.06089305008021029, 0.10424046619124283, 0.10400472899723923, 0.0461435030491657, 0.11276547129685355, 0.14914986164049537, 0.1253616395453605, 0.04469014321497866, 0.006560869630391153, 0.054324591539455014, 0.12206870295105432, 0.08239102173894253, 0.043262158904639136, 0.10189897794703029, 0.10839591845649466, 0.10222940545909864, 0.08408052077643902, 0.07785423196929742, 0.09887857267909794, 0.0678178626233148, 0.09398743871824422, 0.06816800642073417, 0.10650801408931443, 0.09635651954607738, 0.06863690455958249, 0.04678083425727664, 0.0999441031644892, 0.138586316220767, 0.06070472455891718, 0.03052550981166746, 0.0623832216371909, 0.11548607080351303, 0.08303006977618566, 0.08394731481251938, 0.06294165606317392, 0.04017985692033221, 0.0950742979849224, 0.12108649320526865, 0.11163546109449385, 0.0813957600306594, 0.10976238923771575, 0.08669009674977701, 0.019287991516932834, 0.0847202458816696, 0.09926417763554696, 0.13304675571123425, 0.07151953470258832, 0.028462396394701273, 0.053099703354803296, 0.13336130003671087, 0.044463265880182234, 0.011936694887594967, 0.0867157800803966, 0.17830826726347482, 0.10093981260152418, 0.018066948672469607, 0.023738505400302756, 0.12283903463446677, 0.14182172428186846, 0.06969992729275987, 0.012324302036745394, 0.05680703953584043, 0.05962879833697343, 0.010245318146388627, 0.10235086517340619, 0.21161735116908176, 0.18932344523619804, 0.006952243040444728, 0.007084410290730148, 0.07692102438616644, 0.15634340313368966, 0.15214305200365175, 0.13334754134683635, 0.05464686187571033, 0.03929106757712475, 0.10293888580969224, 0.15967318697394717, 0.09379856602780023, 0.10632403725441009, 0.11259183892710212, 0.14133820167549516])


ind = []
for i, n in enumerate(a):
    if n > 0.05:
        ind += [i]

print ind
print len(ind)

#+END_SRC

#+RESULTS:
: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 20, 21, 23, 24, 25, 28, 29, 30, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 45, 46, 47, 49, 50, 51, 52, 53, 55, 56, 57, 58, 59, 60, 62, 63, 64, 65, 67, 68, 71, 72, 73, 76, 77, 78, 80, 81, 83, 84, 85, 88, 89, 90, 91, 92, 94, 95, 96, 97, 98, 99]
: 80

**** 1-47
#+BEGIN_SRC python
import numpy as np
from amp import Amp
from vasp import Vasp

error = []
for i in range(100):

    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_47/MD={0}'.format(i)
    calc = Vasp(wd)
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    
    calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc1)
    E1 = atoms.get_potential_energy()

    error += [abs(E0 - E1)]


print  error
#+END_SRC


#+BEGIN_SRC python
import numpy as np

a = np.array([0.12495008235387672, 0.0987504264638801, 0.11859495618219285, 0.14446440733343024, 0.1341602309968266, 0.12804619462403366, 0.11059963835535314, 0.11201248098706174, 0.14683715660228813, 0.15803614156411072, 0.1490846188239061, 0.14953403571297486, 0.1668282869777613, 0.11222567297085106, 0.09876482406252762, 0.17721003811325886, 0.21837555102905526, 0.178279757642116, 0.09614482079393838, 0.11501186682318121, 0.11050549959205114, 0.11812894029449694, 0.14578834183865297, 0.1696607451102352, 0.15466470392695442, 0.1371473414267257, 0.10254079510872316, 0.1377572727770655, 0.1909365556072089, 0.17397784568748875, 0.1846228998304298, 0.23475590258212264, 0.18345498880287892, 0.12121902029952025, 0.13061280805476372, 0.18893208625385682, 0.1983350475950374, 0.17206078793876145, 0.11991585709378683, 0.202771951331016, 0.19773548119920292, 0.16143689003175155, 0.12436446452528571, 0.13236085233086214, 0.22832634331621193, 0.18347175676493066, 0.12180942604302913, 0.21849337030593574, 0.23439970385501852, 0.17024872903104438, 0.15517239638055003, 0.18354620826036694, 0.16918129425116035, 0.08518404599095675, 0.15240287103881656, 0.11618917907546233, 0.12244822219480511, 0.08278841334194453, 0.042052006463563885, 0.18549890017322923, 0.1596822136205276, 0.16977178790347125, 0.07457728218102488, 0.14913251699670127, 0.25148848541394386, 0.17413647830076684, 0.2268514381246689, 0.21823233222431782, 0.19760910676072285, 0.11998202915063416, 0.038077282909796395, 0.18731172818991126, 0.2465200710530837, 0.20870898288544026, 0.1409474912219082, 0.10970715681622778, 0.18065378136944332, 0.1155426773974284, 0.12441121571242775, 0.2560961815156588, 0.2727079805039523, 0.1542788126726009, 0.1550879377306842, 0.2593662290331622, 0.24208679230650887, 0.16538578453722153, 0.1774447521888476, 0.2164467618212882, 0.2060228301770053, 0.22298078839040159, 0.15217987089346252, 0.1724618309921766, 0.1520666493763656, 0.19560534702605992, 0.14305129569660835, 0.12225159802855501, 0.2960528062563128, 0.15846633377626063, 0.18159227002990974, 0.1783507079498179])


ind = []
for i, n in enumerate(a):
    if n > 0.05:
        ind += [i]

print ind
print len(ind)

#+END_SRC

#+RESULTS:
: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
: 98

*** Surface
#+BEGIN_SRC python
from vasp import Vasp
import numpy as np

factor = [1.00]

for x in factor:
    wd = 'NDFT/surface=fcc111/supercell=22/factor={:.2f}'.format(x)

    calc = Vasp(wd)
    calc.write_db('./database/db2/train-surface.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:

** DB3
*** DBkey2
#+BEGIN_SRC pythdon
from vasp import Vasp
import numpy as np

factor = np.linspace(0, 0.04, 41)

for x in factor:
    wd = './NDFT/bulk=fcc/type=elastic/dirs=11/factor={:.3f}'.format(x)

    calc = Vasp(wd)
    calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
import numpy as np

factor = np.linspace(0, 0.04, 41)

for x in factor:
    wd = './NDFT/bulk=fcc/type=elastic/dirs=44/factor={:.3f}'.format(x)

    calc = Vasp(wd)
    calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:


#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
from ase.calculators.singlepoint import SinglePointCalculator as SPC
from ase.db import connect

db = connect('database/db2/data.db')
E0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-initial').potential_energy
E = []
calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb')
images, energies = calc.get_neb()

E = E0 + energies


[atoms.set_calculator(SPC(atoms, energy=E[i]))
for i, atoms in enumerate(images)]

#for i, atoms in enumerate(images):
#    E += [atoms.get_potential_energy()]


for i, atoms in enumerate (images):
    db.write(atoms, {'bulk':'fcc', 'dbkey':2, 'type':'neb', 'supercell':223})
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
from ase.calculators.singlepoint import SinglePointCalculator as SPC
from ase.db import connect

db = connect('database/db2/data.db')
E0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-initial').potential_energy
E = []
calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb')
images, energies = calc.get_neb()

E = E0 + energies


[atoms.set_calculator(SPC(atoms, energy=E[i]))
for i, atoms in enumerate(images)]

#for i, atoms in enumerate(images):
#    E += [atoms.get_potential_energy()]


for i, atoms in enumerate (images):
    db.write(atoms, {'bulk':'fcc', 'dbkey':2, 'type':'neb', 'supercell':233})
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp

for cell in ['222', '223', '233', '333']:

    for i in range(9):
        wd = './NDFT/bulk=fcc/type=neb/supercell={0}/image={1}'.format(cell, i)
        calc = Vasp(wd)
        calc.write_db('database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []
a = [86, 87, 88, 90, 91, 92, 97, 98, 99, 100, 101, 106, 107, 108, 109, 111, 112, 116, 117, 118, 120, 121, 122, 123, 129, 130, 131, 132, 133, 134, 141, 142, 143, 144, 145, 150, 151, 152, 153, 176, 177, 178, 179, 180, 181, 182, 183, 184, 188, 189, 190, 191, 196, 197, 198, 199]
for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/MD={0}'.format(i)  
    calc = Vasp(wd)
    
    calc.write_db('database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []
a = [0, 3, 7, 8, 11, 12, 20, 21, 28, 39, 43, 46, 50, 51, 53, 54, 57, 58, 59, 60, 64, 65, 66, 67, 68, 69, 71, 72, 73, 79, 80, 88, 91, 92, 98, 99, 101, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 118, 119, 120, 121, 122, 123, 124, 125, 127, 128, 129, 131, 132, 133, 134, 135, 136, 137, 138, 142, 143, 144, 145, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 184, 185, 186, 187, 188, 189, 190, 191, 192, 194, 195, 196, 197, 198, 199]
for i in a:  
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_11/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []
a =  [7, 43, 47, 49, 51, 55, 62, 66, 70, 74, 75, 79, 80, 81, 82, 88, 89, 90, 94, 95, 96, 97, 101, 102, 106, 109, 113, 114, 117, 118, 119, 123, 124, 125, 126, 127, 128, 131, 132, 134, 135, 136, 139, 140, 141, 142, 143, 145, 146, 147, 149, 150, 151, 155, 157, 158, 159, 160, 161, 162, 163, 165, 166, 167, 168, 169, 170, 172, 173, 174, 175, 176, 177, 178, 180, 181, 182, 183, 184, 185, 186, 187, 188, 190, 191, 192, 193, 194, 197, 198, 199]
for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_17/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []
a = [0, 2, 3, 4, 7, 8, 11, 12, 15, 16, 19, 20, 23, 24, 27, 28, 32, 36, 40, 41, 45, 46, 49, 52, 53, 56, 57, 60, 65, 67, 69, 75, 77, 79, 86, 87, 90, 91, 97, 108, 114, 116, 117, 118, 120, 124, 125, 128, 129, 130, 135, 136, 137, 138, 140, 142, 143, 144, 149, 150, 154, 155, 156, 160, 161, 164, 165, 167, 168, 169, 170, 171, 174, 179, 180, 181, 182, 183, 186, 187, 188, 190, 192, 193, 194, 197, 199]
for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.db import connect

db = connect('./database/db3/data.db')


del db[1089]
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 20, 21, 23, 24, 25, 28, 29, 30, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 45, 46, 47, 49, 50, 51, 52, 53, 55, 56, 57, 58, 59, 60, 62, 63, 64, 65, 67, 68, 71, 72, 73, 76, 77, 78, 80, 81, 83, 84, 85, 88, 89, 90, 91, 92, 94, 95, 96, 97, 98, 99]

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []
for i in range(100):
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_47/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)
del a[9]
for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_63/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []

#a = range(0, 21)
#a = range (23, 50)
a = range(0, 50)
del a[11]
del a[21]
#print a

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=1/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 


#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=2/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=3/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=4/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db2/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:
** keywords
#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

from ase.db import connect

db = connect('./database/db2/train-surface.db')
data = db.select(['calculator'])

keys, cnt = {}, 0
for entry in data:
    cnt += 1
    for k, v in entry.key_value_pairs.iteritems():
        
        if k in keys:
            keys[k] += [v]
        else:
            keys[k] = [v]

print ('{0:15s} {1:15s} {2} calculations total'.format('keyword', 'value',cnt))

print('------------------------------------------------------')

for k, v in keys.iteritems():
    vals = list(set(v))
    if len(vals) <= 5:
        val = ", ".join(str(e) for e in vals)
        print('{0:15}: {1}'.format(k, val))

    else:
        val = ", ".join(str(e)[:5] for e in vals[:5])
        print('{0:15s}:{1}, etc...'.format(k, val))
#+END_SRC

#+RESULTS:
#+begin_example
keyword         value           1971 calculations total
------------------------------------------------------
dirs           : 11, 44
MD             :0, 1, 2, 3, 4, etc...
train_set      : True
image          : 1, 2, 3, 4
dbkey          : 0, 1, 2
bulk           : sc, hcp, fcc, diam, bcc
lattice        : primitive, cubic
supercell      :33, 233, 333, 334, 22, etc...
v_a            :1_26, 1_47, 1_63, 1_11, 1_17, etc...
surface        : fcc111
factor         :1.75, 1.5, 2.0, 0.0, 1.0, etc...
type           : eos, md, vacancy, elastic
order          : md2, md0, md1
#+end_example

* Training
** Training Set
#+BEGIN_SRC python
from ase.db import connect
import os
import random
import numpy as np

db = connect('./database/db2/data.db')

n = db.count()
n_train = int(round(n * 0.9))

n_ids =  np.array(range(n)) + 1

# This will sudo-randomly select 10% of the calculations
# Which is useful for reproducing our results.
random.seed(256)
train_samples = random.sample(n_ids, n_train)
valid_samples = set(n_ids) - set(train_samples)

db.update(list(train_samples), train_set=True)
db.update(list(valid_samples), train_set=False)

with connect('./database/db2/train-sur.db') as db0:
    for d in db.select(['train_set=True']):
        db0.write(d, key_value_pairs=d.key_value_pairs)
#+END_SRC

#+RESULTS:

** Train
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

# We will try an iteration for n nodes with l hidden layers.
for l in [2]:
    
    for n in [15, 18, 20, 25, 30]:

        label = '{0}-{1}-0'.format(l,n)
        layer=(l,n)
        wd = os.path.join(home, './database/db2/' + label)

        if not os.path.exists(wd):
            os.makedirs(wd)

        os.chdir(wd)

        run_amp = '''#!/usr/bin/env python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

calc = Amp(label="./",
           descriptor=Behler(cutoff=6.5),
           regression=NeuralNetwork(hiddenlayers={0}))

calc.train("~/Research/Bulk/database/db2/train.db", # The training data
           cores=2,
           extend_variables=False) 
'''.format(layer)

        cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=2
#PBS -l walltime=168:00:00
#PBS -l mem=16GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

        with open('submit.py', 'w') as f:
            f.write(run_amp)
        os.chmod('submit.py', 0777)

        with open('submit.sh', 'w') as f:
            f.write(cmd)

        subprocess.call(['qsub', 'submit.sh'])
        time.sleep(5)
        os.unlink('submit.sh')
        os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1446899.gilgamesh.cheme.cmu.edu
: 1446900.gilgamesh.cheme.cmu.edu
: 1446901.gilgamesh.cheme.cmu.edu
: 1446902.gilgamesh.cheme.cmu.edu
: 1446903.gilgamesh.cheme.cmu.edu
: 1446904.gilgamesh.cheme.cmu.edu
#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *
import os

for n in [15]:
    label = '2-{0}-0'.format(n)
    wd = os.path.join(os.getcwd(), 'database/db2/' + label)

    if not os.path.exists(wd):
        os.makedirs(wd)

    calc = Amp(load='./database/db2/2-{0}-0/-parameters-checkpoint-1.json'.format(n),
               label="./database/db2/{0}/".format(label),
               descriptor=Behler(cutoff=6.0),
               regression=NeuralNetwork(hiddenlayers=(2, '{0}'.format(n))))


    calc.train('./database/db2/train.db', # The training data
               cores=1,
               extend_variables=False) # feature does not work properly and will crash
#+END_SRC

#+RESULTS:

retrain
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

# We will try an iteration for n nodes with l hidden layers.
for l in [2]:
    
    for n in [30]:

        label = '{0}-{1}-sur2'.format(l,n)
        layer=(l,n)
        wd = os.path.join(home, './database/db2/' + label)

        if not os.path.exists(wd):
            os.makedirs(wd)

        os.chdir(wd)

        run_amp = '''#!/usr/bin/env python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

calc = Amp(load="./-parameters-checkpoint-1.json",
           label="./",
           descriptor=Behler(cutoff=6.5),
           regression=NeuralNetwork(hiddenlayers={1}))

calc.train("~/Research/Bulk/database/db2/train-sur.db", # The training data
           cores=4,
           extend_variables=False) 
'''.format(n, layer)

        cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=168:00:00
#PBS -l mem=16GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

        with open('submit.py', 'w') as f:
            f.write(run_amp)
        os.chmod('submit.py', 0777)

        with open('submit.sh', 'w') as f:
            f.write(cmd)

        subprocess.call(['qsub', 'submit.sh'])
        time.sleep(5)
        os.unlink('submit.sh')
        os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1449339.gilgamesh.cheme.cmu.edu

*** sur
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

# We will try an iteration for n nodes with l hidden layers.
for l in [2]:
    
    for n in [10, 15]:

        label = '{0}-{1}-sur'.format(l,n)
        layer=(l,n)
        wd = os.path.join(home, './database/db2/' + label)

        if not os.path.exists(wd):
            os.makedirs(wd)

        os.chdir(wd)

        run_amp = '''#!/usr/bin/env python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

calc = Amp(label="./",
           descriptor=Behler(cutoff=6.5),
           regression=NeuralNetwork(hiddenlayers={0}))

calc.train("~/Research/Bulk/database/db2/train-sur.db", # The training data
           cores=2,
           extend_variables=False) 
'''.format(layer)

        cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=2
#PBS -l walltime=168:00:00
#PBS -l mem=8GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

        with open('submit.py', 'w') as f:
            f.write(run_amp)
        os.chmod('submit.py', 0777)

        with open('submit.sh', 'w') as f:
            f.write(cmd)

        subprocess.call(['qsub', 'submit.sh'])
        time.sleep(5)
        os.unlink('submit.sh')
        os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1447032.gilgamesh.cheme.cmu.edu
: 1447033.gilgamesh.cheme.cmu.edu

** Update

#+BEGIN_SRC python
from ase.db import connect
from amp import Amp

db = connect('./database/db2/data.db')
calc1 = Amp(load = './database/db2/2-20-0/-parameters-checkpoint-0.json')
calc2 = Amp(load = './database/db2/2-30-sur2/-parameters-checkpoint-0.json')

for d in db.select():
    atoms = db.get_atoms(d.id)
    atoms.set_calculator(calc1)
    nrg1 = atoms.get_potential_energy()

    atoms.set_calculator(calc2)
    nrg2 = atoms.get_potential_energy()
    db.update(d.id, NN20 = nrg1, NN30 = nrg2)
#+END_SRC

#+RESULTS:

** Residual
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from ase.db import connect
from amp import Amp
import os

db = connect('database/db2/data.db')

fig, ax = plt.subplots(1, 2, sharey=True, figsize=(8, 4))

for i, n in enumerate([20, 30]):

    E, nnE, var, ind = [], [], [], []
    for j, d in enumerate(db.select('')):# dbkey=0
	E += [d.energy / d.natoms]
	nnE += [d['NN{}'.format(n)]/ d.natoms]
	var += [j]
	ind += [d.train_set]

    res = np.array(nnE) - np.array(E)
    mask = np.array(ind)
    valid = np.ma.masked_array(res, mask)
    train = np.ma.masked_array(res, ~mask)
    vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
    tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))

    ax[i].text(200, -0.050,
               'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
               color='b', ha='left')
    ax[i].text(200, -0.057,
               'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
               color='r', ha='left')

    ax[i].scatter(var, train, color='b')
    ax[i].scatter(var, valid, color='r')
    ax[i].plot([min(var), max(var)], [0, 0], 'k--')
    ax[i].set_xlim(min(var), max(var))

    ax[i].set_xlabel('Calculation ID')
    ax[i].set_title('8-{0}-{0}-1 framework'.format(n))

ax[0].set_ylim(-0.060, 0.060)
ax[0].set_ylabel('Residual error (eV/atom)')
plt.tight_layout()
plt.savefig('./figures/residual-2.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/residual-2.png]]
Large error configurations
#+BEGIN_SRC python
import numpy as np
from ase.db import connect
ids = []
db = connect('database/db2/data.db')
for i, d in enumerate(db.select('')):
    E = d.energy / d.natoms
    nE = d.NN30/ d.natoms
    if abs(E - nE) > 0.04:
        ids += [i]

print ids
#+END_SRC

#+RESULTS:
: [233, 244, 245, 301, 340, 355, 409, 410]



#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db2/data.db')

S, Qe, Ne = [], [], []

for d in db.select([]):
    S += [d.v_a]
    Qe += [d.energy/d.natoms]
    Ne += [d.NN30/d.natoms]
    
S = np.array(S)
Qe = np.array(Qe)
Ne = np.array(Ne)

cmap, hdl = {}, []

for s, c in zip(set(S), ['b', 'r', 'g', 'c', 'm']):
    cmap[s] = c
    hdl +=[mpatches.Patch(color = c, label = s)]

c = []
for s in S:
    c +=[cmap[s]]

RMSE = np.sqrt(sum((Ne-Qe)** 2) / len(Ne - Qe))

(mu, sigma) = norm.fit(Ne- Qe)

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
ax0.plot([min(Qe), 0], [0,0], 'k--', lw =2)
ax0.scatter(Qe, Ne-Qe, marker = 'o', color = c)
ax0.text(min(Qe) + 0.1, 0.14,
         'RMSE: {0:1.3f}'.format(RMSE),
         fontsize = 12, va = 'top', ha = 'left')
ax0.set_xlim(min(Qe), 0)
ax0.set_ylim(-0.045, 0.045)
ax0.set_xlabel('DFT potential energy (eV/atom)')
ax0.set_ylabel('Rsidual error (eV/atom)')
ax0.legend(loc = 'best', handles =hdl, fontsize = 8, frameon = False)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(Ne-Qe, 50,
                            range = (-0.01, 0.01),
                            weights = np.ones_like(Ne-Qe)/ len(Ne),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.05, 0.142, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.05, 0.122, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.01, 0.01)
ax1.set_xlim(0, 0.3)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
plt.tight_layout(w_pad = -0.5)
#plt.savefig('./images/fig-neural-train.png')
plt.show()

#+END_SRC

#+RESULTS:

* Application
** MD
*** Trajectory
**** NEB
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

for cell in ['222', '223', '233', '333']:
    
    for img in [1, 2, 3, 4]:
        
        label = '{0}-{1}'.format(cell, img)
        
        wd = os.path.join(home, './database/db2/' + label)

        if not os.path.exists(wd):
            os.makedirs(wd)

        os.chdir(wd)


        run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from vasp import Vasp

calc = Vasp("./../../../NDFT/bulk=fcc/type=neb/supercell=222/neb")
images, energies = calc.get_neb()


atoms = images[1]

atoms.set_calculator(Amp(load="./../2-30-0/-parameters-checkpoint-1.json"))
        
dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

        cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

        with open('submit.py', 'w') as f:
            f.write(run_md)
        os.chmod('submit.py', 0777)

        with open('submit.sh', 'w') as f:
            f.write(cmd)

        subprocess.call(['qsub', 'submit.sh'])
        time.sleep(5)
        os.unlink('submit.sh')
        os.chdir(wd)
#+END_SRC

#+BEGIN_SRC python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from vasp import Vasp

import os
import subprocess
import time

home = os.getcwd()

for cell in ['222', '223', '233', '333']:
    
    for img in [1, 2, 3, 4]:
        
        label = '{0}-{1}'.format(cell, img)
        
        wd = os.path.join(home, './database/db2/' + label)

        if not os.path.exists(wd):
            os.makedirs(wd)

        os.chdir(wd)


        calc = Vasp("./../../../NDFT/bulk=fcc/type=neb/supercell=222/neb")
        images, energies = calc.get_neb()


        atoms = images[1]

        atoms.set_calculator(Amp(load="./../2-30-0/-parameters-checkpoint-1.json"))
        
        dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


        def printenergy(a=atoms):
            epot = a.get_potential_energy() / len(a)
            ekin = a.get_kinetic_energy() / len(a)
    
        dyn.attach(printenergy, interval=10)

        traj = Trajectory("./MD.traj", "w", atoms)
        dyn.attach(traj.write, interval=10)

        dyn.run(2000)

#+END_SRC

**** Surface
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

label = '225-surface'
wd = os.path.join(home, './database/db2/' + label)

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(2, 2, 5), a=3.939, vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(Amp(load="./../2-30-0/-parameters-checkpoint-1.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD-fixed.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1451040.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

label = '335-surface'
wd = os.path.join(home, './database/db2/' + label)

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(3, 3, 5), a=3.939, vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(Amp(load="./../2-30-0/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD-fixed.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=48:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIRq
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1451727.gilgamesh.cheme.cmu.edu


#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db2/2-20-0/-parameters-checkpoint-0.json')
images = Trajectory('./database/db2/225-surface/MD.traj', 'r')
Ed = []
En = [images[i].get_potential_energy() for i in range(200)]
for i in range(200):
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md0/v_a=0_20/MD={}'.format(i))
    Ed += [calc.potential_energy]

plt.plot(range(len(En)), En, 'b-', label='NN prediction')
plt.scatter(range(len(Ed)), Ed, facecolor='none',
	   edgecolor='r', label='DFT calculation')

plt.xlim([0, 200])
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('222surface-md.png')
plt.show()
#+END_SRC

[[./figures/222surface-md.png]]

*** NN Predict
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db2/2-20-0/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db2/333-4/MD.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
plt.show()
#plt.savefig('./figures/MD1-7-2.png')
#+END_SRC

#+RESULTS:

*** Bulk
**** 8000
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

label = '0-8'
wd = os.path.join(home, './database/db2/' + label)

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 2, 2))
atoms.set_calculator(Amp(load="./../2-30-0/-parameters-checkpoint-1.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(8000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=48:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1451037.gilgamesh.cheme.cmu.edu

*** Vacancy
**** 1-63
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

label = '1-63'
wd = os.path.join(home, './database/db2/' + label)

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(4, 4, 4))

del atoms[0]
atoms.set_calculator(Amp(load="./../2-30-0/-parameters-checkpoint-1.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=20)

traj = Trajectory("./MD-long.traj", "w", atoms)
dyn.attach(traj.write, interval=20)

dyn.run(4000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=168:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1451758.gilgamesh.cheme.cmu.edu


#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
import jbtools.gilgamesh as jb

Ne = []
for i, atoms in enumerate(Trajectory('./database/db0/MD.traj', 'r')):

    Ne += [atoms.get_potential_energy()]

plt.plot(range(len(Ne)), Ne, 'bo')
#plt.savefig('./images/MD-NN.png')
plt.show()
#+END_SRC

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db2/2-20-0/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db2/1-63/MD.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
#plt.show()
plt.xlabel('MD Step')
plt.ylabel('Energy eV')
plt.legend()
plt.savefig('./figures/MD1-63-3.png')

#+END_SRC

#+RESULTS:

[[./figures/MD1-63-3.png]]

** NEB-NN
#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
images, energies = calc.get_neb()

En, E = [], []
calc2 = Amp('./database/db2/2-30-0/-parameters-checkpoint-0.json')

for atoms in images:
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

En = np.array(En)
E = En-En[0]
x = range(len(images))
xarray = np.linspace(0, len(images))
f1 = interp1d(x, energies, kind='cubic', bounds_error=False)
f2 = interp1d(x, E, kind='cubic', bounds_error=False)
plt.plot(x, energies, 'bo', label = 'NEB')
plt.plot(x, E, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
plt.show()
#+END_SRC
#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
from amp import Amp

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
images, energies = calc.get_neb()

calc0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb-initial')
E0 = calc0.potential_energy

energies = np.array(energies)
energies += E0

print energies


En, E = [], []
calc2 = Amp('./database/db2/2-30-0/-parameters-checkpoint-0.json')

for atoms in images:
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

print En
#+END_SRC

#+RESULTS:
: [-35.43371164 -35.42570645 -35.19608912 -34.88827938 -34.75807484
:  -34.88827927 -35.19608898 -35.42570641 -35.43371169]
: [-35.322470231901875, -35.31849228646374, -35.156207100533905, -34.85637361556328, -34.68250391909649, -34.85637347354207, -35.15620697841968, -35.31849225982069, -35.32247023190192]

** Bulk Properties
*** Cohesive energy
Atomic energy
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase import Atoms, Atom
from ase.visualize import view
VASPRC['queue.walltime'] = '24:00:00'

atoms = Atoms([Atom('Pd', [5, 5, 5])],
              cell = (7, 8, 9))

calc = Vasp('NDFT/atomic-Pd',
          xc = 'pbe',
          encut = 350,
          kpts = [1]*3,
          atoms = atoms) 

calc.calculate()

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/atomic-Pd submitted: 1442984.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
from vasp import Vasp
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')

calc = Vasp ('./NDFT/atomic-Pd') 
Eatom = calc.potential_energy
 
calc = Vasp ('./NDFT/bulk=fcc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEfcc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEfcc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=bcc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEbcc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEbcc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=hcp/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEhcp = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEhcp = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=sc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEsc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEsc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=diam/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEdiam = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEdiam = atoms.get_potential_energy()/len(atoms)
print DEfcc-Eatom, NEfcc-Eatom
print DEbcc-Eatom, NEbcc-Eatom
print DEhcp-Eatom, NEhcp-Eatom
print DEsc-Eatom, NEsc-Eatom
print DEdiam-Eatom, NEdiam-Eatom
#+END_SRC

#+RESULTS:
: -3.75476834 -3.75589508423
: -3.71312559 -3.73790838482
: -3.72459561 -3.76095602827
: -3.2532599 -3.26704062214
: -2.6162620675 -2.61824650251

*** Bulk Modulus
#+BEGIN_SRC python
from ase.db import connect
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState
from ase.units import kJ
import numpy as np
from vasp import Vasp
from amp import Amp

factor = np.arange(0.85, 1.2, 0.01)
calc2 = Amp(load = './database/db1/2-24-2/-parameters-checkpoint-0.json')
             #      np.arange(1.2, 2.125, 0.05))
configs = ['fcc', 'bcc', 'hcp', 'sc', 'diam']

for config in configs:
    nrg, vol = [], []
    nn = []
    for f in factor:
        calc = Vasp('./NDFT/bulk={0}/type=eos/factor={1:.2f}'.format(config,f))
        atoms = calc.get_atoms()
        nrg += [atoms.get_potential_energy()/len(atoms)]
        vol += [atoms.get_volume()/len(atoms)]
        atoms.set_calculator(calc2)
        nn +=[atoms.get_potential_energy()/len(atoms)]
        

    vol = np.array(vol)
    nrg = np.array(nrg)
    nn = np.array(nn)
# Fit the data to SJEOS
    eos = EquationOfState(vol, nrg)
    v0, e0, B0 = eos.fit()
    eos = EquationOfState(vol, nn)
    v1, e1, B1 = eos.fit()
    print '{0}'.format(config)
    print v0, e0, B0
    print v1, e1, B1
#+END_SRC

#+RESULTS:
#+begin_example
fcc
15.2979724806 -5.22438476072 1.09507457295
15.3564270183 -5.21520156705 1.07945263208
bcc
15.4257962561 -5.18249419589 1.06469804063
15.3991596967 -5.19211684448 1.08071951009
hcp
15.3645769219 -5.19379582623 1.08254355793
15.3341063992 -5.21621811798 1.09987534388
sc
17.8024966568 -4.72110919112 0.782438954048
17.8334288446 -4.71777979115 0.775358668286
diam
24.3558101786 -4.08130798908 0.428150007251
24.346708419 -4.08117208591 0.428715107213
#+end_example

*** Elastic Constant
**** 11, 12
#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.01, 11)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=11/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load='./database/db2/2-30-0/-parameters-checkpoint-1.json')
    #calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
#+END_SRC

#+RESULTS:
: [ 2.22936683 -0.34128023]
: [ 3.51781497 -0.34109004]

#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.01, 11)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=11/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load='./database/db2/2-30-0/-parameters-checkpoint-1.json')
    #calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')

    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
plt.plot(factor, Ed/Vd[0], 'bo', label = 'DFT')
plt.plot(factor, En/Vd[0], 'ro', label = 'NN')
plt.plot(factor, func(factor, *poptd), 'b-', label = 'DFT fit')
plt.plot(factor, func(factor, *poptn), 'r-', label = 'NN fit')

plt.xlabel('Strain')
plt.ylabel('Energy Density [eV/$\AA^3$]')
plt.legend(loc='best')
#plt.savefig('./figures/elastic-1.png')
plt.show()
#+END_SRC

#+RESULTS:
: [ 2.22936683 -0.34128023]
: [ 3.51781497 -0.34109004]

**** 44
#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.01, 11)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=44/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load='./database/db2/2-30-0/-parameters-checkpoint-1.json')
    #calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
#+END_SRC

#+RESULTS:
: [ 0.73280411 -0.34127966]
: [ 0.8152848 -0.3410909]

**** calculation
#+BEGIN_SRC python
'''
B = 1.09507457295
a = 2.21553499/6
b = 0.66616554
'''

B = 1.0950
a = 3.0178/6
b = 0.8153
C4 = b/2
C2 = (3*B - 2*a)/3
C1 = 2*a + C2

print C1, C2, C4
print C1 * 160.2177
print C2 * 160.2177
print C4 * 160.2177
#+END_SRC

#+RESULTS:
: 1.76562222222 0.759688888889 0.40765
: 282.883931513
: 121.715606493
: 65.312745405

**** reference 
#+BEGIN_SRC python
from vasp import Vasp
calc = Vasp('~/Research/Bulk/DFT/bulk=fcc/type=elastic/elastic')

EM = calc.get_elastic_moduli()

print EM
#+END_SRC

#+RESULTS:
: [[ 206.71093  155.54113  155.54113    0.         0.         0.     ]
:  [ 155.54113  206.71093  155.54113    0.         0.         0.     ]
:  [ 155.54113  155.54113  206.71093    0.         0.         0.     ]
:  [   0.         0.         0.        59.78395    0.         0.     ]
:  [   0.         0.         0.         0.        59.78395    0.     ]
:  [   0.         0.         0.         0.         0.        59.78395]]

** Vacancy formation
*** 222
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=222/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*7
print Ev
#+END_SRC

#+RESULTS:
: 1.06765175


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 2, 2)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (7/8.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  10:04:17      -35.323077       0.0000
: Vacancy formation energy with NN is: 1.158 eV
: -41.6921809084
: -35.3230768877

*** 223
     
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=223/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*11
print Ev
#+END_SRC

#+RESULTS:
: 1.13510973


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 2, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (11/12.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  10:08:55      -56.116879       0.7401
: BFGS:   1  10:09:01      -56.136758       0.6208
: BFGS:   2  10:09:07      -56.172858       0.1487
: BFGS:   3  10:09:13      -56.173163       0.1054
: BFGS:   4  10:09:19      -56.173243       0.0910
: BFGS:   5  10:09:24      -56.173405       0.0330
: Vacancy formation energy with NN is: 1.153 eV
: -62.5382713626
: -56.1734049327

*** 233
     
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=233/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*17
print Ev
#+END_SRC

#+RESULTS:
: 1.15516594


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 3, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (17/18.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  10:11:55      -87.352273       0.6760
: BFGS:   1  10:12:09      -87.382656       0.5809
: BFGS:   2  10:12:22      -87.449470       0.1658
: BFGS:   3  10:12:36      -87.449810       0.0709
: BFGS:   4  10:12:49      -87.449782       0.0621
: BFGS:   5  10:13:03      -87.448243       0.0260
: Vacancy formation energy with NN is: 1.148 eV
: -93.8074070438
: -87.4482427447

*** 333
     
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=333/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*26
print E1
print E0*27
print Ev
#+END_SRC

#+RESULTS:
: -134.47545389
: -140.79068946
: 1.10076559


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (3, 3, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (26/27.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  10:15:55     -134.259635       0.5909
: BFGS:   1  10:16:25     -134.295713       0.5128
: BFGS:   2  10:16:59     -134.376645       0.1256
: BFGS:   3  10:17:33     -134.373331       0.0840
: BFGS:   4  10:18:09     -134.373707       0.0736
: BFGS:   5  10:18:45     -134.374974       0.0360
: Vacancy formation energy with NN is: 1.125 eV
: -140.711110566
: -134.374974352

*** 334
     
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=334/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*35

print Ev
#+END_SRC

#+RESULTS:
: 1.07033284


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (3, 3, 4)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (35/36.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  10:40:34     -181.168995       0.4837
BFGS:   1  10:41:20     -181.198978       0.4371
BFGS:   2  10:42:06     -181.292172       0.1463
BFGS:   3  10:42:52     -181.297291       0.0998
BFGS:   4  10:43:38     -181.300006       0.0885
BFGS:   5  10:44:23     -181.306581       0.0545
BFGS:   6  10:45:09     -181.307656       0.0681
BFGS:   7  10:45:55     -181.306891       0.0800
BFGS:   8  10:46:41     -181.304284       0.0811
BFGS:   9  10:47:27     -181.299184       0.0682
BFGS:  10  10:48:13     -181.294990       0.0504
BFGS:  11  10:48:59     -181.293067       0.0459
Vacancy formation energy with NN is: 1.110 eV
-187.614814088
-181.29306683
#+end_example

*** 344
     
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=344/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*47
print Ev

#+END_SRC

#+RESULTS:
: 1.0137827


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (3, 4, 4)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (47/48.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  11:51:49     -243.709851       0.3831
BFGS:   1  11:53:00     -243.735689       0.3473
BFGS:   2  11:54:11     -243.847779       0.1092
BFGS:   3  11:55:22     -243.855635       0.1107
BFGS:   4  11:56:33     -243.868125       0.0804
BFGS:   5  11:57:45     -243.871778       0.0628
BFGS:   6  11:58:56     -243.871070       0.0440
Vacancy formation energy with NN is: 1.070 eV
-250.152955507
-243.871069593
#+end_example

*** 444
     
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=444/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*63
print Ev
#+END_SRC

#+RESULTS:
: 0.96277588


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (4, 4, 4)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (63/64.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  10:22:58     -327.095298       0.2871
: BFGS:   1  10:24:48     -327.119921       0.2601
: BFGS:   2  10:26:53     -327.231549       0.1002
: BFGS:   3  10:28:55     -327.238182       0.0787
: BFGS:   4  10:31:00     -327.259021       0.0256
: Vacancy formation energy with NN is: 1.067 eV
: -333.537447267
: -327.259021011

| Supercell | E_DFT(eV) | E_NN(eV) | Error(eV) | Error(%) |
|       222 |     1.068 |    1.158 |     0.090 |     8.42 |
|       223 |     1.135 |    1.153 |     0.018 |     1.59 |
|       233 |     1.155 |    1.148 |     0.007 |     0.61 |
|       333 |     1.101 |    1.125 |     0.024 |     2.17 |
|       334 |     1.070 |    1.110 |     0.040 |     3.73 |
|       344 |     1.014 |    1.070 |     0.056 |     5.52 |
|       444 |     0.963 |    1.067 |     0.104 |    10.80 |

** EOS
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState
from ase.db import connect
from amp import Amp
from ase.visualize import view
import os
import json
import time
from ase.units import kJ

db = connect('./database/db2/data.db')

f, ax = plt.subplots(1, 5, figsize = (12, 5))
tag = ['FCC', 'BCC', 'HCP', 'SC', 'Diamond']

for i, key in enumerate(['fcc', 'bcc', 'hcp', 'sc', 'diam']):

    V, Qe, Re, Ne = [], [], [], []

    for d in db.select(['bulk={0}'.format(key), 'type=eos']):
        V += [d.volume / d.natoms]
        Qe += [d.energy / d.natoms]
        Ne += [d.NN30 / d.natoms]

    srt = [j[0] for j in sorted(enumerate(V), key = lambda x:x[1])]
    V = np.array(V)[srt]
    Qe = np.array(Qe)[srt]
    Ne = np.array(Ne)[srt]

    ax[i].plot(V, Qe, 'k-', lw=2, label = 'DFT')
    ax[i].plot(V, Ne, 'r--', lw=2, label = 'Neural')

    if i >0:
        ax[i].set_yticklabels([])

    ax[i].set_ylim(-6 , 0)
    ax[i].set_xlim(0, 150)
    ax[i].set_xticks([0, 40, 80, 120])
    ax[i].set_title('{0}'.format(tag[i]))

ax[0].set_ylabel('Potantial energy (eV/atom)')
ax[2].set_xlabel('Volume ($\AA$/atom)')
ax[4].legend(loc = 'best', fontsize = 12)
plt.tight_layout(w_pad=-1.3)
plt.savefig('./figures/eos-NN-2.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/eos-NN-2.png]]

#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt


E1, E2 = [], []

factor = np.linspace(0.85, 2.5, 1000)
for x in factor :

    atoms = FaceCenteredCubic('Pd',
                              directions=[[0, 1, 1],
                                          [1, 0, 1],
                                          [1, 1, 0]],
                              latticeconstant=3.933)
    
    delta = np.array([[x, 0., 0.],
                      [0., x, 0.],
                      [0., 0., x]])
    atoms.set_cell(np.dot(atoms.get_cell(), delta),
                   scale_atoms=True)
    calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
    calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
    
    atoms.set_calculator(calc1)
    E1 += [atoms.get_potential_energy()]

    atoms.set_calculator(calc2)
    E2 += [atoms.get_potential_energy()]

E1 = np.array(E1)
E2 = np.array(E2)
res = abs(E1 - E2)
#print E1


f, ax = plt.subplots(2, 1, sharex=True)
ax[0].plot(factor, E1, 'b', lw=2, label='2-24')
ax[0].plot(factor, E2, 'r', lw=2, label='2-30')
ax[0].plot([0.85, 0.85], [2, -6], 'k--')
ax[0].plot([2.1, 2.1], [2, -6], 'k--')
ax[0].set_ylabel('Potential energy (eV)')
ax[0].set_xlim(0.6, 2.5)
ax[0].set_ylim(-6, 2)
ax[0].legend(loc='best')
ax[1].plot(factor, res)
ax[1].plot([0.85, 0.85], [0, 0.5], 'k--')
ax[1].plot([2.07, 2.1], [0, 0.5], 'k--')
ax[1].set_ylabel('NN energy difference (eV)')
ax[1].set_ylim(0, 0.5)
ax[1].set_xlabel('Strain/stretch factor (%)')
plt.tight_layout(w_pad=0.0)
plt.savefig('./figures/app-eos.png')
#+END_SRC

#+RESULTS:

[[./figures/app-eos.png]]


* 4th DFT
** Surface-MD
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db2/225-surface/MD-fixed.traj', 'r')
#Ne = [images[i].get_potential_energy() for i in range(0, 100)]
Ne = [images[i].get_potential_energy() for i in range(0, 200)]
#for i in np.arange(0, 100, 4):
for i in range(200):        
        calc = Vasp('NDFT/surface=fcc111/type=md/order=md0/v_a=0_20/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9, 9, 1],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)

plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
#plt.show()
plt.savefig('./figures/surf225.png')
#+END_SRC

[[./figures/surf225.png]]
** NEB-MD
*** 222
#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
from vasp.vasprc import VASPRC
VASPRC['queue.walltime']='24:00:00'

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
images, energies = calc.get_neb()

for i, atoms in enumerate(images):

    calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/image={0}'.format(i),
                 xc='pbe',
                 kpts=[9]*3,
                 encut=350,
                 nsw=0,
                 atoms=images[i])
    calc.potential_energy
#+END_SRC

*** 223
#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
from vasp.vasprc import VASPRC
VASPRC['queue.walltime']='24:00:00'

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb')
images, energies = calc.get_neb()

for i, atoms in enumerate(images):

    calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/image={0}'.format(i),
                 xc='pbe',
                 kpts=[9, 9, 5],
                 encut=350,
                 nsw=0,
                 atoms=images[i])
    calc.potential_energy
#+END_SRC

#+RESULTS:
#+begin_example
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=0 submitted: 1447048.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=0 Queued: 1447048.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=1 submitted: 1447049.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=1 Queued: 1447049.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=2 submitted: 1447050.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=2 Queued: 1447050.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=3 submitted: 1447051.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=3 Queued: 1447051.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=4 submitted: 1447052.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=4 Queued: 1447052.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=5 submitted: 1447053.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=5 Queued: 1447053.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=6 submitted: 1447054.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=6 Queued: 1447054.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=7 submitted: 1447055.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=7 Queued: 1447055.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=8 submitted: 1447056.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=8 Queued: 1447056.gilgamesh.cheme.cmu.edu
#+end_example

*** 233
#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
from vasp.vasprc import VASPRC
VASPRC['queue.walltime']='24:00:00'

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb')
images, energies = calc.get_neb()

for i, atoms in enumerate(images):

    calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/image={0}'.format(i),
                 xc='pbe',
                 kpts=[9, 5, 5],
                 encut=350,
                 nsw=0,
                 atoms=images[i])
    calc.potential_energy
#+END_SRC

*** 333
#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
from vasp.vasprc import VASPRC
VASPRC['queue.mem']='4GB'

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb')
images, energies = calc.get_neb()

for i, atoms in enumerate(images):

    calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/image={0}'.format(i),
                 xc='pbe',
                 kpts=[9]*3,
                 encut=350,
                 nsw=0,
                 atoms=images[i])
    calc.potential_energy
#+END_SRC

#+RESULTS:
#+begin_example
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=0 submitted: 1447095.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=0 Queued: 1447095.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=1 submitted: 1447096.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=1 Queued: 1447096.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=2 submitted: 1447097.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=2 Queued: 1447097.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=3 submitted: 1447098.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=3 Queued: 1447098.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=4 submitted: 1447099.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=4 Queued: 1447099.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=5 submitted: 1447100.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=5 Queued: 1447100.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=6 submitted: 1447101.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=6 Queued: 1447101.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=7 submitted: 1447102.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=7 Queued: 1447102.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=8 submitted: 1447103.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=8 Queued: 1447103.gilgamesh.cheme.cmu.edu
#+end_example

** Vacancy
2*2*2 = [9, 9, 9]
3*3*3 = [5, 5, 5] 2GB
4*4*4 = [3, 3, 3] 4GB
*** Primitive
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase import Atoms, Atom
from ase.lattice.cubic import FaceCenteredCubic
from ase.visualize import view
import numpy as np

VASPRC['queue.men'] = '4GB'

#factor = [0.9, 0.95, 1.0, 1.05]
factor = [1.000]
energies = []
for x in factor:

    fcc = FaceCenteredCubic('Pd',
                            directions=[[0, 1, 1],
                                        [1, 0, 1],
                                        [1, 1, 0]],
                            latticeconstant = 3.939)

    delta = np.array([[x, 0., 0.],
                      [0., x, 0.],
                      [0., 0., x]])
    fcc.set_cell(np.dot(fcc.get_cell(), delta),
                       scale_atoms = True)

    atoms = fcc.repeat([3, 4, 4])

    cnt = len(atoms)
    del atoms[0]
    atoms.rattle()
    
    wd = './NDFT/bulk=fcc/type=vacancy/vrelax=True/supercell=344/factor={0:1.3f}'.format(x)
    calc = Vasp(wd,
                xc='pbe',
                encut=350,
                kpts = [5, 3, 3],
                ibrion = 2,
                isif = 3,
                nsw = 25,
                atoms = atoms)

    energies.append(calc.potential_energy) 

print energies


#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=vacancy/vrelax=True/supercell=344/factor=1.000 submitted: 1449347.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=vacancy/vrelax=True/supercell=344/factor=1.000 Queued: 1449347.gilgamesh.cheme.cmu.edu
: [None]

#+BEGIN_SRC python
from vasp import Vasp

factor = [0.9, 0.95, 1.0, 1.05]
nrg, calcs = [], []
for f in factor:
    calc = Vasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=222/factor={0:1.3f}'.format(f))
    calcs  += [calc]
    nrg +=[calc.potential_energy]

Vasp.stop_if(None in nrg)


[calc.write_db('database/master.db', parser='=', overwrite=False) for calc in calcs]
#+END_SRC

* DB
#+BEGIN_SRC python
from vasp import Vasp
for i in range(200):        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md0/v_a=0_20/MD={}'.format(i))
    calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':3}) 
#+END_SRC

#+RESULTS:

** keywords
#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

from ase.db import connect

db = connect('./database/db3/data.db')
data = db.select([])

keys, cnt = {}, 0
for entry in data:
    cnt += 1
    for k, v in entry.key_value_pairs.iteritems():
        
        if k in keys:
            keys[k] += [v]
        else:
            keys[k] = [v]

print ('{0:15s} {1:15s} {2} calculations total'.format('keyword', 'value',cnt))

print('------------------------------------------------------')

for k, v in keys.iteritems():
    vals = list(set(v))
    if len(vals) <= 5:
        val = ", ".join(str(e) for e in vals)
        print('{0:15}: {1}'.format(k, val))

    else:
        val = ", ".join(str(e)[:5] for e in vals[:5])
        print('{0:15s}:{1}, etc...'.format(k, val))
#+END_SRC
#+RESULTS:
#+begin_example
keyword         value           1739 calculations total
------------------------------------------------------
dirs           : 11, 44
MD             :0, 1, 2, 3, 4, etc...
train_set      : False, True
image          :0, 1, 2, 3, 4, etc...
dbkey          : 0, 1, 2, 3
bulk           : sc, hcp, fcc, diam, bcc
lattice        : primitive
supercell      :233, 333, 334, 344, 444, etc...
v_a            :1_26, 1_47, 1_63, 0_20, 1_11, etc...
vrelax         : False
factor         :1.25, 1.0, 2.0, 1.5, 0.036, etc...
type           : vacancy, md, neb, eos, elastic
order          : md2, md0, md1
surface        : fcc111
#+end_example

* Training
** Training Set
#+BEGIN_SRC python
from ase.db import connect
import os
import random
import numpy as np

db = connect('./database/db3/data.db')

n = db.count()
n_train = int(round(n * 0.9))

n_ids =  np.array(range(n)) + 1

# This will sudo-randomly select 10% of the calculations
# Which is useful for reproducing our results.
random.seed(256)
train_samples = random.sample(n_ids, n_train)
valid_samples = set(n_ids) - set(train_samples)

db.update(list(train_samples), train_set=True)
db.update(list(valid_samples), train_set=False)

with connect('./database/db3/train.db') as db0:
    for d in db.select(['train_set=True']):
        db0.write(d, key_value_pairs=d.key_value_pairs)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.db import connect
import os
import random
import numpy as np

db = connect('./database/db3/data.db')
for d in db.select('train_set=True'):
    atoms = d.toatoms()
    del atoms.constraints

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *
import os
from ase.db import connect
images= []
db = connect('database/db3/train.db')
for d in db.select(''):
    atoms = d.toatoms()
    del atoms.constraints
    images += [atoms]

for n in [10]:
    label = '2-{0}-0'.format(n)
    wd = os.path.join(os.getcwd(), 'database/db3/' + label)

    if not os.path.exists(wd):
        os.makedirs(wd)

    calc = Amp(label="./database/db2/{0}/".format(label),
               descriptor=Behler(cutoff=6.0),
               regression=NeuralNetwork(hiddenlayers=(2, '{0}'.format(n))))


    calc.train(images=images, # The training data
               data_format='db',
               cores=1,
               extend_variables=False) # feature does not work properly and will crash
#+END_SRC

** Training
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

# We will try an iteration for n nodes with l hidden layers.
for l in [2]:
    
    for n in [30]:

        label = '{0}-{1}-0'.format(l,n)
        layer=(l,n)
        wd = os.path.join(home, './database/db3/' + label)

        if not os.path.exists(wd):
            os.makedirs(wd)

        os.chdir(wd)

        run_amp = '''#!/usr/bin/env python
from amp import Amp
from amp.descriptor import *
from amp.regression import *
from ase.db import connect
images = []
db = connect("../train.db")

for d in db.select(''):
    atoms = d.toatoms()
    del atoms.constraints
    images += [atoms]

calc = Amp(load ="-parameters-checkpoint-1.json",
           label="./",
           descriptor=Behler(cutoff=6.5),
           regression=NeuralNetwork(hiddenlayers={0}))

calc.train(images=images,
           data_format="db",
           cores=4,
           extend_variables=False) 
'''.format(layer)

        cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=168:00:00
#PBS -l mem=16GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

        with open('submit.py', 'w') as f:
            f.write(run_amp)
        os.chmod('submit.py', 0777)

        with open('submit.sh', 'w') as f:
            f.write(cmd)

        subprocess.call(['qsub', 'submit.sh'])
        time.sleep(5)
        os.unlink('submit.sh')
        os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1452745.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
from amp import Amp
from ase.io import read
from amp import SimulatedAnnealing
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
import os, shutil

if os.path.exists('networks/db3/10-10/'):
    shutil.rmtree('networks/db3/10-10/')
    os.mkdir('networks/db3/10-10/')
else:
    os.mkdir('networks/db3/10-10/')

calc = Amp(
           label='networks/db/10-10/',
	   dblabel='networks/',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, 8)))

calc.train(images=read('database/AuPd.db', ':'),
	   data_format='db',
	   cores=4,
	   energy_goal=1e-3,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
#+END_SRC

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

for n in [18, 24]:

    wd = 'networks/db3/{0}-{0}/'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)
    os.chdir(wd)

    run_amp = """#!/usr/bin/env python
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing

db = connect('../../../database/db3/data.db')

images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=4,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
""".format(n)

    cmd = '''#!/bin/bash
#PBS -N {}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=24:00:00
#PBS -l mem=8GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

    with open('submit.py', 'w') as f:
        f.write(run_amp)
    os.chmod('submit.py', 0777)

    with open('submit.sh', 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', 'submit.sh'])
    time.sleep(2)
    os.unlink('submit.sh')
    os.chdir(home)
#+END_SRC

#+RESULTS:
: 1453339.gilgamesh.cheme.cmu.edu
: 1453340.gilgamesh.cheme.cmu.edu

load
load=os.path.join(wd, 'checkoutpoint-parameters-0.json'),
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

for n in [10, 15, 18, 20, 24, 25, 30]:

    wd = 'networks/db3/{0}-{0}/'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)
    os.chdir(wd)

    run_amp = """#!/usr/bin/env python
import os
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing

db = connect('../../../database/db3/data.db')
wd = os.getcwd()
images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(load='parameters.json',
           label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=4,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
""".format(n)

    cmd = '''#!/bin/bash
#PBS -N {}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=24:00:00
#PBS -l mem=8GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

    with open('submit.py', 'w') as f:
        f.write(run_amp)
    os.chmod('submit.py', 0777)

    with open('submit.sh', 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', 'submit.sh'])
    time.sleep(2)
    os.unlink('submit.sh')
    os.chdir(home)
#+END_SRC

#+RESULTS:
: 1453747.gilgamesh.cheme.cmu.edu
: 1453748.gilgamesh.cheme.cmu.edu
: 1453749.gilgamesh.cheme.cmu.edu
: 1453750.gilgamesh.cheme.cmu.edu
: 1453751.gilgamesh.cheme.cmu.edu
: 1453752.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing
import os

home = os.getcwd()
wd = 'networks/db3/10-10/'
os.chdir(wd)

db = connect('../../../database/db3/data.db')
wd = os.getcwd()
images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(load='parameters.json',
           label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=4,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
#+END_SRC

#+RESULTS:

** Update

#+BEGIN_SRC python
from ase.db import connect
from amp import Amp

db = connect('./database/db3/data.db')
calc1 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db3/25-25/checkpoint-parameters.json')

for d in db.select():
    atoms = db.get_atoms(d.id)
    atoms.set_calculator(calc1)
    nrg1 = atoms.get_potential_energy()

    atoms.set_calculator(calc2)
    nrg2 = atoms.get_potential_energy()
    db.update(d.id, NN24 = nrg1, NN25 = nrg2)
#+END_SRC

#+RESULTS:

** Residual
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from ase.db import connect
from amp import Amp
import os

db = connect('database/db3/data.db')

fig, ax = plt.subplots(1, 2, sharey=True, figsize=(8, 4))

for i, n in enumerate([24, 25]):

    E, nnE, var, ind = [], [], [], []
    for j, d in enumerate(db.select('')):# dbkey=0
	E += [d.energy / d.natoms]
	nnE += [d['NN{}'.format(n)]/ d.natoms]
	var += [j]
	ind += [d.train_set]

    res = np.array(nnE) - np.array(E)
    mask = np.array(ind)
    valid = np.ma.masked_array(res, mask)
    train = np.ma.masked_array(res, ~mask)
    vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
    tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))

    ax[i].text(200, -0.050,
               'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
               color='b', ha='left')
    ax[i].text(200, -0.057,
               'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
               color='r', ha='left')

    ax[i].scatter(var, train, color='b')
    ax[i].scatter(var, valid, color='r')
    ax[i].plot([min(var), max(var)], [0, 0], 'k--')
    ax[i].set_xlim(min(var), max(var))

    ax[i].set_xlabel('Calculation ID')
    ax[i].set_title('8-{0}-{0}-1 framework'.format(n))

ax[0].set_ylim(-0.060, 0.060)
ax[0].set_ylabel('Residual error (eV/atom)')
plt.tight_layout()
plt.savefig('./figures/residual-3.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/residual-3.png]]
Large error configurations
#+BEGIN_SRC python
import numpy as np
from ase.db import connect
ids = []
db = connect('database/db2/data.db')
for i, d in enumerate(db.select('')):
    E = d.energy / d.natoms
    nE = d.NN30/ d.natoms
    if abs(E - nE) > 0.04:
        ids += [i]

print ids
#+END_SRC

#+RESULTS:
: [233, 244, 245, 301, 340, 355, 409, 410]



#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db3/data.db')

S, Qe, Ne = [], [], []

for d in db.select(['bulk']):
    S += [d.bulk]
    Qe += [d.energy/d.natoms]
    Ne += [d.NN24/d.natoms]
    
S = np.array(S)
Qe = np.array(Qe)
Ne = np.array(Ne)

cmap, hdl = {}, []

for s, c in zip(set(S), ['b', 'r', 'g', 'c', 'm']):
    cmap[s] = c
    hdl +=[mpatches.Patch(color = c, label = s)]

c = []
for s in S:
    c +=[cmap[s]]

RMSE = np.sqrt(sum((Ne-Qe)** 2) / len(Ne - Qe))

(mu, sigma) = norm.fit(Ne- Qe)

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
ax0.plot([min(Qe), 0], [0,0], 'k--', lw =2)
ax0.scatter(Qe, Ne-Qe, marker = 'o', color = c)
ax0.text(min(Qe) + 0.1, 0.14,
         'RMSE: {0:1.3f}'.format(RMSE),
         fontsize = 12, va = 'top', ha = 'left')
ax0.set_xlim(min(Qe), -1)
ax0.set_ylim(-0.045, 0.045)
ax0.set_xlabel('DFT potential energy (eV/atom)')
ax0.set_ylabel('Rsidual error (eV/atom)')
ax0.legend(loc = 'best', handles =hdl, fontsize = 8, frameon = False)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(Ne-Qe, 50,
                            range = (-0.01, 0.01),
                            weights = np.ones_like(Ne-Qe)/ len(Ne),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.05, 0.142, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.05, 0.122, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.06, 0.06)
ax1.set_xlim(0, 0.3)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
plt.tight_layout(w_pad = -0.5)
#plt.savefig('./images/fig-neural-train.png')
plt.show()

#+END_SRC

#+RESULTS:

* Application
** MD
*** Trajectory
**** NEB
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

for cell in ['222', '223', '233', '333']:
    
    for img in [1, 2, 3, 4]:
        
        label = '{0}-{1}'.format(cell, img)
        
        wd = os.path.join(home, './database/db2/' + label)

        if not os.path.exists(wd):
            os.makedirs(wd)

        os.chdir(wd)


        run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from vasp import Vasp

calc = Vasp("./../../../NDFT/bulk=fcc/type=neb/supercell=222/neb")
images, energies = calc.get_neb()


atoms = images[1]

atoms.set_calculator(Amp(load="./../2-30-0/-parameters-checkpoint-1.json"))
        
dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

        cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

        with open('submit.py', 'w') as f:
            f.write(run_md)
        os.chmod('submit.py', 0777)

        with open('submit.sh', 'w') as f:
            f.write(cmd)

        subprocess.call(['qsub', 'submit.sh'])
        time.sleep(5)
        os.unlink('submit.sh')
        os.chdir(wd)
#+END_SRC

#+BEGIN_SRC python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from vasp import Vasp

import os
import subprocess
import time

home = os.getcwd()

for cell in ['222', '223', '233', '333']:
    
    for img in [1, 2, 3, 4]:
        
        label = '{0}-{1}'.format(cell, img)
        
        wd = os.path.join(home, './database/db2/' + label)

        if not os.path.exists(wd):
            os.makedirs(wd)

        os.chdir(wd)


        calc = Vasp("./../../../NDFT/bulk=fcc/type=neb/supercell=222/neb")
        images, energies = calc.get_neb()


        atoms = images[1]

        atoms.set_calculator(Amp(load="./../2-30-0/-parameters-checkpoint-1.json"))
        
        dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


        def printenergy(a=atoms):
            epot = a.get_potential_energy() / len(a)
            ekin = a.get_kinetic_energy() / len(a)
    
        dyn.attach(printenergy, interval=10)

        traj = Trajectory("./MD.traj", "w", atoms)
        dyn.attach(traj.write, interval=10)

        dyn.run(2000)

#+END_SRC

**** Surface
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

label = '225-surface'
wd = os.path.join(home, './database/db2/' + label)

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(2, 2, 5), a=3.939, vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(Amp(load="./../2-30-0/-parameters-checkpoint-1.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD-fixed.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1451040.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

label = '335-surface'
wd = os.path.join(home, './database/db2/' + label)

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(3, 3, 5), a=3.939, vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(Amp(load="./../2-30-0/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD-fixed.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=48:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1451727.gilgamesh.cheme.cmu.edu


#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db2/2-20-0/-parameters-checkpoint-0.json')
images = Trajectory('./database/db2/225-surface/MD.traj', 'r')
Ed = []
En = [images[i].get_potential_energy() for i in range(200)]
for i in range(200):
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md0/v_a=0_20/MD={}'.format(i))
    Ed += [calc.potential_energy]

plt.plot(range(len(En)), En, 'b-', label='NN prediction')
plt.scatter(range(len(Ed)), Ed, facecolor='none',
	   edgecolor='r', label='DFT calculation')

plt.xlim([0, 200])
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('222surface-md.png')
plt.show()
#+END_SRC

[[./figures/222surface-md.png]]

*** NN Predict
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp

calc1 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db3/25-25/checkpoint-parameters.json')
traj = Trajectory('./database/db3/MD-225.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/MD225-3.png')
#+END_SRC

#+RESULTS:

[[./figures/MD225-3.png]]

#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
images, energies = calc.get_neb()

En, E = [], []
calc2 = Amp('./networks/db3/24-24/checkpoint-parameters.json')

for atoms in images:
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

En = np.array(En)
E = En-En[0]
x = range(len(images))
xarray = np.linspace(0, len(images))
f1 = interp1d(x, energies, kind='cubic', bounds_error=False)
f2 = interp1d(x, E, kind='cubic', bounds_error=False)
plt.plot(x, energies, 'bo', label = 'NEB')
plt.plot(x, E, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
#plt.show()
plt.savefig('./figures/NN-NEB-4.png')
#+END_SRC
#+RESULTS:

[[./figures/NN-NEB-4.png]]
** NEB-NN
#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb')
images, energies = calc.get_neb()

En, E = [], []
calc2 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')

for atoms in images:
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

En = np.array(En)
E = En-En[0]
x = range(len(images))
xarray = np.linspace(0, len(images))
f1 = interp1d(x, energies, kind='cubic', bounds_error=False)
f2 = interp1d(x, E, kind='cubic', bounds_error=False)
plt.plot(x, energies, 'bo', label = 'NEB')
plt.plot(x, E, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
plt.show()
#+END_SRC
#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
from amp import Amp

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
images, energies = calc.get_neb()

calc0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb-initial')
E0 = calc0.potential_energy

energies = np.array(energies)
energies += E0

print energies


En, E = [], []
calc2 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')

for atoms in images:
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

print En
#+END_SRC

#+RESULTS:
: [-35.43371164 -35.42570645 -35.19608912 -34.88827938 -34.75807484
:  -34.88827927 -35.19608898 -35.42570641 -35.43371169]
: [-35.322470231901875, -35.31849228646374, -35.156207100533905, -34.85637361556328, -34.68250391909649, -34.85637347354207, -35.15620697841968, -35.31849225982069, -35.32247023190192]

** Bulk Properties
*** Cohesive energy
Atomic energy
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase import Atoms, Atom
from ase.visualize import view
VASPRC['queue.walltime'] = '24:00:00'

atoms = Atoms([Atom('Pd', [5, 5, 5])],
              cell = (7, 8, 9))

calc = Vasp('NDFT/atomic-Pd',
          xc = 'pbe',
          encut = 350,
          kpts = [1]*3,
          atoms = atoms) 

calc.calculate()

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/atomic-Pd submitted: 1442984.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
from vasp import Vasp
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')

calc = Vasp ('./NDFT/atomic-Pd') 
Eatom = calc.potential_energy
 
calc = Vasp ('./NDFT/bulk=fcc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEfcc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEfcc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=bcc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEbcc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEbcc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=hcp/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEhcp = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEhcp = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=sc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEsc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEsc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=diam/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEdiam = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEdiam = atoms.get_potential_energy()/len(atoms)
print DEfcc-Eatom, NEfcc-Eatom
print DEbcc-Eatom, NEbcc-Eatom
print DEhcp-Eatom, NEhcp-Eatom
print DEsc-Eatom, NEsc-Eatom
print DEdiam-Eatom, NEdiam-Eatom
#+END_SRC

#+RESULTS:
: -3.75476834 -3.75589508423
: -3.71312559 -3.73790838482
: -3.72459561 -3.76095602827
: -3.2532599 -3.26704062214
: -2.6162620675 -2.61824650251

*** Bulk Modulus
#+BEGIN_SRC python
from ase.db import connect
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState
from ase.units import kJ
import numpy as np
from vasp import Vasp
from amp import Amp

factor = np.arange(0.85, 1.2, 0.01)
calc2 = Amp(load = './database/db1/2-24-2/-parameters-checkpoint-0.json')
             #      np.arange(1.2, 2.125, 0.05))
configs = ['fcc', 'bcc', 'hcp', 'sc', 'diam']

for config in configs:
    nrg, vol = [], []
    nn = []
    for f in factor:
        calc = Vasp('./NDFT/bulk={0}/type=eos/factor={1:.2f}'.format(config,f))
        atoms = calc.get_atoms()
        nrg += [atoms.get_potential_energy()/len(atoms)]
        vol += [atoms.get_volume()/len(atoms)]
        atoms.set_calculator(calc2)
        nn +=[atoms.get_potential_energy()/len(atoms)]
        

    vol = np.array(vol)
    nrg = np.array(nrg)
    nn = np.array(nn)
# Fit the data to SJEOS
    eos = EquationOfState(vol, nrg)
    v0, e0, B0 = eos.fit()
    eos = EquationOfState(vol, nn)
    v1, e1, B1 = eos.fit()
    print '{0}'.format(config)
    print v0, e0, B0
    print v1, e1, B1
#+END_SRC

#+RESULTS:
#+begin_example
fcc
15.2979724806 -5.22438476072 1.09507457295
15.3564270183 -5.21520156705 1.07945263208
bcc
15.4257962561 -5.18249419589 1.06469804063
15.3991596967 -5.19211684448 1.08071951009
hcp
15.3645769219 -5.19379582623 1.08254355793
15.3341063992 -5.21621811798 1.09987534388
sc
17.8024966568 -4.72110919112 0.782438954048
17.8334288446 -4.71777979115 0.775358668286
diam
24.3558101786 -4.08130798908 0.428150007251
24.346708419 -4.08117208591 0.428715107213
#+end_example

*** Elastic Constant
**** 11, 12
#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.01, 11)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=11/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')
    #calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
#+END_SRC

#+RESULTS:
: [ 2.22936683 -0.34128023]
: [ 2.58330265 -0.34127457]

#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.01, 11)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=11/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')
    #calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')

    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
plt.plot(factor, Ed/Vd[0], 'bo', label = 'DFT')
plt.plot(factor, En/Vd[0], 'ro', label = 'NN')
plt.plot(factor, func(factor, *poptd), 'b-', label = 'DFT fit')
plt.plot(factor, func(factor, *poptn), 'r-', label = 'NN fit')

plt.xlabel('Strain')
plt.ylabel('Energy Density [eV/$\AA^3$]')
plt.legend(loc='best')
#plt.savefig('./figures/elastic-1.png')
plt.show()
#+END_SRC

#+RESULTS:
: [ 2.22936683 -0.34128023]
: [ 2.87528197 -0.34126408]

**** 44
#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.01, 11)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=44/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

  #  calc2 = Amp(load='./networks/db3/2-25/checkpoint-parameters.json')
    calc2 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')
    #calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
#+END_SRC

#+RESULTS:
: [ 0.73280411 -0.34127966]
: [ 0.71863853 -0.34126554]

**** calculation
#+BEGIN_SRC python
'''
B = 1.09507457295
a = 2.21553499/6
b = 0.66616554
'''

B = 1.0950
a = 3.0178/6
b = 0.8153
C4 = b/2
C2 = (3*B - 2*a)/3
C1 = 2*a + C2

print C1, C2, C4
print C1 * 160.2177
print C2 * 160.2177
print C4 * 160.2177
#+END_SRC

#+RESULTS:
: 1.76562222222 0.759688888889 0.40765
: 282.883931513
: 121.715606493
: 65.312745405

**** reference 
#+BEGIN_SRC python
from vasp import Vasp
calc = Vasp('~/Research/Bulk/DFT/bulk=fcc/type=elastic/elastic')

EM = calc.get_elastic_moduli()

print EM
#+END_SRC

#+RESULTS:
: [[ 206.71093  155.54113  155.54113    0.         0.         0.     ]
:  [ 155.54113  206.71093  155.54113    0.         0.         0.     ]
:  [ 155.54113  155.54113  206.71093    0.         0.         0.     ]
:  [   0.         0.         0.        59.78395    0.         0.     ]
:  [   0.         0.         0.         0.        59.78395    0.     ]
:  [   0.         0.         0.         0.         0.        59.78395]]

** Vacancy formation
*** 222
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=222/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*7
print Ev
#+END_SRC

#+RESULTS:
: 1.06765175


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 2, 2)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (7/8.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  10:04:17      -35.323077       0.0000
: Vacancy formation energy with NN is: 1.158 eV
: -41.6921809084
: -35.3230768877

*** 223
     
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=223/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*11
print Ev
#+END_SRC

#+RESULTS:
: 1.13510973


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 2, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (11/12.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  10:08:55      -56.116879       0.7401
: BFGS:   1  10:09:01      -56.136758       0.6208
: BFGS:   2  10:09:07      -56.172858       0.1487
: BFGS:   3  10:09:13      -56.173163       0.1054
: BFGS:   4  10:09:19      -56.173243       0.0910
: BFGS:   5  10:09:24      -56.173405       0.0330
: Vacancy formation energy with NN is: 1.153 eV
: -62.5382713626
: -56.1734049327

*** 233
     
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=233/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*17
print Ev
#+END_SRC

#+RESULTS:
: 1.15516594


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 3, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (17/18.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  10:11:55      -87.352273       0.6760
: BFGS:   1  10:12:09      -87.382656       0.5809
: BFGS:   2  10:12:22      -87.449470       0.1658
: BFGS:   3  10:12:36      -87.449810       0.0709
: BFGS:   4  10:12:49      -87.449782       0.0621
: BFGS:   5  10:13:03      -87.448243       0.0260
: Vacancy formation energy with NN is: 1.148 eV
: -93.8074070438
: -87.4482427447

*** 333
     
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=333/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*26
print E1
print E0*27
print Ev
#+END_SRC

#+RESULTS:
: -134.47545389
: -140.79068946
: 1.10076559


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (3, 3, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (26/27.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  10:15:55     -134.259635       0.5909
: BFGS:   1  10:16:25     -134.295713       0.5128
: BFGS:   2  10:16:59     -134.376645       0.1256
: BFGS:   3  10:17:33     -134.373331       0.0840
: BFGS:   4  10:18:09     -134.373707       0.0736
: BFGS:   5  10:18:45     -134.374974       0.0360
: Vacancy formation energy with NN is: 1.125 eV
: -140.711110566
: -134.374974352

*** 334
     
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=334/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*35

print Ev
#+END_SRC

#+RESULTS:
: 1.07033284


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (3, 3, 4)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (35/36.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  10:40:34     -181.168995       0.4837
BFGS:   1  10:41:20     -181.198978       0.4371
BFGS:   2  10:42:06     -181.292172       0.1463
BFGS:   3  10:42:52     -181.297291       0.0998
BFGS:   4  10:43:38     -181.300006       0.0885
BFGS:   5  10:44:23     -181.306581       0.0545
BFGS:   6  10:45:09     -181.307656       0.0681
BFGS:   7  10:45:55     -181.306891       0.0800
BFGS:   8  10:46:41     -181.304284       0.0811
BFGS:   9  10:47:27     -181.299184       0.0682
BFGS:  10  10:48:13     -181.294990       0.0504
BFGS:  11  10:48:59     -181.293067       0.0459
Vacancy formation energy with NN is: 1.110 eV
-187.614814088
-181.29306683
#+end_example

*** 344
     
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=344/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*47
print Ev

#+END_SRC

#+RESULTS:
: 1.0137827


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (3, 4, 4)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (47/48.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  11:51:49     -243.709851       0.3831
BFGS:   1  11:53:00     -243.735689       0.3473
BFGS:   2  11:54:11     -243.847779       0.1092
BFGS:   3  11:55:22     -243.855635       0.1107
BFGS:   4  11:56:33     -243.868125       0.0804
BFGS:   5  11:57:45     -243.871778       0.0628
BFGS:   6  11:58:56     -243.871070       0.0440
Vacancy formation energy with NN is: 1.070 eV
-250.152955507
-243.871069593
#+end_example

*** 444
     
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=444/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*63
print Ev
#+END_SRC

#+RESULTS:
: 0.96277588


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (4, 4, 4)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (63/64.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  10:22:58     -327.095298       0.2871
: BFGS:   1  10:24:48     -327.119921       0.2601
: BFGS:   2  10:26:53     -327.231549       0.1002
: BFGS:   3  10:28:55     -327.238182       0.0787
: BFGS:   4  10:31:00     -327.259021       0.0256
: Vacancy formation energy with NN is: 1.067 eV
: -333.537447267
: -327.259021011

| Supercell | E_DFT(eV) | E_NN(eV) | Error(eV) | Error(%) |
|       222 |     1.068 |    1.158 |     0.090 |     8.42 |
|       223 |     1.135 |    1.153 |     0.018 |     1.59 |
|       233 |     1.155 |    1.148 |     0.007 |     0.61 |
|       333 |     1.101 |    1.125 |     0.024 |     2.17 |
|       334 |     1.070 |    1.110 |     0.040 |     3.73 |
|       344 |     1.014 |    1.070 |     0.056 |     5.52 |
|       444 |     0.963 |    1.067 |     0.104 |    10.80 |

** EOS
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState
from ase.db import connect
from amp import Amp
from ase.visualize import view
import os
import json
import time
from ase.units import kJ

db = connect('./database/db2/data.db')

f, ax = plt.subplots(1, 5, figsize = (12, 5))
tag = ['FCC', 'BCC', 'HCP', 'SC', 'Diamond']

for i, key in enumerate(['fcc', 'bcc', 'hcp', 'sc', 'diam']):

    V, Qe, Re, Ne = [], [], [], []

    for d in db.select(['bulk={0}'.format(key), 'type=eos']):
        V += [d.volume / d.natoms]
        Qe += [d.energy / d.natoms]
        Ne += [d.NN30 / d.natoms]

    srt = [j[0] for j in sorted(enumerate(V), key = lambda x:x[1])]
    V = np.array(V)[srt]
    Qe = np.array(Qe)[srt]
    Ne = np.array(Ne)[srt]

    ax[i].plot(V, Qe, 'k-', lw=2, label = 'DFT')
    ax[i].plot(V, Ne, 'r--', lw=2, label = 'Neural')

    if i >0:
        ax[i].set_yticklabels([])

    ax[i].set_ylim(-6 , 0)
    ax[i].set_xlim(0, 150)
    ax[i].set_xticks([0, 40, 80, 120])
    ax[i].set_title('{0}'.format(tag[i]))

ax[0].set_ylabel('Potantial energy (eV/atom)')
ax[2].set_xlabel('Volume ($\AA$/atom)')
ax[4].legend(loc = 'best', fontsize = 12)
plt.tight_layout(w_pad=-1.3)
plt.savefig('./figures/eos-NN-2.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/eos-NN-2.png]]

#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt


E1, E2 = [], []

factor = np.linspace(0.85, 2.5, 1000)
for x in factor :

    atoms = FaceCenteredCubic('Pd',
                              directions=[[0, 1, 1],
                                          [1, 0, 1],
                                          [1, 1, 0]],
                              latticeconstant=3.933)
    
    delta = np.array([[x, 0., 0.],
                      [0., x, 0.],
                      [0., 0., x]])
    atoms.set_cell(np.dot(atoms.get_cell(), delta),
                   scale_atoms=True)
    calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
    calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
    
    atoms.set_calculator(calc1)
    E1 += [atoms.get_potential_energy()]

    atoms.set_calculator(calc2)
    E2 += [atoms.get_potential_energy()]

E1 = np.array(E1)
E2 = np.array(E2)
res = abs(E1 - E2)
#print E1


f, ax = plt.subplots(2, 1, sharex=True)
ax[0].plot(factor, E1, 'b', lw=2, label='2-24')
ax[0].plot(factor, E2, 'r', lw=2, label='2-30')
ax[0].plot([0.85, 0.85], [2, -6], 'k--')
ax[0].plot([2.1, 2.1], [2, -6], 'k--')
ax[0].set_ylabel('Potential energy (eV)')
ax[0].set_xlim(0.6, 2.5)
ax[0].set_ylim(-6, 2)
ax[0].legend(loc='best')
ax[1].plot(factor, res)
ax[1].plot([0.85, 0.85], [0, 0.5], 'k--')
ax[1].plot([2.07, 2.1], [0, 0.5], 'k--')
ax[1].set_ylabel('NN energy difference (eV)')
ax[1].set_ylim(0, 0.5)
ax[1].set_xlabel('Strain/stretch factor (%)')
plt.tight_layout(w_pad=0.0)
plt.savefig('./figures/app-eos.png')
#+END_SRC

#+RESULTS:

[[./figures/app-eos.png]]


* 5th DFT
** Surface MD
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
from vasp import Vasp
from vasp.vasprc import VASPRC

VASPRC['queue.walltime'] = '24:00:00'

calc1 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db3/25-25/checkpoint-parameters.json')
images = Trajectory('./database/db3/MD-225.traj', 'r')
E1, E2 = [], []

for atoms in images:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in images:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)

#+END_SRC

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
from vasp import Vasp
from vasp.vasprc import VASPRC

VASPRC['queue.walltime'] = '24:00:00'

calc1 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db3/25-25/checkpoint-parameters.json')
images = Trajectory('./database/db3/MD-225.traj', 'r')
E1, E2 = [], []

for atoms in images:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in images:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)


nrg, res, s = [], [], []
calcs = []
A = [0, 2, 4, 5, 6, 7, 10, 11, 12, 13, 16, 17, 18, 19, 21, 24, 25, 26, 27, 28, 29, 30, 32, 33, 37, 38, 40, 41, 43, 44, 45, 46, 50, 52, 54, 55, 60, 61, 63, 64, 65, 66, 73, 74, 75, 76, 82, 87, 92, 93, 102, 103, 104, 107, 108, 113, 114, 119, 121, 123, 124, 128, 129, 133, 138, 139, 142, 145, 146, 147, 148, 149, 150, 154, 155, 158, 159, 160, 167, 170, 179, 180, 184, 189, 191, 193, 194, 195, 197, 198]

for i in A:        
        
        calc = Vasp('NDFT/surface=fcc111/type=md/order=md1/v_a=0_20/MD={}'.format(i))

        nrg += [calc.potential_energy/20]


plt.plot(range(len(E1)), E1, 'b-', label='NN1 prediction')
plt.plot(range(len(E2)), E2, 'r--', label='NN2 prediction')
plt.scatter(A, nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(E1)))
plt.ylabel('Potential energy (eV)')

plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/225MD-3.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/225MD-3.png]]
#+RESULTS:

: [0, 2, 4, 5, 6, 7, 10, 11, 12, 13, 15, 16, 17, 18, 19, 21, 24, 25, 26, 27, 28, 29, 30, 32, 33, 37, 38, 40, 41, 43, 44, 45, 46, 50, 52, 54, 55, 60, 61, 63, 64, 65, 66, 73, 74, 75, 76, 82, 87, 92, 93, 102, 103, 104, 107, 108, 113, 114, 119, 121, 123, 124, 128, 129, 133, 136, 138, 139, 140, 142, 145, 146, 147, 148, 149, 150, 154, 155, 158, 159, 160, 167, 170, 179, 180, 184, 189, 191, 193, 194, 195, 197, 198]


 136 140
#+BEGIN_SRC python
from vasp import Vasp
t = [0, 2, 4, 5, 6, 7, 10, 11, 12, 13, 16, 17, 18, 19, 21, 24, 25, 26, 27, 28, 29, 30, 32, 33, 37, 38, 40, 41, 43, 44, 45, 46, 50, 52, 54, 55, 60, 61, 63, 64, 65, 66, 73, 74, 75, 76, 82, 87, 92, 93, 102, 103, 104, 107, 108, 113, 114, 119, 121, 123, 124, 128, 129 133,  138, 139, 142, 145, 146, 147, 148, 149, 150, 154, 155, 158, 159, 160, 167, 170, 179, 180, 184, 189, 191, 193, 194, 195, 197, 198]

nrg = []
for i in t:        
        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md1/v_a=0_20/MD={}'.format(i))
    nrg +=[calc.potential_energy]
    print t
#+END_SRC

#+BEGIN_SRC python
from vasp import Vasp
import os
t = [136]

nrg = []
for i in t:        
        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md1/v_a=0_20/MD={}'.format(i))

    cwd = os.getcwd()
    print 
tianyug1/Research/Bulk/NDFT/surface=fcc111/type=md/order=md1/v_a=0_20/MD=136
#+END_SRC

#+RESULTS:

#+END_SRC
** Surface vacancy
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc111
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

a0 = 3.939
nrg = []

atoms = fcc111('Pd', size=(4, 4, 5), a = a0,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
del atoms[-1]


calc = Vasp('NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=44',
            xc='pbe',
            kpts=[3, 3, 1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=atoms)

calc.set_memory()
nrg += [calc.potential_energy]
#+END_SRC

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc111
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np
from vasp.vasprc import VASPRC

VASPRC['queue.walltime']='24:00:00'
VASPRC['queue.ppn'] = 4
a0 = 3.939
nrg = []

atoms = fcc111('Pd', size=(3, 3, 5), a = a0,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
del atoms[-1]


calc = Vasp('NDFT/surface=fcc111/type=test/vrelax=False/supercell=33',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=atoms)

calc.set_memory()
nrg += [calc.potential_energy]
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=test/vrelax=False/supercell=33 submitted: 1453764.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=test/vrelax=False/supercell=33 Queued: 1453764.gilgamesh.cheme.cmu.edu
*** Surface vacancy diffusion neb
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111
from ase.constraints import FixAtoms

#VASPRC['queue.mem'] = '8GB'
VASPRC['queue.walltime'] = '24:00:00'

a0 = 3.939
atoms = fcc111('Pd', size=(2, 2, 5), a = a0,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)

ini = atoms.copy()
del ini[-1]
# Get unrelaxed initial and final states for speed.

c0 = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/neb-initial',
          xc='pbe',
          kpts=[9, 9, 1],
          encut=350,
          ibrion=2,
          isif=2,
          nsw=25,
          atoms=ini)

fin = atoms.copy()
del fin[-2]

cend = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/neb-end',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=fin)

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

ini = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/neb-initial').get_atoms()
fin = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/neb-end').get_atoms()
images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/neb',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/surf-vac-NEB.png')
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.502667
:          Iterations: 15
:          Function evaluations: 30

[[./figures/surf-vac-NEB.png]]
** Surface adatom
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

calc = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00')
atoms = calc.get_atoms()

add_adsorbate(atoms, 'Pd', height=2.0, position='fcc')
constraint = FixAtoms(mask=[atom.tag >0  for atom in atoms])
atoms.set_constraint(constraint)

calc = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site=fcc',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=atoms)

calc.set_memory()
nrg += [calc.potential_energy]

#+END_SRC


#+RESULTS:

#+BEGIN_SRC python
from ase.lattice.surface import fcc111, add_adsorbate
from ase.visualize import view
from ase.constraints  import FixAtoms

atoms = fcc111('Pd', size=(2, 2, 3), vacuum=10.0)
add_adsorbate(atoms, 'Pd', height=2.0, position='fcc')
constraint = FixAtoms(mask=[atom.tag >0  for atom in atoms])
atoms.set_constraint(constraint)
view(atoms)
#+END_SRC

#+RESULTS:

*** fcc
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

VASPRC['queue.walltime']='24:00:00'
VASPRC['queue.ppn']=2
atoms = fcc111('Pd', size=(2, 2, 5), a = 3.939, vacuum = 6.0)
add_adsorbate(atoms, 'Pd', height=2.0, position='fcc')
constraint = FixAtoms(mask=[atom.tag >3  for atom in atoms])
atoms.set_constraint(constraint)

calc = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site=fcc',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=atoms)

calc.set_memory()
nrg = calc.potential_energy

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=adatom/supercell=22/site=fcc submitted: 1459439.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=adatom/supercell=22/site=fcc Queued: 1459439.gilgamesh.cheme.cmu.edu

*** hcp
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

VASPRC['queue.walltime']='24:00:00'
VASPRC['queue.ppn'] = 2

atoms = fcc111('Pd', size=(2, 2, 5), a = 3.939,  vacuum = 6.0)
add_adsorbate(atoms, 'Pd', height=2.0, position='hcp')
constraint = FixAtoms(mask=[atom.tag >3  for atom in atoms])
atoms.set_constraint(constraint)

calc = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site=hcp',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=atoms)

calc.set_memory()
nrg = calc.potential_energy

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=adatom/supercell=22/site=hcp submitted: 1459440.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=adatom/supercell=22/site=hcp Queued: 1459440.gilgamesh.cheme.cmu.edu

*** bridge
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms, FixScaled
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

VASPRC['queue.walltime']='24:00:00'
VASPRC['queue.ppn'] = 2

atoms = fcc111('Pd', size=(2, 2, 5), a= 3.939, vacuum = 6.0)
add_adsorbate(atoms, 'Pd', height=2.0, position='bridge')
constraint1 = FixAtoms(mask=[atom.tag >3  for atom in atoms])


constraint2 = FixScaled(atoms.get_cell(), 20, [True, True, False])
atoms.set_constraint([constraint1, constraint2])


calc = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site=bridge',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=atoms)

calc.set_memory()
nrg = calc.potential_energy

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=adatom/supercell=22/site=bridge submitted: 1459437.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=adatom/supercell=22/site=bridge Queued: 1459437.gilgamesh.cheme.cmu.edu

*** top
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms, FixScaled
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

VASPRC['queue.walltime']='24:00:00'
VASPRC['queue.ppn'] = 2

atoms = fcc111('Pd', size=(2, 2, 5), a=3.939, vacuum = 6.0)
add_adsorbate(atoms, 'Pd', height=2.0, position='ontop')
constraint1 = FixAtoms(mask=[atom.tag >3  for atom in atoms])


constraint2 = FixScaled(atoms.get_cell(), 20, [True, True, False])
atoms.set_constraint([constraint1, constraint2])


calc = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site=top',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=atoms)

calc.set_memory()
nrg = calc.potential_energy

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=adatom/supercell=22/site=top submitted: 1459438.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=adatom/supercell=22/site=top Queued: 1459438.gilgamesh.cheme.cmu.edu

*** surface adatom diffusion neb
**** top-fcc
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111
from ase.constraints import FixAtoms

VASPRC['queue.mem'] = '8GB'

ini = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site=top').get_atoms()
fin = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site=fcc').get_atoms()
images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc111/type=neb/class=top_fcc/neb',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/top-fcc.png')
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: 0.004509
:          Iterations: 13
:          Function evaluations: 26

[[./figures/top-fcc.png]]
**** fcc-hcp
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111
from ase.constraints import FixAtoms

VASPRC['queue.mem'] = '8GB'

ini = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site=fcc').get_atoms()
fin = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site=hcp').get_atoms()
images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc111/type=neb/class=fcc_hcp/neb',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/fcc-hcp.png')
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.102846
:          Iterations: 14
:          Function evaluations: 28

[[./figures/fcc-hcp.png]]
**** hcp-top
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111
from ase.constraints import FixAtoms

VASPRC['queue.mem'] = '8GB'

ini = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site=hcp').get_atoms()
fin = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site=top').get_atoms()
images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc111/type=neb/class=hcp_top/neb',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/hcp-top.png')
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.659015
:          Iterations: 19
:          Function evaluations: 38

[[./figures/hcp-top.png]]

**** hcp-top-2
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111
from ase.constraints import FixAtoms

#VASPRC['queue.mem'] = '8GB'
VASPRC['queue.walltime'] = '24:00:00'
VASPRC['ppn'] = 4
ini = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site=hcp').get_atoms()

atoms = fcc111('Pd', size=(2, 2, 5), vacuum = 6.0)
add_adsorbate(atoms, 'Pd', height=2.0, position='ontop')
constraint1 = FixAtoms(mask=[atom.tag >3  for atom in atoms])


constraint2 = FixScaled(atoms.get_cell(), 20, [True, True, False])
atoms.set_constraint([constraint1, constraint2])


calc = Vasp('NDFT/surface=fcc111/type=neb/class=hcp_top/neb-end',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=atoms)

calc.set_memory()
nrg = calc.potential_energy
'''
fin = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site=top').get_atoms()
images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc111/type=neb/class=hcp_top/neb',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/hcp-top.png')
'''
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.659015
:          Iterations: 19
:          Function evaluations: 38

[[./figures/hcp-top.png]]

*** fixed all neb
**** position
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms
from ase import Atoms, Atom

#VASPRC['queue.mem'] = '8GB'
VASPRC['queue.walltime'] = '24:00:00'

calc = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00')
slab = calc.get_atoms()

#slab = fcc111('Pd', size=(2, 2, 5), a = 3.939,  vacuum=6.0)
#end = slab.copy()
p = slab.positions

pfcc = (p[16] + p[17] + p[18])/3.0 + [0, 0, 2]
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(pfcc)

fcc = slab + add
constraint = FixAtoms(mask=[atom.tag > 0  for atom in fcc])
fcc.set_constraint(constraint)
#print fcc.get_tags()
#view(fcc)

calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=fcc',
            xc = 'pbe',
            kpts=[9,9,1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=fcc)
calc.get_memory()
calc.calculate()

#+END_SRC

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms, FixScaled
from ase import Atoms, Atom

#VASPRC['queue.mem'] = '8GB'
VASPRC['queue.walltime'] = '24:00:00'

calc = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00')
slab = calc.get_atoms()

#slab = fcc111('Pd', size=(2, 2, 5), a = 3.939,  vacuum=6.0)
#end = slab.copy()
p = slab.positions

pbridge = (p[17] + p[18])/2.0 + [0, 0, 2.4]
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(pbridge)


bridge = slab + add
constraint1 = FixAtoms(mask=[atom.tag > 0  for atom in bridge])
constraint2 = FixScaled(bridge.get_cell(), 20, [True, True, False])
bridge.set_constraint([constraint1, constraint2])
#print fcc.get_tags()
#view(bridge)

calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=bridge',
            xc = 'pbe',
            kpts=[9,9,1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=bridge)
calc.get_memory()
calc.calculate()

#+END_SRC

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms
from ase import Atoms, Atom

#VASPRC['queue.mem'] = '8GB'
VASPRC['queue.walltime'] = '24:00:00'

calc = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00')
slab = calc.get_atoms()

#slab = fcc111('Pd', size=(2, 2, 5), a = 3.939,  vacuum=6.0)
#end = slab.copy()
p = slab.positions

ptop = (p[17]  + [0, 0, 2.4])
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(ptop)

top = slab + add
constraint = FixAtoms(mask=[atom.tag > 0  for atom in top])
top.set_constraint(constraint)
#print fcc.get_tags()
#view(top)

calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=top',
            xc = 'pbe',
            kpts=[9,9,1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=top)
calc.get_memory()
calc.calculate()

#+END_SRC


#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms
from ase import Atoms, Atom

#VASPRC['queue.mem'] = '8GB'
VASPRC['queue.walltime'] = '24:00:00'

calc = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00')
slab = calc.get_atoms()

#slab = fcc111('Pd', size=(2, 2, 5), a = 3.939,  vacuum=6.0)
#end = slab.copy()
p = slab.positions

phcp = ((p[17]+p[18]+p[19])/3  + [0, 0, 2])
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(phcp)

hcp = slab + add
constraint = FixAtoms(mask=[atom.tag > 0  for atom in hcp])
hcp.set_constraint(constraint)
#print fcc.get_tags()
#view(hcp)

calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=hcp',
            xc = 'pbe',
            kpts=[9,9,1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=hcp)
calc.get_memory()
calc.calculate()

#+END_SRC

**** top-fcc
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms
from ase import Atoms, Atom

#VASPRC['queue.mem'] = '8GB'
#VASPRC['queue.walltime'] = '24:00:00'


fin = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=fcc').get_atoms()
ini = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=top').get_atoms()
images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/class=top_fcc/neb',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/top-fcc-fixed.png')g

#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: 0.000001
:          Iterations: 32
:          Function evaluations: 64

[[./figures/top-fcc-fixed.png]]

**** fcc-hcp

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms
from ase import Atoms, Atom

#VASPRC['queue.mem'] = '8GB'
#VASPRC['queue.walltime'] = '24:00:00'


ini = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=fcc').get_atoms()
fin = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=hcp').get_atoms()
images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/class=fcc_hcp/neb',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/fcc-hcp-fixed.png')

#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.167086
:          Iterations: 15
:          Function evaluations: 30

[[./figures/fcc-hcp-fixed.png]]
**** hcp-top
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms
from ase import Atoms, Atom

#VASPRC['queue.mem'] = '8GB'
#VASPRC['queue.walltime'] = '24:00:00'


ini= Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=hcp').get_atoms()
fin = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=top').get_atoms()
images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/class=hcp_top/neb',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/hcp-top-fixed.png')
#+END_SRC

#+RESULTS:

[[./figures/hcp-top-fixed.png]]

* DB
#+BEGIN_SRC python
from vasp import Vasp
A = [0, 2, 4, 5, 6, 7, 10, 11, 12, 13, 16, 17, 18, 19, 21, 24, 25, 26, 27, 28, 29, 30, 32, 33, 37, 38, 40, 41, 43, 44, 45, 46, 50, 52, 54, 55, 60, 61, 63, 64, 65, 66, 73, 74, 75, 76, 82, 87, 92, 93, 102, 103, 104, 107, 108, 113, 114, 119, 121, 123, 124, 128, 129, 133, 138, 139, 142, 145, 146, 147, 148, 149, 150, 154, 155, 158, 159, 160, 167, 170, 179, 180, 184, 189, 191, 193, 194, 195, 197, 198]
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md1/v_a=0_20/MD={}'.format(i))
    calc.write_db('./database/db4/data.db', parser='=', overwrite=False, keys={'dbkey':4}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calc = Vasp('NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=22')
calc.write_db('./database/db4/data.db', parser='=', overwrite=False, keys={'dbkey':4}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp

pos = ['fcc', 'hcp', 'bridge', 'top']
for cong in pos:
    calc = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site={}'.format(cong))
    calc.write_db('./database/db4/data.db', parser='=', overwrite=False, keys={'dbkey':4}) 

#+END_SRC

#+RESULTS:

** keywords
#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

from ase.db import connect

db = connect('./database/db4/data.db')
data = db.select(['train_set=False'])

keys, cnt = {}, 0
for entry in data:
    cnt += 1
    for k, v in entry.key_value_pairs.iteritems():
        
        if k in keys:
            keys[k] += [v]
        else:
            keys[k] = [v]

print ('{0:15s} {1:15s} {2} calculations total'.format('keyword', 'value',cnt))

print('------------------------------------------------------')

for k, v in keys.iteritems():
    vals = list(set(v))
    if len(vals) <= 5:
        val = ", ".join(str(e) for e in vals)
        print('{0:15}: {1}'.format(k, val))

    else:
        val = ", ".join(str(e)[:5] for e in vals[:5])
        print('{0:15s}:{1}, etc...'.format(k, val))
#+END_SRC
#+RESULTS:
#+begin_example
keyword         value           183 calculations total
------------------------------------------------------
dirs           : 11, 44
MD             :1, 2, 3, 4, 5, etc...
train_set      : False
NN24           :-5.14, -234., -1.51, -243., -40.9, etc...
NN25           :-40.1, -84.0, -34.6, -4.50, -34.1, etc...
dbkey          : 0, 1, 2, 3, 4
image          :1, 2, 3, 5, 7, etc...
bulk           : sc, hcp, fcc, diam, bcc
lattice        : primitive
supercell      : 344, 233, 333, 223
v_a            :1_26, 1_47, 1_63, 0_20, 1_11, etc...
vrelax         : False
factor         :1.3, 1.0, 2.0, 1.45, 0.94, etc...
type           : vacancy, md, neb, eos, elastic
order          : md2, md0, md1
surface        : fcc111
#+end_example

* Training
** Training Set
#+BEGIN_SRC python
from ase.db import connect
import os
import random
import numpy as np

db = connect('./database/db4/data.db')

n = db.count()
n_train = int(round(n * 0.9))

n_ids =  np.array(range(n)) + 1

# This will sudo-randomly select 10% of the calculations
# Which is useful for reproducing our results.
random.seed(256)
train_samples = random.sample(n_ids, n_train)
valid_samples = set(n_ids) - set(train_samples)

db.update(list(train_samples), train_set=True)
db.update(list(valid_samples), train_set=False)

#+END_SRC

#+RESULTS:

** Training
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

for n in [10, 15, 18, 20, 24]:

    wd = 'networks/db4/{0}-{0}/'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)
    os.chdir(wd)

    run_amp = """#!/usr/bin/env python
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing

db = connect('../../../database/db4/data.db')

images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=4,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
""".format(n)

    cmd = '''#!/bin/bash
#PBS -N {}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=24:00:00
#PBS -l mem=16GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

    with open('submit.py', 'w') as f:
        f.write(run_amp)
    os.chmod('submit.py', 0777)

    with open('submit.sh', 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', 'submit.sh'])
    time.sleep(2)
    os.unlink('submit.sh')
    os.chdir(home)
#+END_SRC

load
load=os.path.join(wd, 'checkoutpoint-parameters-0.json'),
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

for n in [15, 18, 20, 24]:

    wd = 'networks/db4/{0}-{0}/'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)
    os.chdir(wd)

    run_amp = """#!/usr/bin/env python
import os
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing

db = connect('../../../database/db4/data.db')
wd = os.getcwd()
images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(load='checkpoint-parameters.json',
           label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=4,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
""".format(n)

    cmd = '''#!/bin/bash
#PBS -N {}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=24:00:00
#PBS -l mem=16GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

    with open('submit.py', 'w') as f:
        f.write(run_amp)
    os.chmod('submit.py', 0777)

    with open('submit.sh', 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', 'submit.sh'])
    time.sleep(2)
    os.unlink('submit.sh')
    os.chdir(home)
#+END_SRC

#+RESULTS:
: 1459461.gilgamesh.cheme.cmu.edu
: 1459462.gilgamesh.cheme.cmu.edu
: 1459463.gilgamesh.cheme.cmu.edu
: 1459464.gilgamesh.cheme.cmu.edu


#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing
import os

home = os.getcwd()
wd = 'networks/db3/10-10/'
os.chdir(wd)

db = connect('../../../database/db3/data.db')
wd = os.getcwd()
images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(load='parameters.json',
           label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=4,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
#+END_SRC

** Update

#+BEGIN_SRC python
from ase.db import connect
from amp import Amp

db = connect('./database/db4/data.db')
calc1 = Amp(load = './networks/db4/10-10/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db4/15-15/checkpoint-parameters.json')

for d in db.select():
    atoms = db.get_atoms(d.id)
    atoms.set_calculator(calc1)
    nrg1 = atoms.get_potential_energy()

    atoms.set_calculator(calc2)
    nrg2 = atoms.get_potential_energy()
    db.update(d.id, NN10 = nrg1, NN15 = nrg2)
#+END_SRC

#+RESULTS:

** Residual
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from ase.db import connect
from amp import Amp
import os

db = connect('database/db4/data.db')

fig, ax = plt.subplots(1, 2, sharey=True, figsize=(8, 4))

for i, n in enumerate([10, 15]):

    E, nnE, var, ind = [], [], [], []
    for j, d in enumerate(db.select('')):# dbkey=0
	E += [d.energy / d.natoms]
	nnE += [d['NN{}'.format(n)]/ d.natoms]
	var += [j]
	ind += [d.train_set]

    res = np.array(nnE) - np.array(E)
    mask = np.array(ind)
    valid = np.ma.masked_array(res, mask)
    train = np.ma.masked_array(res, ~mask)
    vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
    tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))

    ax[i].text(200, -0.050,
               'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
               color='b', ha='left')
    ax[i].text(200, -0.057,
               'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
               color='r', ha='left')

    ax[i].scatter(var, train, color='b')
    ax[i].scatter(var, valid, color='r')
    ax[i].plot([min(var), max(var)], [0, 0], 'k--')
    ax[i].set_xlim(min(var), max(var))

    ax[i].set_xlabel('Calculation ID')
    ax[i].set_title('8-{0}-{0}-1 framework'.format(n))

ax[0].set_ylim(-0.060, 0.060)
ax[0].set_ylabel('Residual error (eV/atom)')
plt.tight_layout()
plt.savefig('./figures/residual-4.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/residual-4.png]]

Large error configurations
#+BEGIN_SRC python
import numpy as np
from ase.db import connect
ids = []
db = connect('database/db4/data.db')
for i, d in enumerate(db.select('')):
    E = d.energy / d.natoms
    nE = d.NN15/ d.natoms
    if abs(E - nE) > 0.04:
        ids += [i]

print ids
#+END_SRC

#+RESULTS:
: [228, 342, 604]


*** Bulk Residual
#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db4/data.db')

S, Qe, Ne = [], [], []

for d in db.select(['type=eos']):
    S += [d.bulk]
    Qe += [d.energy/d.natoms]
    Ne += [d.NN15/d.natoms]
    
S = np.array(S)
Qe = np.array(Qe)
Ne = np.array(Ne)

cmap, hdl = {}, []

#print Ne
for s, c in zip(set(S), ['b', 'r', 'g', 'c', 'm']):
    cmap[s] = c
    hdl +=[mpatches.Patch(color = c, label = s)]

c = []
for s in S:
    c +=[cmap[s]]

RMSE = np.sqrt(sum((Ne-Qe)** 2) / len(Ne - Qe))

(mu, sigma) = norm.fit(Ne- Qe)

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
ax0.plot([min(Qe), 0], [0,0], 'k--', lw =2)
ax0.scatter(Qe, Ne-Qe, marker = 'o', color = c)
ax0.text(min(Qe) + 0.1, 0.14,
         'RMSE: {0:1.3f}'.format(RMSE),
         fontsize = 12, va = 'top', ha = 'left')
ax0.set_xlim(min(Qe), 0)
ax0.set_ylim(-0.05, 0.05)
ax0.set_xlabel('DFT potential energy (eV/atom)')
ax0.set_ylabel('Rsidual error (eV/atom)')
ax0.legend(loc = 'best', handles =hdl, fontsize = 8, frameon = False)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(Ne-Qe, 50,
                            range = (-0.05, 0.05),
                            weights = np.ones_like(Ne-Qe)/ len(Ne),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.05, 0.142, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.05, 0.122, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.05, 0.05)
ax1.set_xlim(0, 0.3)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
plt.tight_layout(w_pad = -0.5)

plt.savefig('./figures/eos-residual-4.png')
#plt.show()

#+END_SRC

#+RESULTS:

eos-residual

[[./figures/eos-residual-4.png]]



*** total residual
#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db4/data.db')

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
E, nE, var, ind = [], [], [], []
for j, d in enumerate(db.select('surface=fcc111')):# dbkey=0
    E += [d.energy / d.natoms]
    nE += [d.NN10/ d.natoms]
    var += [j]
    ind += [d.train_set]

E = np.array(E)
nE = np.array(nE)
res = np.array(nE) - np.array(E)
mask = np.array(ind)
valid = np.ma.masked_array(res, mask)
train = np.ma.masked_array(res, ~mask)
vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))

ax0.text(380, -0.048,
           'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
           color='b', ha='left')
ax0.text(270, -0.055,
           'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
           color='r', ha='left')

ax0.scatter(var, train, color='b')
ax0.scatter(var, valid, color='r')
ax0.plot([min(var), max(var)], [0, 0], 'k--')
ax0.set_xlim(min(var), max(var))

ax0.set_xlabel('Calculation ID')
ax0.set_title('8-10-10-1 framework')


(mu, sigma) = norm.fit(nE - E)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(nE-E, 50,
                            range = (-0.05, 0.05),
                            weights = np.ones_like(nE-E)/ len(nE),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.01, 0.04, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.01, 0.03, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.05, 0.05)
ax1.set_xlim(0, 0.20)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
ax1.set_title('Error Distribution')
plt.tight_layout(w_pad = -0.5)
plt.savefig('./figures/error-distribution-4.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/error-distribution-4.png]]
* Application
** MD
*** Trajectory
**** perfect
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db4')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(2, 2, 5), a=3.939, vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(Amp(load="./../../networks/db4/15-15/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD-fixed.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

**** vacancy
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db4')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(2, 2, 5), a=3.939, vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
del atoms[-1]
atoms.set_calculator(Amp(load="./../../networks/db4/15-15/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD1-19.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1460223.gilgamesh.cheme.cmu.edu

*** NN Prediction
**** perfect
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp

calc1 = Amp(load = './networks/db4/10-10/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db4/15-15/checkpoint-parameters.json')
traj = Trajectory('./database/db4/MD-fixed.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/MD225-5.png')
#+END_SRC

#+RESULTS:

[[./figures/MD225-5.png]]

**** vacancy
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp

calc1 = Amp(load = './networks/db4/10-10/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db4/15-15/checkpoint-parameters.json')
traj = Trajectory('./database/db4/MD1-19.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
plt.show()
#plt.savefig('./figures/MD225-5.png')
#+END_SRC

#+RESULTS:

** Bulk Properties
*** Cohesive energy
Atomic energy
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase import Atoms, Atom
from ase.visualize import view
VASPRC['queue.walltime'] = '24:00:00'

atoms = Atoms([Atom('Pd', [5, 5, 5])],
              cell = (7, 8, 9))

calc = Vasp('NDFT/atomic-Pd',
          xc = 'pbe',
          encut = 350,
          kpts = [1]*3,
          atoms = atoms) 

calc.calculate()

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/atomic-Pd submitted: 1442984.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
from vasp import Vasp
from amp import Amp
calc1 = Amp(load='./networks/db4/15-15/checkpoint-parameters.json')

calc = Vasp ('./NDFT/atomic-Pd') 
Eatom = calc.potential_energy
 
calc = Vasp ('./NDFT/bulk=fcc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEfcc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEfcc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=bcc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEbcc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEbcc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=hcp/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEhcp = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEhcp = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=sc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEsc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEsc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=diam/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEdiam = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEdiam = atoms.get_potential_energy()/len(atoms)
print DEfcc-Eatom, NEfcc-Eatom
print DEbcc-Eatom, NEbcc-Eatom
print DEhcp-Eatom, NEhcp-Eatom
print DEsc-Eatom, NEsc-Eatom
print DEdiam-Eatom, NEdiam-Eatom
#+END_SRC

#+RESULTS:
: -3.75476834 -3.75462069529
: -3.71312559 -3.74156357701
: -3.72459561 -3.75344541272
: -3.2532599 -3.2528306537
: -2.6162620675 -2.62032974052

*** Bulk Modulus
#+BEGIN_SRC python
from ase.db import connect
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState
from ase.units import kJ
import numpy as np
from vasp import Vasp
from amp import Amp

factor = np.arange(0.85, 1.2, 0.01)
calc2 = Amp(load='./networks/db4/15-15/checkpoint-parameters.json')
configs = ['fcc', 'bcc', 'hcp', 'sc', 'diam']

for config in configs:
    nrg, vol = [], []
    nn = []
    for f in factor:
        calc = Vasp('./NDFT/bulk={0}/type=eos/factor={1:.2f}'.format(config,f))
        atoms = calc.get_atoms()
        nrg += [atoms.get_potential_energy()/len(atoms)]
        vol += [atoms.get_volume()/len(atoms)]
        atoms.set_calculator(calc2)
        nn +=[atoms.get_potential_energy()/len(atoms)]
        

    vol = np.array(vol)
    nrg = np.array(nrg)
    nn = np.array(nn)
# Fit the data to SJEOS
    eos = EquationOfState(vol, nrg)
    v0, e0, B0 = eos.fit()
    eos = EquationOfState(vol, nn)
    v1, e1, B1 = eos.fit()
    print '{0}'.format(config)
    print v0, e0, B0
    print v1, e1, B1
#+END_SRC

#+RESULTS:
#+begin_example
fcc
15.2979724806 -5.22438476072 1.09507457295
15.2920941055 -5.21955810425 1.1005260915
bcc
15.4257962561 -5.18249419589 1.06469804063
15.4435903952 -5.18716475228 1.06608307803
hcp
15.3645769219 -5.19379582623 1.08254355793
15.3134956647 -5.21647101448 1.10513375669
sc
17.8024966568 -4.72110919112 0.782438954048
17.7845001473 -4.72145099467 0.782964233772
diam
24.3558101786 -4.08130798908 0.428150007251
24.3349178688 -4.08186369292 0.429893179488
#+end_example

*** Elastic Constant
**** 11, 12
#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.01, 11)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=11/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')
    #calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
#+END_SRC

#+RESULTS:
: [ 2.22936683 -0.34128023]
: [ 2.58330265 -0.34127457]

#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.01, 11)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=11/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')
    #calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')

    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
plt.plot(factor, Ed/Vd[0], 'bo', label = 'DFT')
plt.plot(factor, En/Vd[0], 'ro', label = 'NN')
plt.plot(factor, func(factor, *poptd), 'b-', label = 'DFT fit')
plt.plot(factor, func(factor, *poptn), 'r-', label = 'NN fit')

plt.xlabel('Strain')
plt.ylabel('Energy Density [eV/$\AA^3$]')
plt.legend(loc='best')
#plt.savefig('./figures/elastic-1.png')
plt.show()
#+END_SRC

#+RESULTS:
: [ 2.22936683 -0.34128023]
: [ 2.87528197 -0.34126408]

**** 44
#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.01, 11)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=44/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

  #  calc2 = Amp(load='./networks/db3/2-25/checkpoint-parameters.json')
    calc2 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')
    #calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
#+END_SRC

#+RESULTS:
: [ 0.73280411 -0.34127966]
: [ 0.71863853 -0.34126554]

subplot

#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.01, 11)

Ed1, En1, Vd1, Vn1 = [], [], [], []
Ed4, En4, Vd4, Vn4 = [], [], [], []

# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=11/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed1.append(atoms.get_potential_energy())
    Vd1.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')

    atoms.set_calculator(calc2)
    En1.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed1/Vd1[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En1/Vd1[0])
print poptn

plt.subplot(1, 2, 1)
plt.plot(factor, Ed1/Vd1[0], 'bo', label = 'DFT')
plt.plot(factor, En1/Vd1[0], 'ro', label = 'NN')
plt.plot(factor, func(factor, *poptd), 'b-', label = 'DFT fit')
plt.plot(factor, func(factor, *poptn), 'r-', label = 'NN fit')
plt.xlabel('Strain')
plt.ylabel('Energy Density [eV/$\AA^3$]')
plt.legend(loc='best')
plt.title('Strain 1')

for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=44/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed4.append(atoms.get_potential_energy())
    Vd4.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')

    atoms.set_calculator(calc2)
    En4.append(atoms.get_potential_energy())

poptd, pcovd = curve_fit(func, factor, Ed4/Vd4[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En4/Vd4[0])
print poptn

#plt.savefig('./figures/elastic-1.png')
plt.subplot(1, 2, 2)
plt.plot(factor, Ed4/Vd4[0], 'bo', label = 'DFT')
plt.plot(factor, En4/Vd4[0], 'ro', label = 'NN')
plt.plot(factor, func(factor, *poptd), 'b-', label = 'DFT fit')
plt.plot(factor, func(factor, *poptn), 'r-', label = 'NN fit')
plt.xlabel('Strain')
plt.ylabel('Energy Density [eV/$\AA^3$]')
plt.legend(loc='best')
plt.title('Strain 2')

plt.tight_layout()
plt.savefig('./figures/els-cons-4.png')
#plt.show()
#+END_SRC

#+RESULTS:
: [ 2.22936683 -0.34128023]
: [ 2.87528197 -0.34126408]
: [ 0.73280411 -0.34127966]
: [ 0.71863853 -0.34126554]

[[./figures/els-cons-4.png]]

**** calculation
#+BEGIN_SRC python
'''
B = 1.09507457295
a = 2.21553499/6
b = 0.66616554
'''

B = 1.0950
a = 3.0178/6
b = 0.8153
C4 = b/2
C2 = (3*B - 2*a)/3
C1 = 2*a + C2

print C1, C2, C4
print C1 * 160.2177
print C2 * 160.2177
print C4 * 160.2177
#+END_SRC

#+RESULTS:
: 1.76562222222 0.759688888889 0.40765
: 282.883931513
: 121.715606493
: 65.312745405

**** reference 
#+BEGIN_SRC python
from vasp import Vasp
calc = Vasp('~/Research/Bulk/DFT/bulk=fcc/type=elastic/elastic')

EM = calc.get_elastic_moduli()

print EM
#+END_SRC

#+RESULTS:
: [[ 206.71093  155.54113  155.54113    0.         0.         0.     ]
:  [ 155.54113  206.71093  155.54113    0.         0.         0.     ]
:  [ 155.54113  155.54113  206.71093    0.         0.         0.     ]
:  [   0.         0.         0.        59.78395    0.         0.     ]
:  [   0.         0.         0.         0.        59.78395    0.     ]
:  [   0.         0.         0.         0.         0.        59.78395]]


* 6th DFT
** Surface MD
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 2
images = Trajectory('./database/db4/MD-fixed.traj', 'r')

for i in range(50):
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md2/v_a=0_20/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC




#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
from vasp import Vasp
from vasp.vasprc import VASPRC



calc1 = Amp(load = './networks/db4/10-10/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db4/15-15/checkpoint-parameters.json')
images = Trajectory('./database/db4/MD-fixed.traj', 'r')
E1, E2 = [], []

for atoms in images:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in images:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)


nrg, res, s = [], [], []
calcs = []
A = range(50)
for i in A:        
        
        calc = Vasp('NDFT/surface=fcc111/type=md/order=md2/v_a=0_20/MD={}'.format(i))

        nrg += [calc.potential_energy/20]


plt.plot(range(len(E1)), E1, 'b-', label='NN1 prediction')
plt.plot(range(len(E2)), E2, 'r--', label='NN2 prediction')
plt.scatter(A, nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(E1)))
plt.ylabel('Potential energy (eV)')

plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/225MD-5.png')

#+END_SRC

#+RESULTS:

[[./figures/225MD-5.png]]

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 2
images = Trajectory('./database/db4/MD1-19.traj', 'r')

for i in range(50):
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md2/v_a=1_19/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC


#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
from vasp import Vasp
from vasp.vasprc import VASPRC



calc1 = Amp(load = './networks/db4/10-10/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db4/15-15/checkpoint-parameters.json')
images = Trajectory('./database/db4/MD1-19.traj', 'r')
E1, E2 = [], []

for atoms in images:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in images:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)


nrg, res, s = [], [], []
calcs = []
A = range(50)
for i in A:        
        
        calc = Vasp('NDFT/surface=fcc111/type=md/order=md2/v_a=1_19/MD={}'.format(i))

        nrg += [calc.potential_energy/20]


plt.plot(range(len(E1)), E1, 'b-', label='NN1 prediction')
plt.plot(range(len(E2)), E2, 'r--', label='NN2 prediction')
plt.scatter(A, nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(E1)))
plt.ylabel('Potential energy (eV)')

plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
#plt.savefig('./figures/225MD-5.png')
plt.show()
#+END_SRC

#+RESULTS:

* DB
** dbkey 5
#+BEGIN_SRC python
from vasp import Vasp
A = range (50)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md2/v_a=0_20/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':5, 'structure':'surface'})  
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python

from vasp import Vasp
A = range (50)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md2/v_a=1_19/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':5, 'structure':'surface'})  

#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=34'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':4, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=44'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':4, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

*** trajectory

#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=22'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':4}) for A in images]
#+END_SRC

#+RESULTS:

** write
*** DBkey0
#+BEGIN_SRC python
from vasp import Vasp

factor = [0.900, 0.950, 1.000, 1.050]

cells= ['222', '223', '233', '333', '334', '344', '444'] 

calcs = []
for cell in cells:

    for x in factor:
    
        wd = './NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell={0}/factor={1:.3f}'.format(cell,x)
        #wd = './NDFT/bulk=fcc/type=vacancy/lattice=cubic/supercell={0}/factor={1:.3f}'.format(cell,x)
        calc = Vasp(wd)

        calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':0, 'structure':'bulk'}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []
for i in range(200):
    wd = './NDFT/bulk=fcc/type=md/order=md0/v_a=0_8/MD={0}'.format(i)

    calc = Vasp(wd)
    calcs += [calc]
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':0, 'structure':'bulk'}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
import numpy as np

factor = np.append(np.arange(0.85, 1.2, 0.01),
                   np.arange(1.2, 2.125, 0.05))


cells = ['fcc', 'bcc', 'hcp', 'sc', 'diam']
for cell in cells:

    for x in factor:
    
   
        wd = './NDFT/bulk={0}/type=eos/factor={1:.2f}'.format(cell,x)
        calc = Vasp(wd)

        calc.write_db('./database/ddb5/data.db', parser='=', overwrite=False, keys={'dbkey':0, 'structure':'bulk'}) 
#+END_SRC

#+RESULTS:

*** DBkey1
**** 0:8
#+BEGIN_SRC python
from vasp import Vasp

for i in range(200):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=0_8/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':1, 'structure':'bulk'})  
#+END_SRC

#+RESULTS:

**** 1:7
#+BEGIN_SRC python
from vasp import Vasp

for i in range(51):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_7/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':1, 'structure':'bulk'})  
#+END_SRC

#+RESULTS:

**** 1:11
#+BEGIN_SRC python
from vasp import Vasp

for i in range(22):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_11/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':1, 'structure':'bulk'})  
#+END_SRC

#+RESULTS:

**** 1:17
#+BEGIN_SRC python
from vasp import Vasp

for i in range(38):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_17/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':1, 'structure':'bulk'})  
#+END_SRC

#+RESULTS:

**** 1:26
#+BEGIN_SRC python
from vasp import Vasp

for i in range(16):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_26/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':1, 'structure':'bulk'})  
#+END_SRC

#+RESULTS:

**** 1:35
#+BEGIN_SRC python
from vasp import Vasp

for i in range(10):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_35/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':1, 'structure':'bulk'})   
#+END_SRC

#+RESULTS:

**** 1:47
#+BEGIN_SRC python
from vasp import Vasp

for i in range(10):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_47/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':1, 'structure':'bulk'})   
#+END_SRC

#+RESULTS:

**** 1:63
#+BEGIN_SRC python
from vasp import Vasp

for i in range(10):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_63/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':1, 'structure':'bulk'})  
#+END_SRC

#+RESULTS:

*** DBkey2
#+BEGIN_SRC python
from vasp import Vasp
import numpy as np

factor = np.linspace(0, 0.04, 41)

for x in factor:
    wd = './NDFT/bulk=fcc/type=elastic/dirs=11/factor={:.3f}'.format(x)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})   
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
import numpy as np

factor = np.linspace(0, 0.04, 41)

for x in factor:
    wd = './NDFT/bulk=fcc/type=elastic/dirs=44/factor={:.3f}'.format(x)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp

for cell in ['222', '223', '233', '333']:

    for i in range(9):
        wd = './NDFT/bulk=fcc/type=neb/supercell={0}/image={1}'.format(cell, i)
        calc = Vasp(wd)
        calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []
a = [86, 87, 88, 90, 91, 92, 97, 98, 99, 100, 101, 106, 107, 108, 109, 111, 112, 116, 117, 118, 120, 121, 122, 123, 129, 130, 131, 132, 133, 134, 141, 142, 143, 144, 145, 150, 151, 152, 153, 176, 177, 178, 179, 180, 181, 182, 183, 184, 188, 189, 190, 191, 196, 197, 198, 199]
for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/MD={0}'.format(i)  
    calc = Vasp(wd)
    
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []
a = [0, 3, 7, 8, 11, 12, 20, 21, 28, 39, 43, 46, 50, 51, 53, 54, 57, 58, 59, 60, 64, 65, 66, 67, 68, 69, 71, 72, 73, 79, 80, 88, 91, 92, 98, 99, 101, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 118, 119, 120, 121, 122, 123, 124, 125, 127, 128, 129, 131, 132, 133, 134, 135, 136, 137, 138, 142, 143, 144, 145, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 184, 185, 186, 187, 188, 189, 190, 191, 192, 194, 195, 196, 197, 198, 199]
for i in a:  
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_11/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []
a =  [7, 43, 47, 49, 51, 55, 62, 66, 70, 74, 75, 79, 80, 81, 82, 88, 89, 90, 94, 95, 96, 97, 101, 102, 106, 109, 113, 114, 117, 118, 119, 123, 124, 125, 126, 127, 128, 131, 132, 134, 135, 136, 139, 140, 141, 142, 143, 145, 146, 147, 149, 150, 151, 155, 157, 158, 159, 160, 161, 162, 163, 165, 166, 167, 168, 169, 170, 172, 173, 174, 175, 176, 177, 178, 180, 181, 182, 183, 184, 185, 186, 187, 188, 190, 191, 192, 193, 194, 197, 198, 199]
for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_17/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []
a = [0, 2, 3, 4, 7, 8, 11, 12, 15, 16, 19, 20, 23, 24, 27, 28, 32, 36, 40, 41, 45, 46, 49, 52, 53, 56, 57, 60, 65, 67, 69, 75, 77, 79, 86, 87, 90, 91, 97, 108, 114, 116, 117, 118, 120, 124, 125, 128, 129, 130, 135, 136, 137, 138, 140, 142, 143, 144, 149, 150, 154, 155, 156, 160, 161, 164, 165, 167, 168, 169, 170, 171, 174, 179, 180, 181, 182, 183, 186, 187, 188, 190, 192, 193, 194, 197, 199]
for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})
#+END_SRC


#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 20, 21, 23, 24, 25, 28, 29, 30, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 45, 46, 47, 49, 50, 51, 52, 53, 55, 56, 57, 58, 59, 60, 62, 63, 64, 65, 67, 68, 71, 72, 73, 76, 77, 78, 80, 81, 83, 84, 85, 88, 89, 90, 91, 92, 94, 95, 96, 97, 98, 99]

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []
for i in range(100):
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_47/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)
del a[9]
for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_63/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []

#a = range(0, 21)
#a = range (23, 50)
a = range(0, 50)
del a[11]
del a[21]
#print a

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=1/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})


#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=2/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=3/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=4/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})
#+END_SRC

#+RESULTS:

**** Surface
#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':2, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=relaxation/supercell=23/factor=1.00'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':2, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=relaxation/supercell=33/factor=1.00'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':2, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

*** DBkey3
#+BEGIN_SRC python
from vasp import Vasp
for i in range(200):        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md0/v_a=0_20/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':3, 'structure':'surface'}) 
#+END_SRC

#+RESULTS:

*** DBkey4
#+BEGIN_SRC python
from vasp import Vasp
A = [0, 2, 4, 5, 6, 7, 10, 11, 12, 13, 16, 17, 18, 19, 21, 24, 25, 26, 27, 28, 29, 30, 32, 33, 37, 38, 40, 41, 43, 44, 45, 46, 50, 52, 54, 55, 60, 61, 63, 64, 65, 66, 73, 74, 75, 76, 82, 87, 92, 93, 102, 103, 104, 107, 108, 113, 114, 119, 121, 123, 124, 128, 129, 133, 138, 139, 142, 145, 146, 147, 148, 149, 150, 154, 155, 158, 159, 160, 167, 170, 179, 180, 184, 189, 191, 193, 194, 195, 197, 198]
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md1/v_a=0_20/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':4, 'structure':'surface'}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=22'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':4, 'structure':'surface'}) for A in images]
#+END_SRC
#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=23'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':4, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=33'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':4, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read
pos = ['fcc', 'hcp', 'bridge', 'top']
for cong in pos:
    wd = 'NDFT/surface=fcc111/type=adatom/supercell=22/site={}'.format(cong)
    images = read(wd + '/vasprun.xml', ':')
    calc = Vasp(wd)

    [calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':4, 'structure':'surface'}) for A in images] 

#+END_SRC

#+RESULTS:

** keywords
#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

from ase.db import connect

db = connect('./database/db5/data.db')
data = db.select(['train_set=True'])

keys, cnt = {}, 0
for entry in data:
    cnt += 1
    for k, v in entry.key_value_pairs.iteritems():
        
        if k in keys:
            keys[k] += [v]
        else:
            keys[k] = [v]

print ('{0:15s} {1:15s} {2} calculations total'.format('keyword', 'value',cnt))

print('------------------------------------------------------')

for k, v in keys.iteritems():
    vals = list(set(v))
    if len(vals) <= 5:
        val = ", ".join(str(e) for e in vals)
        print('{0:15}: {1}'.format(k, val))

    else:
        val = ", ".join(str(e)[:5] for e in vals[:5])
        print('{0:15s}:{1}, etc...'.format(k, val))
#+END_SRC
#+RESULTS:
#+begin_example
keyword         value           1967 calculations total
------------------------------------------------------
dirs           : 11, 44
MD             :0, 1, 2, 3, 4, etc...
vrelax         : False
train_set      : True
image          :0, 1, 2, 3, 4, etc...
site           : bridge, top, fcc, hcp
dbkey          :0, 1, 2, 3, 4, etc...
bulk           : sc, hcp, fcc, diam, bcc
lattice        : primitive
supercell      :33, 233, 333, 334, 22, etc...
v_a            :1_7, 1_47, 1_63, 0_20, 1_11, etc...
surface        : fcc111
factor         :1.25, 1.0, 2.0, 1.5, 0.036, etc...
type           :md, elast, vacan, neb, adato, etc...
order          : md2, md0, md1
structure      : bulk, surface
#+end_example

* Training
** Training Set
#+BEGIN_SRC python
from ase.db import connect
import os
import random
import numpy as np

db = connect('./database/db5/data.db')

n = db.count()
n_train = int(round(n * 0.9))

n_ids =  np.array(range(n)) + 1

# This will sudo-randomly select 10% of the calculations
# Which is useful for reproducing our results.
random.seed(256)
train_samples = random.sample(n_ids, n_train)
valid_samples = set(n_ids) - set(train_samples)

db.update(list(train_samples), train_set=True)
db.update(list(valid_samples), train_set=False)

#+END_SRC

#+RESULTS:

** Training
#+BEGIN_SRC python
import os
import subprocess
import time
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing

home = os.getcwd()

for n in [2]:

    wd = 'temp/db5/{0}-{0}/'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)
    os.chdir(wd)


from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing

db = connect('../../../database/db5/data.db')

images = []
for d in db.select(''):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, 2)))

calc.train(images=images,
	   data_format='db',
	   cores=4,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)

#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

for n in [15, 18, 20, 24]:

    wd = 'networks/db5/{0}-{0}/'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)
    os.chdir(wd)

    run_amp = """#!/usr/bin/env python
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing

db = connect('../../../database/db5/data.db')

images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=8,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
""".format(n)

    cmd = '''#!/bin/bash
#PBS -N {}
#PBS -l nodes=1:ppn=8
#PBS -l walltime=168:00:00
#PBS -l mem=16GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

    with open('submit.py', 'w') as f:
        f.write(run_amp)
    os.chmod('submit.py', 0777)

    with open('submit.sh', 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', 'submit.sh'])
    time.sleep(2)
    os.unlink('submit.sh')
    os.chdir(home)
#+END_SRC

#+RESULTS:
: 1460463.gilgamesh.cheme.cmu.edu
: 1460464.gilgamesh.cheme.cmu.edu
: 1460465.gilgamesh.cheme.cmu.edu
: 1460466.gilgamesh.cheme.cmu.edu

load
load=os.path.join(wd, 'checkoutpoint-parameters-0.json'),
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

for n in [18]:

    wd = 'networks/db5/{0}-{0}/'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)
    os.chdir(wd)

    run_amp = """#!/usr/bin/env python
import os
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing

db = connect('../../../database/db5/data.db')
wd = os.getcwd()
images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(load='checkpoint-parameters.json',
           label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=4,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
""".format(n)

    cmd = '''#!/bin/bash
#PBS -N {}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=168:00:00
#PBS -l mem=16GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

    with open('submit.py', 'w') as f:
        f.write(run_amp)
    os.chmod('submit.py', 0777)

    with open('submit.sh', 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', 'submit.sh'])
    time.sleep(2)
    os.unlink('submit.sh')
    os.chdir(home)
#+END_SRC

#+RESULTS:
: 1461120.gilgamesh.cheme.cmu.edu


#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing
import os

home = os.getcwd()
wd = 'networks/db3/10-10/'
os.chdir(wd)

db = connect('../../../database/db3/data.db')
wd = os.getcwd()
images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(load='parameters.json',
           label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=4,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
#+END_SRC

** Update

#+BEGIN_SRC python
from ase.db import connect
from amp import Amp

db = connect('./database/db5/data.db')
calc1 = Amp(load = './networks/db4/15-15/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db4/20-20/checkpoint-parameters.json')

for d in db.select():
    atoms = db.get_atoms(d.id)
    atoms.set_calculator(calc1)
    nrg1 = atoms.get_potential_energy()

    atoms.set_calculator(calc2)
    nrg2 = atoms.get_potential_energy()
    db.update(d.id, NN15 = nrg1, NN20 = nrg2)
#+END_SRC

#+RESULTS:

** Residual
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from ase.db import connect
from amp import Amp
import os

db = connect('database/db5/data.db')

fig, ax = plt.subplots(1, 2, sharey=True, figsize=(8, 4))

for i, n in enumerate([15, 20]):

    E, nnE, var, ind = [], [], [], []
    for j, d in enumerate(db.select('')):# dbkey=0
	E += [d.energy / d.natoms]
	nnE += [d['NN{}'.format(n)]/ d.natoms]
	var += [j]
	ind += [d.train_set]

    res = np.array(nnE) - np.array(E)
    mask = np.array(ind)
    valid = np.ma.masked_array(res, mask)
    train = np.ma.masked_array(res, ~mask)
    vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
    tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))

    ax[i].text(200, -0.050,
               'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
               color='b', ha='left')
    ax[i].text(200, -0.057,
               'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
               color='r', ha='left')

    ax[i].scatter(var, train, color='b')
    ax[i].scatter(var, valid, color='r')
    ax[i].plot([min(var), max(var)], [0, 0], 'k--')
    ax[i].set_xlim(min(var), max(var))

    ax[i].set_xlabel('Calculation ID')
    ax[i].set_title('8-{0}-{0}-1 framework'.format(n))

ax[0].set_ylim(-0.060, 0.060)
ax[0].set_ylabel('Residual error (eV/atom)')
plt.tight_layout()
plt.savefig('./figures/residual-5.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/residual-5.png]]

Large error configurations
#+BEGIN_SRC python
import numpy as np
from ase.db import connect
ids = []
db = connect('database/db5/data.db')
for i, d in enumerate(db.select('')):
    E = d.energy / d.natoms
    nE = d.NN15/ d.natoms
    if abs(E - nE) > 0.04:
        ids += [i]

print ids
#+END_SRC

#+RESULTS:
: [228, 770, 2122]

#+BEGIN_SRC python
from ase.db import connect

db = connect('database/db5/data.db')
for i, d in enumerate(db.select('id=2122')):
        for key in d:
            print ('{0:25}:{1}'.format(key, d[key]))
#+END_SRC

#+RESULTS:
#+begin_example
forces                   :[[-0.00609386 -0.00475205 -0.03970749]
 [ 0.00609386 -0.00475205 -0.03970749]
 [ 0.          0.00300473 -0.05314357]
 [ 0.          0.00588724 -0.05557616]
 [-0.00077056  0.00838713  0.07530263]
 [ 0.00077056  0.00838713  0.07530263]
 [ 0.         -0.01222171  0.03860598]
 [ 0.         -0.01163335  0.03387169]
 [ 0.          0.00167858 -0.00083004]
 [ 0.          0.00686816 -0.00656157]
 [ 0.00627474  0.0083125  -0.00454085]
 [-0.00627474  0.0083125  -0.00454085]
 [ 0.00267647 -0.00172957 -0.00718877]
 [-0.00267647 -0.00172957 -0.00718877]
 [ 0.          0.01258181 -0.01189079]
 [ 0.         -0.00682303  0.00846076]
 [ 0.04504862 -0.01578173  0.01304872]
 [-0.04504862 -0.01578173  0.01304872]
 [ 0.         -0.03066894 -0.00811017]
 [ 0.         -0.01806074 -0.01240103]
 [ 0.          0.06051467 -0.00625358]]
calculator               :unknown
site                     :bridge
surface                  :fcc111
supercell                :22
dbkey                    :4
calculator_parameters    :"\"\\\"\\\\\\\"{}\\\\\\\"\\\"\""
mtime                    :16.6834972741
structure                :surface
ctime                    :16.673066159
stress                   :[  1.37760563e-02   1.88254252e-02   3.35674038e-03  -8.69619532e-05
  -0.00000000e+00  -0.00000000e+00]
NN15                     :-104.041524486
train_set                :True
positions                :[[  5.57058719   1.60809      5.99999991]
 [  2.78529358   1.60809      5.99999991]
 [  6.963234     4.02022503   5.99999991]
 [  4.17794039   4.02022503   5.99999991]
 [  0.           0.           8.27418277]
 [  2.78529361   0.           8.27418277]
 [  1.39264681   2.41213502   8.27418277]
 [  4.17794042   2.41213502   8.27418277]
 [  1.39264683   0.80932017  10.54679329]
 [  4.17794044   0.80820605  10.54989662]
 [  2.78425224   3.21639883  10.53906007]
 [  5.57162859   3.21639883  10.53906007]
 [  5.56520943   1.62759206  12.83108296]
 [  2.7906714    1.62759206  12.83108296]
 [  6.96323403   4.00944785  12.80584136]
 [  4.17794044   4.02442147  12.79994334]
 [ -0.06521576  -0.02424263  15.01919264]
 [  2.85050937  -0.02424263  15.01919264]
 [  1.39264681   2.35336471  15.18535112]
 [  4.17794039   2.45061046  15.18967764]
 [  1.39264681   0.          17.09690903]]
user                     :tianyug1
NN20                     :-103.92314303
id                       :2122
cell                     :[[  5.57058722   0.           0.        ]
 [  2.78529361   4.82427005   0.        ]
 [  0.           0.          21.09673084]]
pbc                      :[ True  True  True]
type                     :adatom
energy                   :-103.93990493
unique_id                :89ca0693b301644cce2af0c5d6b5c2fa
numbers                  :[46 46 46 46 46 46 46 46 46 46 46 46 46 46 46 46 46 46 46 46 46]
#+end_example

*** Bulk Residual
#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db4/data.db')

S, Qe, Ne = [], [], []

for d in db.select(['type=eos']):
    S += [d.bulk]
    Qe += [d.energy/d.natoms]
    Ne += [d.NN15/d.natoms]
    
S = np.array(S)
Qe = np.array(Qe)
Ne = np.array(Ne)

cmap, hdl = {}, []

#print Ne
for s, c in zip(set(S), ['b', 'r', 'g', 'c', 'm']):
    cmap[s] = c
    hdl +=[mpatches.Patch(color = c, label = s)]

c = []
for s in S:
    c +=[cmap[s]]

RMSE = np.sqrt(sum((Ne-Qe)** 2) / len(Ne - Qe))

(mu, sigma) = norm.fit(Ne- Qe)

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
ax0.plot([min(Qe), 0], [0,0], 'k--', lw =2)
ax0.scatter(Qe, Ne-Qe, marker = 'o', color = c)
ax0.text(min(Qe) + 0.1, 0.14,
         'RMSE: {0:1.3f}'.format(RMSE),
         fontsize = 12, va = 'top', ha = 'left')
ax0.set_xlim(min(Qe), 0)
ax0.set_ylim(-0.05, 0.05)
ax0.set_xlabel('DFT potential energy (eV/atom)')
ax0.set_ylabel('Rsidual error (eV/atom)')
ax0.legend(loc = 'best', handles =hdl, fontsize = 8, frameon = False)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(Ne-Qe, 50,
                            range = (-0.05, 0.05),
                            weights = np.ones_like(Ne-Qe)/ len(Ne),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.05, 0.142, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.05, 0.122, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.05, 0.05)
ax1.set_xlim(0, 0.3)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
plt.tight_layout(w_pad = -0.5)

plt.savefig('./figures/eos-residual-4.png')
#plt.show()

#+END_SRC

#+RESULTS:

eos-residual

[[./figures/eos-residual-4.png]]



*** surface residual
#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db5/data.db')

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
E, nE, var, ind = [], [], [], []
#for j, d in enumerate(db.select(['order=md2','structure=surface'])):# dbkey=0
#for j, d in enumerate(db.select(['v_a=0_20'])):# dbkey=0
#for j, d in enumerate(db.select(['type=vacancy', 'structure=surface'])):# dbkey=0
for j, d in enumerate(db.select(['type=elastic'])):
    E += [d.energy / d.natoms]
    nE += [d.NN15/ d.natoms]
    var += [j]
    ind += [d.train_set]

E = np.array(E)
nE = np.array(nE)
res = np.array(nE) - np.array(E)
mask = np.array(ind)
valid = np.ma.masked_array(res, mask)
train = np.ma.masked_array(res, ~mask)
vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))

ax0.text(380, -0.048,
           'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
           color='b', ha='left')
ax0.text(270, -0.055,
           'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
           color='r', ha='left')

ax0.scatter(var, train, color='b')
ax0.scatter(var, valid, color='r')
ax0.plot([min(var), max(var)], [0, 0], 'k--')
ax0.set_xlim(min(var), max(var))
ax0.set_ylim(-0.015, 0.015)

ax0.set_xlabel('Calculation ID')
ax0.set_title('8-15-15-1 framework')


(mu, sigma) = norm.fit(nE - E)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(nE-E, 50,
                            range = (-0.05, 0.05),
                            weights = np.ones_like(nE-E)/ len(nE),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.01, 0.04, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.01, 0.03, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.05, 0.05)
ax1.set_xlim(0, 0.20)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
ax1.set_title('Error Distribution')
plt.tight_layout(w_pad = -0.5)
plt.savefig('./figures/surf-error-distribution-5.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/surf-error-distribution-5.png]]

* Application
** MD
*** Trajectory
**** perfect
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db5/perfect')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(2, 2, 5), a=3.939, vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(Amp(load="./../../../networks/db5/20-20/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(4000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1460496.gilgamesh.cheme.cmu.edu

**** vacancy
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db5/vacancy')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(2, 2, 5), a=3.939, vacuum=6.0)
del atoms[-1]
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(Amp(load="./../../../networks/db5/20-20/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db5/vacancy-33')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(3, 3, 5), a=3.939, vacuum=6.0)
del atoms[-1]
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(Amp(load="./../../../networks/db5/20-20/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1460499.gilgamesh.cheme.cmu.edu

**** adatom
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db5/fcc')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111, add_adsorbate
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(2, 2, 5), a = 3.939, vacuum = 6.0)
add_adsorbate(atoms, "Pd", height=2.0, position="fcc")
constraint = FixAtoms(mask=[atom.tag >3  for atom in atoms])
atoms.set_constraint(constraint)

atoms.set_calculator(Amp(load="./../../../networks/db5/20-20/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(1000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1460501.gilgamesh.cheme.cmu.edu

*** NN Prediction
**** perfect
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp

calc1 = Amp(load = './networks/db4/10-10/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db4/15-15/checkpoint-parameters.json')
traj = Trajectory('./database/db4/MD-fixed.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/MD225-5.png')
#+END_SRC

#+RESULTS:

[[./figures/MD225-5.png]]

**** vacancy
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp

calc1 = Amp(load = './networks/db5/18-18/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db5/20-20/checkpoint-parameters.json')
traj = Trajectory('./database/db5/vacancy/MD.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/MD-vac-6.png')
#+END_SRC

#+RESULTS:

[[./figures/MD-vac-6.png]]

** Elastic
#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.01, 11)

Ed1, En1, Vd1, Vn1 = [], [], [], []
Ed4, En4, Vd4, Vn4 = [], [], [], []

# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=11/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed1.append(atoms.get_potential_energy())
    Vd1.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')

    atoms.set_calculator(calc2)
    En1.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed1/Vd1[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En1/Vd1[0])
print poptn

plt.subplot(1, 2, 1)
plt.plot(factor, Ed1/Vd1[0], 'bo', label = 'DFT')
plt.plot(factor, En1/Vd1[0], 'ro', label = 'NN')
plt.plot(factor, func(factor, *poptd), 'b-', label = 'DFT fit')
plt.plot(factor, func(factor, *poptn), 'r-', label = 'NN fit')
plt.xlabel('Strain')
plt.ylabel('Energy Density [eV/$\AA^3$]')
plt.legend(loc='best')
plt.title('Strain 1')

for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=44/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed4.append(atoms.get_potential_energy())
    Vd4.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load = './networks/db5/20-20/checkpoint-parameters.json')

    atoms.set_calculator(calc2)
    En4.append(atoms.get_potential_energy())

poptd, pcovd = curve_fit(func, factor, Ed4/Vd4[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En4/Vd4[0])
print poptn

#plt.savefig('./figures/elastic-1.png')
plt.subplot(1, 2, 2)
plt.plot(factor, Ed4/Vd4[0], 'bo', label = 'DFT')
plt.plot(factor, En4/Vd4[0], 'ro', label = 'NN')
plt.plot(factor, func(factor, *poptd), 'b-', label = 'DFT fit')
plt.plot(factor, func(factor, *poptn), 'r-', label = 'NN fit')
plt.xlabel('Strain')
plt.ylabel('Energy Density [eV/$\AA^3$]')
plt.legend(loc='best')
plt.title('Strain 2')

plt.tight_layout()
plt.savefig('./figures/els-cons-5.png')
#+END_SRC

#+RESULTS:
: [ 2.22936683 -0.34128023]
: [ 2.87528197 -0.34126408]
: [ 0.73280411 -0.34127966]
: [ 0.86558393 -0.34136471]

[[./figures/els-cons-5.png]]

**** calculation
#+BEGIN_SRC python
'''
B = 1.09507457295
a = 2.21553499/6
b = 0.66616554
'''

B = 1.0950
a = 2.875/6
b = 0.866
C4 = b/2
C2 = (3*B - 2*a)/3
C1 = 2*a + C2

print C1, C2, C4
print C1 * 160.2177
print C2 * 160.2177
print C4 * 160.2177
#+END_SRC

#+RESULTS:
: 1.73388888889 0.775555555556 0.433
: 277.799689833
: 124.257727333
: 69.3742641

#+BEGIN_SRC python
from ase.db import connect

db = connect('database/db5/data.db')
for i, d in enumerate(db.select('type=elastic')):
        for key in d:
            print ('{0:25}:{1}'.format(key, d[key]))
#+END_SRC


* 7th DFT
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 2
images = Trajectory('./database/db5/vacancy/MD.traj', 'r')

for i in range(100):
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md3/v_a=1_19/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
from vasp import Vasp
from vasp.vasprc import VASPRC



calc1 = Amp(load = './networks/db5/20-20/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db5/24-24/checkpoint-parameters.json')
images = Trajectory('./database/db5/vacancy/MD.traj', 'r')
E1, E2 = [], []

for atoms in images:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in images:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)


nrg, res, s = [], [], []
calcs = []
A = range(100)
for i in A:        
        
        calc = Vasp('NDFT/surface=fcc111/type=md/order=md3/v_a=1_19/MD={}'.format(i))

        nrg += [calc.potential_energy/20]


plt.plot(range(len(E1)), E1, 'b-', label='NN1 prediction')
plt.plot(range(len(E2)), E2, 'r--', label='NN2 prediction')
plt.scatter(A, nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(E1)))
plt.ylabel('Potential energy (eV)')

plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/sur-vac-5.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/sur-vac-5.png]]

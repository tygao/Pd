* 1st DFT
2*2*2 = [9, 9, 9]
3*3*3 = [5, 5, 5] 2GB
4*4*4 = [3, 3, 3] 4GB
** Vacancy
2*2*2 = [9, 9, 9]
3*3*3 = [5, 5, 5] 2GB
4*4*4 = [3, 3, 3] 4GB
*** Primitive
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase import Atoms, Atom
from ase.lattice.cubic import FaceCenteredCubic
from ase.visualize import view
import numpy as np

VASPRC['queue.men'] = '4GB'

#factor = [0.9, 0.95, 1.0, 1.05]
factor = [1.000]
energies = []
for x in factor:

    fcc = FaceCenteredCubic('Pd',
                            directions=[[0, 1, 1],
                                        [1, 0, 1],
                                        [1, 1, 0]],
                            latticeconstant = 3.939)

    delta = np.array([[x, 0., 0.],
                      [0., x, 0.],
                      [0., 0., x]])
    fcc.set_cell(np.dot(fcc.get_cell(), delta),
                       scale_atoms = True)

    atoms = fcc.repeat([4, 4, 4])

    cnt = len(atoms)
    del atoms[0]
    atoms.rattle()
    
    wd = './NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=444/factor={0:1.3f}'.format(x)
    calc = Vasp(wd,
                xc='pbe',
                encut=350,
                kpts = [3, 3, 3],
                ibrion = 2,
                isif = 2,
                nsw = 25,
                atoms = atoms)

    energies.append(calc.potential_energy) 

print energies


#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=444/factor=1.000 submitted: 1428755.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=444/factor=1.000 Queued: 1428755.gilgamesh.cheme.cmu.edu
: [None]

#+BEGIN_SRC python
from vasp import Vasp

factor = [0.9, 0.95, 1.0, 1.05]
nrg, calcs = [], []
for f in factor:
    calc = Vasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=222/factor={0:1.3f}'.format(f))
    calcs  += [calc]
    nrg +=[calc.potential_energy]

Vasp.stop_if(None in nrg)


[calc.write_db('database/master.db', parser='=', overwrite=False) for calc in calcs]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase import Atoms, Atom
from ase.lattice.cubic import FaceCenteredCubic
from ase.visualize import view
import numpy as np
VASPRC['queue.men']='8GB'
#factor = [0.9, 0.95, 1.0, 1.05]
factor = [1.000]
energies = []
for x in factor:

    fcc = FaceCenteredCubic('Pd',
                            directions=[[0, 1, 1],
                                        [1, 0, 1],
                                        [1, 1, 0]],
                            latticeconstant = 3.939)

    delta = np.array([[x, 0., 0.],
                      [0., x, 0.],
                      [0., 0., x]])
    fcc.set_cell(np.dot(fcc.get_cell(), delta),
                       scale_atoms = True)

    atoms = fcc.repeat([5, 5, 5])

    cnt = len(atoms)
    del atoms[0]
    atoms.rattle()
    
    wd = './NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=555/factor={0:1.3f}'.format(x)
    calc = Vasp(wd,
                xc='pbe',
                encut=350,
                kpts = [1, 1, 1],
                ibrion = 2,
                isif = 2,
                nsw = 25,
                atoms = atoms)

 
    calc.potential_energy


#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=555/factor=1.000 submitted: 1449350.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=555/factor=1.000 Queued: 1449350.gilgamesh.cheme.cmu.edu

*** Cubic
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase import Atoms, Atom
from ase.lattice.cubic import FaceCenteredCubic
from ase.visualize import view
import numpy as np

VASPRC['queue.men'] = '4GB'

#factor = [0.95, 1.0, 1.05]
factor=[0.950]
energies = []
calcs = []
for x in factor:

    fcc = FaceCenteredCubic('Pd',
                            directions=[[1, 0, 0],
                                        [0, 1, 0],
                                        [0, 0, 1]],
                            latticeconstant = 3.939)

    delta = np.array([[x, 0., 0.],
                      [0., x, 0.],
                      [0., 0., x]])
    fcc.set_cell(np.dot(fcc.get_cell(), delta),
                       scale_atoms = True)

    atoms = fcc.repeat([2, 2, 2])

    cnt = len(atoms)
    del atoms[0]
    atoms.rattle()

    wd = './NDFT/bulk=fcc/type=vacancy/lattice=cubic/supercell=222/factor={:.3f}'.format(x)
   # wd = './NDFT/bulk=fcc/type=test/factor={:.3f}'.format(x)
    calc = Vasp(wd,
                xc='pbe',
                encut=350,
                kpts=[4]*3,
                #kpts=[2]*3,
                ibrion=2,
                isif=2,
                nsw=25,
                atoms=atoms)

    energies += [calc.potential_energy]
    calcs += [calc]

print energies

#Vasp.stop_if(None in energies)

[calc.write_db('./database/db0.db', parser='=', overwrite=False, keys={'dbkey':0}) for calc in calcs]
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=vacancy/lattice=cubic/supercell=222/factor=0.950 submitted: 1430982.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=vacancy/lattice=cubic/supercell=222/factor=0.950 Queued: 1430982.gilgamesh.cheme.cmu.edu
: [None]

#+BEGIN_SRC python
from vasp import Vasp
calc = Vasp('./NDFT/bulk=fcc/type=vacancy/lattice=cubic/supercell=222/factor=0.950')
calc.qalter('s','walltime=24:00:00')
#+END_SRC

#+RESULTS:

** Vacancy Diffusion NEB
*** 2*2*2
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '8GB'
VASPRC['wall.time'] = '24:00:00'
fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 2, 2])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb-initial',
          xc='pbe',
          kpts=[9, 9, 9],
          encut=350,
          atoms=ini)

fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb-final',
            xc='pbe',
            kpts=[9, 9, 9],
            encut=350,
            atoms=fin)

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb',
            xc='pbe',
            kpts=[9, 9, 9],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/222-NEB.png')
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.675637
:          Iterations: 15
:          Function evaluations: 30

[[./figures/NEB-7.png]]
*** 2*2*3
c0-end
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['wall.time'] = '24:00:00'
fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 2, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-initial',
          xc='pbe',
          kpts=[9, 9, 5],
          encut=350,
          atoms=ini)
c0.calculate()
fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-final',
            xc='pbe',
            kpts=[9, 9, 5],
            encut=350,
            atoms=fin)
cend.calculate()
#+END_SRC

#+RESULTS:
: No calculation_required.
: No calculation_required.


#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '8GB'

fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 2, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-initial',
          xc='pbe',
          kpts=[9, 9, 5],
          encut=350,
          atoms=ini)

fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-final',
            xc='pbe',
            kpts=[9, 9, 5],
            encut=350,
            atoms=fin)

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb',
            xc='pbe',
            kpts=[9, 9, 5],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('.images/223-NEB.png')
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/neb submitted: 1434120.gilgamesh.cheme.cmu.edu

*** 2*3*3
c0-end
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['wall.time'] = '24:00:00'
fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 3, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-initial',
          xc='pbe',
          kpts=[9, 5, 5],
          encut=350,
          atoms=ini)
c0.calculate()
fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-final',
            xc='pbe',
            kpts=[9, 5, 5],
            encut=350,
            atoms=fin)
cend.calculate()
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=233/neb-initial submitted: 1434130.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=233/neb-final submitted: 1434131.gilgamesh.cheme.cmu.edu


#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '8GB'


# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-initial')
ini = c0.get_atoms()

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-final')
fin = cend.get_atoms()

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb',
            xc='pbe',
            kpts=[9, 5, 5],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('.images/233-NEB.png')
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/neb submitted: 1434120.gilgamesh.cheme.cmu.edu

*** 3*3*3
c0-end
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([3, 3, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb-initial',
          xc='pbe',
          kpts=[5, 5, 5],
          encut=350,
          atoms=ini)
c0.calculate()
fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb-final',
            xc='pbe',
            kpts=[5, 5, 5],
            encut=350,
            atoms=fin)
cend.calculate()
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/neb-initial submitted: 1434133.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/neb-final submitted: 1434134.gilgamesh.cheme.cmu.edu


#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '8GB'


# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb-initial')
ini = c0.get_atoms()

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-final')
fin = cend.get_atoms()

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb',
            xc='pbe',
            kpts=[5, 5, 5],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('.images/333-NEB.png')
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/neb submitted: 1434120.gilgamesh.cheme.cmu.edu

** MD0
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
from vasp.vasprc import VASPRC
import matplotlib.pyplot as plt
import jbtools.gilgamesh as jb
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
for i, atoms in enumerate(Trajectory('./networks/db3-v/MD.traj', 'r')):

    calc = Vasp('NDFT/bulk=fcc/type=md/order=md0/v:a=0:8/MD={0}'.format(int(i)),
              xc='PBE',
              kpts=[9, 9, 9],
              encut=350,
              ibrion=-1,
              atoms=atoms)

    calc.calculate()
#+END_SRC

* DB
** write
#+BEGIN_SRC python
from vasp import Vasp

factor = [0.900, 0.950, 1.000, 1.050]
#cells= ['222', '223', '233', '333', '334', '344'] #'444'
cells= ['222', '223', '233', '333', '334']
#cells=['222']
calcs = []
for cell in cells:

    for x in factor:
    
        wd = './NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell={0}/factor={1:.3f}'.format(cell,x)
        
        calc = Vasp(wd)
        calcs += [calc]

[calc.write_db('database/db0/data.db', parser='=', overwrite=False) for calc in calcs]        
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []
for i in range(200):
    wd = './NDFT/bulk=fcc/type=MD0/MD={0}'.format(i)

    calc = Vasp(wd)
    calcs += [calc]
[calc.write_db('database/db0/data.db', parser='=', overwrite=False) for calc in calcs]   
#+END_SRC

#+RESULTS:

** keywords

#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

from ase.db import connect

db = connect('./database/db0/data.db')
data = db.select([])

keys, cnt = {}, 0
for entry in data:
    cnt += 1
    for k, v in entry.key_value_pairs.iteritems():
        
        if k in keys:
            keys[k] += [v]
        else:
            keys[k] = [v]

print ('{0:15s} {1:15s} {2} calculations total'.format('keyword', 'value',cnt))

print('------------------------------------------------------')

for k, v in keys.iteritems():
    vals = list(set(v))
    if len(vals) <= 5:
        val = ", ".join(str(e) for e in vals)
        print('{0:15}: {1}'.format(k, val))

    else:
        val = ", ".join(str(e)[:5] for e in vals[:5])
        print('{0:15s}:{1}, etc...'.format(k, val))
#+END_SRC

#+RESULTS:
: keyword         value           224 calculations total
: ------------------------------------------------------
: MD             :0, 1, 2, 3, 4, etc...
: train_set      : False, True
: bulk           : fcc
: lattice        : primitive
: supercell      :233, 333, 334, 344, 222, etc...
: factor         : 1.05, 0.95, 0.9, 1.0
: type           : vacancy, MD0

* Training
#+BEGIN_SRC python
from ase.db import connect
import os
import random
import numpy as np

db = connect('./database/db0/data.db')

n = db.count()
n_train = int(round(n * 0.9))

n_ids =  np.array(range(n)) + 1

# This will sudo-randomly select 10% of the calculations
# Which is useful for reproducing our results.
random.seed(256)
train_samples = random.sample(n_ids, n_train)
valid_samples = set(n_ids) - set(train_samples)

db.update(list(train_samples), train_set=True)
db.update(list(valid_samples), train_set=False)

with connect('./database/db0/train.db') as db0:
    for d in db.select(['train_set=True']):
        db0.write(d, key_value_pairs=d.key_value_pairs)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *
import os

for n in [20]:
    label = '2-{0}-test'.format(n)
    wd = os.path.join(os.getcwd(), 'database/db0/' + label)

    if not os.path.exists(wd):
        os.makedirs(wd)

    calc = Amp(label="./database/db0/{0}/".format(label),
               descriptor=Behler(cutoff=6.0),
               regression=NeuralNetwork(hiddenlayers=(2, '{0}'.format(n))))


    calc.train('./database/db0/train.db', # The training data
               cores=1,
               extend_variables=False) # feature does not work properly and will crash
#+END_SRC
#+RESULTS:


#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

# We will try an iteration for n nodes with l hidden layers.
for l in [2]:
    #for n in [15, 20, 25]:
    #for n in [10, 15, 16, 18,20, 24, 25, 30]:
    for n in [15, 16, 20, 24, 30]:
        label = '{0}-{1}-1'.format(l,n)
        layer=(l,n)
        wd = os.path.join(home, './database/db0/' + label)

        if not os.path.exists(wd):
            os.makedirs(wd)

        os.chdir(wd)

        run_amp = '''#!/usr/bin/env python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

calc = Amp(label="./",
           descriptor=Behler(cutoff=6.0),
           regression=NeuralNetwork(hiddenlayers={0}))

calc.train("~/Research/Bulk/database/db0/train.db", # The training data
           cores=1,
           extend_variables=False) 
'''.format(layer)

        cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=100:00:00
#PBS -l mem=8GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

        with open('submit.py', 'w') as f:
            f.write(run_amp)
        os.chmod('submit.py', 0777)

        with open('submit.sh', 'w') as f:
            f.write(cmd)

        subprocess.call(['qsub', 'submit.sh'])
        time.sleep(5)
        os.unlink('submit.sh')
        os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1428600.gilgamesh.cheme.cmu.edu
: 1428601.gilgamesh.cheme.cmu.edu
: 1428602.gilgamesh.cheme.cmu.edu
: 1428603.gilgamesh.cheme.cmu.edu
: 1428604.gilgamesh.cheme.cmu.edu
: 1428605.gilgamesh.cheme.cmu.edu
: 1428606.gilgamesh.cheme.cmu.edu
: 1428607.gilgamesh.cheme.cmu.edu

** Update

#+BEGIN_SRC python
from ase.db import connect
from amp import Amp

db = connect('./database/db0/data.db')
calc1 = Amp(load = './database/db0/2-20/-parameters-checkpoint-0.json')
calc2 = Amp(load = './database/db0/2-25/-parameters-checkpoint-0.json')

for d in db.select():
    atoms = db.get_atoms(d.id)
    atoms.set_calculator(calc1)
    nrg1 = atoms.get_potential_energy()

    atoms.set_calculator(calc2)
    nrg2 = atoms.get_potential_energy()
    db.update(d.id, NN20 = nrg1, NN25 = nrg2)
#+END_SRC

#+RESULTS:

** Residual
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from ase.db import connect
from amp import Amp
import os

db = connect('database/db0/data.db')

fig, ax = plt.subplots(1, 2, sharey=True, figsize=(8, 4))

for i, n in enumerate([20, 18]):

    E, nnE, var, ind = [], [], [], []
    for j, d in enumerate(db.select('')):# dbkey=0
	E += [d.energy / d.natoms]
	nnE += [d['NN{}'.format(n)]/ d.natoms]
	var += [j]
	ind += [d.train_set]

    res = np.array(nnE) - np.array(E)
    mask = np.array(ind)
    valid = np.ma.masked_array(res, mask)
    train = np.ma.masked_array(res, ~mask)
    vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
    tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))

    ax[i].text(5, -0.010,
               'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
               color='b', ha='left')
    ax[i].text(5, -0.012,
               'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
               color='r', ha='left')

    ax[i].scatter(var, train, color='b')
    ax[i].scatter(var, valid, color='r')
    ax[i].plot([min(var), max(var)], [0, 0], 'k--')
    ax[i].set_xlim(min(var), max(var))

    ax[i].set_xlabel('Calculation ID')
    ax[i].set_title('8-{0}-{0}-1 framework'.format(n))

ax[0].set_ylim(-0.015, 0.015)
ax[0].set_ylabel('Residual error (eV/atom)')
plt.tight_layout()
plt.savefig('./figures/residual-1.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/residual-1.png]]

* Application
** Vacancy formation
*** 222
     
#+BEGIN_SRC python
from jasp import *
with jasp('./DFT/relaxed=True/bulk=fcc/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    E0 = E0 * 8

with jasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=222/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E1 = atoms.get_potential_energy()
    
print E1 - E0*7/8.0
print E0
print E1
#+END_SRC

#+RESULTS:
: 1.06876678
: -41.71703416
: -35.43363811


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 2, 2)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (7/8.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  16:17:22      -35.425995       0.0000
: Vacancy formation energy with NN is: 1.233 eV
: -41.8964497535
: -35.4259953432

*** 223
     
#+BEGIN_SRC python
from jasp import *
with jasp('./DFT/relaxed=True/bulk=fcc/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    E0 = E0 * 12

with jasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=223/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E1 = atoms.get_potential_energy()
    
print E1 - E0*11/12.0
print E0
print E1
#+END_SRC

#+RESULTS:
: 1.13686192
: -62.57555124
: -56.22406005


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 2, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (11/12.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  16:01:25      -56.223696       0.0612
BFGS:   1  16:01:28      -56.223950       0.0614
BFGS:   2  16:01:34      -55.888867       1.2340
BFGS:   3  16:01:37      -56.224515       0.1683
BFGS:   4  16:01:41      -56.225162       0.0664
BFGS:   5  16:01:46      -56.223440       0.5872
BFGS:   6  16:01:49      -55.881439       1.8661
BFGS:   7  16:01:52      -56.195122       2.7989
BFGS:   8  16:01:56      -56.200861       2.8939
BFGS:   9  16:01:59      -56.147653       2.9650
BFGS:  10  16:02:04      -56.083272       0.9322
BFGS:  11  16:02:07      -56.083548       0.8520
BFGS:  12  16:02:11      -56.072413       0.1074
BFGS:  13  16:02:14      -56.072930       0.0848
BFGS:  14  16:02:19      -56.077142       0.1149
BFGS:  15  16:02:22      -56.084386       0.1064
BFGS:  16  16:02:25      -56.089207       0.0856
BFGS:  17  16:02:28      -56.090064       0.3287
BFGS:  18  16:02:32      -56.094426       0.3931
BFGS:  19  16:02:35      -56.096148       2.0402
BFGS:  20  16:02:38      -56.101788       0.1326
BFGS:  21  16:02:41      -56.102540       0.2125
BFGS:  22  16:02:44      -56.054526       5.2848
BFGS:  23  16:02:48      -56.104337       0.1582
BFGS:  24  16:02:52      -56.106317       0.1397
BFGS:  25  16:02:56      -56.110466       1.4389
BFGS:  26  16:03:00      -56.111091       0.1313
BFGS:  27  16:03:03      -56.114277       0.1625
BFGS:  28  16:03:07      -56.086505       3.8736
BFGS:  29  16:03:11      -56.116809       0.1662
BFGS:  30  16:03:14      -56.118950       0.1784
BFGS:  31  16:03:17      -56.123206       1.2603
BFGS:  32  16:03:21      -56.124143       0.2465
BFGS:  33  16:03:24      -56.125957       0.3256
BFGS:  34  16:03:27      -56.126528       0.9731
BFGS:  35  16:03:31      -56.128367       0.3836
BFGS:  36  16:03:34      -56.129191       0.3385
BFGS:  37  16:03:38      -56.131701       0.3101
BFGS:  38  16:03:41      -56.132418       0.2366
BFGS:  39  16:03:44      -56.133312       0.1430
BFGS:  40  16:03:49      -56.133836       0.1258
BFGS:  41  16:03:52      -56.134794       0.0830
BFGS:  42  16:03:55      -56.135290       0.0766
BFGS:  43  16:03:59      -56.136382       0.1018
BFGS:  44  16:04:03      -56.137074       0.1014
BFGS:  45  16:04:06      -56.140119       0.0794
BFGS:  46  16:04:09      -56.142184       0.0833
BFGS:  47  16:04:13      -56.143207       0.0508
BFGS:  48  16:04:16      -56.142751       0.2729
BFGS:  49  16:04:19      -56.142639       0.0728
BFGS:  50  16:04:22      -56.143307       0.0532
BFGS:  51  16:04:26      -56.144844       0.0418
Vacancy formation energy with NN is: 1.463 eV
-62.8446746302
-56.1448437589
#+end_example

*** 233
     
#+BEGIN_SRC python
from jasp import *
with jasp('./DFT/relaxed=True/bulk=fcc/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    E0 = E0 * 18

with jasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=233/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E1 = atoms.get_potential_energy()
    
print E1 - E0*17/18.0
print E0
print E1
#+END_SRC

#+RESULTS:
: 1.15787387
: -93.86332686
: -87.49082372


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 3, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (17/18.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  16:20:19      -87.440575       1.1271
: BFGS:   1  16:20:26      -87.453983       0.0311
: Vacancy formation energy with NN is: 1.576 eV
: -94.2670119454
: -87.4539826064

*** 333
     
#+BEGIN_SRC python
from jasp import *
with jasp('./DFT/relaxed=True/bulk=fcc/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    E0 = E0 * 27

with jasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=333/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E1 = atoms.get_potential_energy()
    
print E1 - E0*26/27.0
print E0
print E1
#+END_SRC

#+RESULTS:
: 1.10490713
: -140.79499029
: -134.47545389


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (3, 3, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (26/27.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  16:24:51     -134.477875       0.3992
BFGS:   1  16:25:09     -134.468405       0.8071
BFGS:   2  16:25:25     -134.464655       0.5516
BFGS:   3  16:25:40     -134.467827       0.3581
BFGS:   4  16:25:55     -134.429471       1.4055
BFGS:   5  16:26:11     -134.395081       5.4958
BFGS:   6  16:26:25     -134.440105       1.9102
BFGS:   7  16:26:40     -134.455258       1.4404
BFGS:   8  16:26:54     -134.286076       2.2246
BFGS:   9  16:27:09     -134.457750       0.7766
BFGS:  10  16:27:23     -134.453631       0.9435
BFGS:  11  16:27:37     -134.391792       3.5046
BFGS:  12  16:27:52     -134.457622       1.2063
BFGS:  13  16:28:06     -134.467813       0.3232
BFGS:  14  16:28:20     -134.416929       2.7551
BFGS:  15  16:28:35     -134.475881       0.1593
BFGS:  16  16:28:49     -134.479074       0.1322
BFGS:  17  16:29:03     -134.243555       5.7355
BFGS:  18  16:29:18     -134.481547       0.0978
BFGS:  19  16:29:32     -134.483571       0.0799
BFGS:  20  16:29:46     -134.520602       0.3048
BFGS:  21  16:30:01     -134.278988       4.6688
BFGS:  22  16:30:15     -134.527945       4.1324
BFGS:  23  16:30:29     -134.512940       0.1768
BFGS:  24  16:30:44     -134.526350       0.2272
BFGS:  25  16:30:59     -134.496047       2.0505
BFGS:  26  16:31:13     -134.546638       0.4713
BFGS:  27  16:31:27     -134.561798       0.5825
BFGS:  28  16:31:41     -134.056127       5.7977
BFGS:  29  16:31:56     -134.567987       0.8830
BFGS:  30  16:32:10     -134.561362       1.0052
BFGS:  31  16:32:24     -134.388341       2.9986
BFGS:  32  16:32:39     -134.523007       0.9711
BFGS:  33  16:32:53     -134.507802       0.5886
BFGS:  34  16:33:08     -134.460927       1.5441
BFGS:  35  16:33:22     -134.478955       0.3877
BFGS:  36  16:33:37     -134.483606       0.2983
BFGS:  37  16:33:51     -134.409312       3.3928
BFGS:  38  16:34:06     -134.492459       0.3363
BFGS:  39  16:34:21     -134.497496       0.3425
BFGS:  40  16:34:36     -134.452054      10.4915
BFGS:  41  16:34:51     -134.504803       0.3159
BFGS:  42  16:35:06     -134.507730       0.6701
BFGS:  43  16:35:21     -134.510506       1.3799
BFGS:  44  16:35:35     -134.529125       0.7931
BFGS:  45  16:35:50     -134.556153       1.6488
BFGS:  46  16:36:05     -134.673846       1.5687
BFGS:  47  16:36:20     -134.266504       9.3334
BFGS:  48  16:36:34     -134.703085       0.6334
BFGS:  49  16:36:49     -134.706754       0.2829
BFGS:  50  16:37:04     -134.711601       0.0826
BFGS:  51  16:37:19     -134.713086       1.0839
BFGS:  52  16:37:34     -134.716229       0.1208
BFGS:  53  16:37:49     -134.718122       0.1076
BFGS:  54  16:38:03     -134.710053       1.1629
BFGS:  55  16:38:18     -134.720366       0.1541
BFGS:  56  16:38:33     -134.721177       0.1858
BFGS:  57  16:38:48     -134.321413       9.8658
BFGS:  58  16:39:03     -134.723118       0.1084
BFGS:  59  16:39:18     -134.723746       0.0811
BFGS:  60  16:39:32     -134.724334       0.3969
BFGS:  61  16:39:47     -134.724603       0.3455
BFGS:  62  16:40:02     -134.725103       0.1563
BFGS:  63  16:40:17     -134.725705       0.0778
BFGS:  64  16:40:32     -134.726632       0.0702
BFGS:  65  16:40:47     -134.727600       0.1388
BFGS:  66  16:41:02     -134.727469       0.3088
BFGS:  67  16:41:17     -134.727953       0.1155
BFGS:  68  16:41:31     -134.728402       0.0425
Vacancy formation energy with NN is: 1.435 eV
-141.400517918
-134.728401597
#+end_example

** MD
*** Bulk
**** 2000
#+BEGIN_SRC python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

# Set up a crystal
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 2, 2))

# Describe the interatomic interactions with the Effective Medium Theory
atoms.set_calculator(Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json'))
# We want to run MD with constant energy using the Langevin algorithm
# with a time step of 5 fs, the temperature T and the friction
# coefficient to 0.02 atomic units.
dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):  # store a reference to atoms in the definition.
    """Function to print the potential, kinetic and total energy."""
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

# We also want to save the positions of all atoms after every time step.
traj = Trajectory('./database/db0/MD.traj', 'w', atoms)
dyn.attach(traj.write, interval=10)

# Now run the dynamics
dyn.run(2000)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
import jbtools.gilgamesh as jb

Ne = []
for i, atoms in enumerate(Trajectory('./database/db0/MD.traj', 'r')):

    Ne += [atoms.get_potential_energy()]

plt.plot(range(len(Ne)), Ne, 'bo')
#plt.savefig('./images/MD-NN.png')
plt.show()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db0/2-20/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db0/MD.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
#plt.show()
plt.xlabel('MD Step')
plt.ylabel('Energy eV')
plt.legend()
plt.savefig('./figures/MD-1.png')

#+END_SRC

#+RESULTS:

[[./figures/MD-1.png]]
**** 4000
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db0')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 2, 2))

atoms.set_calculator(Amp(load="./2-18/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=20)

traj = Trajectory("./MD-0:8.traj", "w", atoms)
dyn.attach(traj.write, interval=20)

dyn.run(4000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=8GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('0:8')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1429517.gilgamesh.cheme.cmu.edu
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db0/2-20/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db0/MD-0:8.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
#plt.show()
plt.xlabel('MD Step')
plt.ylabel('Energy eV')
plt.legend()
plt.savefig('./figures/0:8-md1.png')
#plt.show()

#+END_SRC

#+RESULTS:

[[./figures/0:8-md1.png]]

*** Vacancy
**** 1:8
#+BEGIN_SRC python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

# Set up a crystal
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 2, 2))

del atoms[0]
# Describe the interatomic interactions with the Effective Medium Theory
atoms.set_calculator(Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json'))
# We want to run MD with constant energy using the Langevin algorithm
# with a time step of 5 fs, the temperature T and the friction
# coefficient to 0.02 atomic units.
dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):  # store a reference to atoms in the definition.
    """Function to print the potential, kinetic and total energy."""
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

# We also want to save the positions of all atoms after every time step.
traj = Trajectory('./database/db0/MD-1:8.traj', 'w', atoms)
dyn.attach(traj.write, interval=10)

# Now run the dynamics
dyn.run(2000)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db0/2-20/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db0/MD-1:8.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,100])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/MD-2.png')
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne,Ne0, nrg, res, s = [], [], [], [], []
calcs = []
images = Trajectory('./database/db0/MD-1:8.traj', 'r')
Ne0 = [images[i].get_potential_energy() for i in range(0, 200)]
for i in np.arange(0, len(images), 4):
    if i != 60:
        Ne +=[Ne0[i]]
        
        calc = Vasp('NDFT/bulk=fcc/type=MD1/MD={}'.format(i),
                     xc='pbe',
                     kpts=[5]*3,
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)

#res = [r for i, r in enumerate(Ne) if i in
#       np.arange(0, len(images), 4) and i != 60]
res = abs(np.array(Ne) - np.array(nrg))

fig, ax = plt.subplots(figsize=(6, 4))
ax.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
ax.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='b', label='DFT prediction')

#ax.set_xlim(min(s), max(s))
ax.set_ylabel('Potential energy (eV)', color='b')
ax.tick_params(axis='y', colors='b')
#ax.set_ylim(-141, -130)
ax.set_xlabel('Time step')
ax.legend(loc=2)

ax1 = ax.twinx()

ax1.scatter(range(len(res)), res, color='r')
ax1.set_ylabel('Absolute residual error (eV)', color='r')
#ax1.set_xlim(min(s), max(s))
ax1.tick_params(axis='y', colors='r')
ax1.set_ylim(0.0, 7.0)

plt.tight_layout()
plt.show()
#+END_SRC

#+RESULTS:

The energy of MD=60 is too high to calculate.

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db0/MD-1:8.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(0, 50)]

calcs = [Vasp('NDFT/bulk=fcc/type=md/order=md1/v:a=1:7/MD={}'.format(i),
            xc='pbe',
            kpts=[9]*3,
            encut=350,
            nsw=0,
            atoms=images[i]) for i in range(50)]

[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)

#res = [r for i, r in enumerate(Ne) if i in
#       np.arange(0, len(images), 4) and i != 60]
res = abs(np.array(Ne) - np.array(nrg))

fig, ax = plt.subplots(figsize=(6, 4))
ax.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
ax.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='b', label='DFT prediction')

#ax.set_xlim(min(s), max(s))
ax.set_ylabel('Potential energy (eV)', color='b')
ax.tick_params(axis='y', colors='b')
#ax.set_ylim(-141, -130)
ax.set_xlabel('Time step')
ax.legend(loc=2)

ax1 = ax.twinx()

ax1.scatter(range(len(res)), res, color='r')
ax1.set_ylabel('Absolute residual error (eV)', color='r')
#ax1.set_xlim(min(s), max(s))
ax1.tick_params(axis='y', colors='r')
ax1.set_ylim(0.0, 7.0)

plt.tight_layout()
plt.show()
#+END_SRC

#+RESULTS:

**** 1:12
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db0')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 2, 3))

del atoms[0]

atoms.set_calculator(Amp(load="./2-18/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=5)

traj = Trajectory("./MD-1:12.traj", "w", atoms)
dyn.attach(traj.write, interval=5)

dyn.run(500)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=8GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('1:12')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1429794.gilgamesh.cheme.cmu.edu

**** 1:18
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db0')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 3, 3))

del atoms[0]

atoms.set_calculator(Amp(load="./2-18/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=5)

traj = Trajectory("./MD-1:18.traj", "w", atoms)
dyn.attach(traj.write, interval=5)

dyn.run(200)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=8GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('1:18')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC
#+RESULTS:
: 1429515.gilgamesh.cheme.cmu.edu

**** 1:27
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db0')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(3, 3, 3))

del atoms[0]

atoms.set_calculator(Amp(load="./2-18/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=5)

traj = Trajectory("./MD-1:27.traj", "w", atoms)
dyn.attach(traj.write, interval=5)

dyn.run(100)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=8GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1429514.gilgamesh.cheme.cmu.edu

**** 1:36
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db0')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(3, 3, 4))

del atoms[0]

atoms.set_calculator(Amp(load="./2-18/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=5)

traj = Trajectory("./MD-1:36.traj", "w", atoms)
dyn.attach(traj.write, interval=5)

dyn.run(50)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=8GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1429513.gilgamesh.cheme.cmu.edu

**** 1:48
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db0')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(3, 4, 4))

del atoms[0]

atoms.set_calculator(Amp(load="./2-18/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=5)

traj = Trajectory("./MD-1:48.traj", "w", atoms)
dyn.attach(traj.write, interval=5)

dyn.run(50)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=8GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1429512.gilgamesh.cheme.cmu.edu

**** 1:64
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db0')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(4, 4, 4))

del atoms[0]

atoms.set_calculator(Amp(load="./2-18/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=5)

traj = Trajectory("./MD-1:64.traj", "w", atoms)
dyn.attach(traj.write, interval=5)

dyn.run(50)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=8GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1429511.gilgamesh.cheme.cmu.edu


* 2nd DFT
** Bulk
*** fcc
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
VASPRC['queue.walltime'] = '24:00:00'

# Fraction of equilibrium lattice constant to be calculated
factor = np.append(np.arange(0.85, 1.2, 0.01),
                   np.arange(1.2, 2.125, 0.05))
#factor = np.delete(factor, 15)

fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)

nrg, calcs = [], []
for f in factor:
    atoms = fcc.copy()

    delta = np.array([[f, 0., 0.],
                      [0., f, 0.],
                      [0., 0., f]])
    atoms.set_cell(np.dot(atoms.get_cell(), delta),
                   scale_atoms=True)

    calc = Vasp('./NDFT/bulk=fcc/type=eos/factor={:.2f}'.format(f),
                xc='pbe',
                kpts=[14]*3,
                encut=350,
                nsw=0,
                atoms=atoms)
    calcs += [calc]
    nrg += [calc.potential_energy]
Vasp.stop_if(None in nrg)

plt.plot(factor, nrg)

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=eos/factor=1.00 submitted: 1443243.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=eos/factor=1.00 Queued: 1443243.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
from ase.db import connect
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState
from ase.units import kJ
import numpy as np
from vasp import Vasp

nrg, t, vol = [], [], []

factor = np.arange(0.85, 1.2, 0.01)
             #      np.arange(1.2, 2.125, 0.05))


for f in factor:
    calc = Vasp('./NDFT/bulk=fcc/type=eos/factor={:.2f}'.format(f))
    atoms = calc.get_atoms()
    nrg += [atoms.get_potential_energy()]
    vol += [atoms.get_volume()]

vol = np.array(vol)
nrg = np.array(nrg)

# Fit the data to SJEOS
eos = EquationOfState(vol, nrg)
v0, e0, B = eos.fit()

x = np.linspace(vol.min(), vol.max(), 250)

plt.scatter(vol, nrg, color='r')
plt.plot(x, eos.fit0(x**-(1.0 / 3)), 'b-')

plt.xlim(vol.min(), vol.max())
plt.ylabel('Potential energy (eV)')

plt.text(vol.max() - 6, nrg.max(),
	 'V$_{0}$={1:1.3f}'.format('{min}', v0),
	 va='center', ha='left')
plt.text(vol.max() - 6, nrg.max() - 0.3,
	 'E$_{0}$={1:1.3f}'.format('{min}', e0),
	 va='center', ha='left')
plt.text(vol.max() - 6, nrg.max() - 0.6,
	 #'B={0:1.0f}'.format(B  / kJ * 1.0e24),
         'B={0:1.3f}'.format(B),
	 va='center', ha='left')


plt.xlabel('Volume ($\AA^{3}$/atom)')
plt.tight_layout()
plt.savefig('./figures/eosfcc.png')
#+END_SRC

#+RESULTS:

[[./figures/eosfcc.png]]

#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState

# Fraction of equilibrium lattice constant to be calculated
factor = np.append(np.arange(0.85, 1.2, 0.01),
                   np.arange(1.2, 2.125, 0.05))
factor = np.delete(factor, 15)

nrg, vol = [], []

for f in factor:
    calc = Vasp('./NDFT/bulk=fcc/type=eos/factor={:.2f}'.format(f))
    atoms = calc.get_atoms()
    nrg += [atoms.get_potential_energy()]
    vol += [atoms.get_volume()]

eos = EquationOfState(vol, nrg)
v0, e0, B0 = eos.fit()
eos.plot('./figures/eos-fcc.png')

ind = np.argmin(nrg)
print 3.939 * factor[ind]
#+END_SRC

#+RESULTS:
: 3.97839


[[./figures/eos-fcc.png]]
**** cutoff
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
VASPRC['queue.walltime'] = '24:00:00'

# Fraction of equilibrium lattice constant to be calculated
factor = np.arange(2.1, 2.6, 0.05)

fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


nrg, calcs = [], []

for f in factor:
    atoms = fcc.copy()

    delta = np.array([[f, 0., 0.],
                      [0., f, 0.],
                      [0., 0., f]])
    atoms.set_cell(np.dot(atoms.get_cell(), delta),
                   scale_atoms=True)

    calc = Vasp('./NDFT/bulk=fcc/type=test/factor={:.2f}'.format(f),
                xc='pbe',
                kpts=[14]*3,
                encut=350,
                nsw=0,
                atoms=atoms)
    calcs += [calc]
    nrg += [calc.potential_energy]


#+END_SRC

#+RESULTS:
#+begin_example
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.10 submitted: 1443893.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.10 Queued: 1443893.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.15 submitted: 1443894.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.15 Queued: 1443894.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.20 submitted: 1443895.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.20 Queued: 1443895.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.25 submitted: 1443896.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.25 Queued: 1443896.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.30 submitted: 1443897.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.30 Queued: 1443897.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.35 submitted: 1443898.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.35 Queued: 1443898.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.40 submitted: 1443899.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.40 Queued: 1443899.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.45 submitted: 1443900.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.45 Queued: 1443900.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.50 submitted: 1443901.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.50 Queued: 1443901.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.55 submitted: 1443902.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/factor=2.55 Queued: 1443902.gilgamesh.cheme.cmu.edu
#+end_example

*** bcc
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
import numpy as np
from ase.lattice.cubic import BodyCenteredCubic
import matplotlib.pyplot as plt
VASPRC['queue.walltime'] = '24:00:00'

# Fraction of equilibrium lattice constant to be calculated
factor = np.append(np.arange(0.85, 1.2, 0.01),
                   np.arange(1.2, 2.125, 0.05))

bcc = BodyCenteredCubic('Pd',
                        directions=[[-1, 1, 1],
                                    [1, -1, 1],
                                    [1, 1, -1]],
                        latticeconstant = 3.136)

nrg, calcs = [], []
for f in factor:
    atoms = bcc.copy()

    delta = np.array([[f, 0., 0.],
                      [0., f, 0.],
                      [0., 0., f]])
    atoms.set_cell(np.dot(atoms.get_cell(), delta),
                   scale_atoms=True)

    calc = Vasp('./NDFT/bulk=bcc/type=eos/factor={:.2f}'.format(f),
                xc='pbe',
                kpts=[14]*3,
                encut=350,
                nsw=0,
                atoms=atoms)
    calcs += [calc]
    nrg += [calc.potential_energy]
Vasp.stop_if(None in nrg)

plt.plot(factor, nrg)
plt.show()
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=bcc/type=eos/factor=1.00 submitted: 1443249.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=bcc/type=eos/factor=1.00 Queued: 1443249.gilgamesh.cheme.cmu.edu

*** hcp
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
import numpy as np
from ase.lattice.hexagonal import HexagonalClosedPacked
import matplotlib.pyplot as plt
VASPRC['queue.walltime'] = '24:00:00'

# Fraction of equilibrium lattice constant to be calculated
factor = np.append(np.arange(0.85, 1.2, 0.01),
                   np.arange(1.2, 2.125, 0.05))


hcp = HexagonalClosedPacked('Pd',
                            latticeconstant = {'a':2.767, 'c/a':1.674})

nrg, calcs = [], []
for f in factor:
    atoms = hcp.copy()

    delta = np.array([[f, 0., 0.],
                      [0., f, 0.],
                      [0., 0., f]])
    atoms.set_cell(np.dot(atoms.get_cell(), delta),
                   scale_atoms=True)

    calc = Vasp('./NDFT/bulk=hcp/type=eos/factor={:.2f}'.format(f),
                xc='pbe',
                kpts=[14]*3,
                encut=350,
                nsw=0,
                atoms=atoms)
    calcs += [calc]
    nrg += [calc.potential_energy]
Vasp.stop_if(None in nrg)

plt.plot(factor, nrg)
plt.show()
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=hcp/type=eos/factor=1.00 submitted: 1443253.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=hcp/type=eos/factor=1.00 Queued: 1443253.gilgamesh.cheme.cmu.edu

*** sc
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
import numpy as np
from ase.lattice.cubic import SimpleCubic
import matplotlib.pyplot as plt
VASPRC['queue.walltime'] = '24:00:00'

# Fraction of equilibrium lattice constant to be calculated
factor = np.append(np.arange(0.85, 1.2, 0.01),
                   np.arange(1.2, 2.125, 0.05))

sc = SimpleCubic('Pd',
                  latticeconstant=2.612)

nrg, calcs = [], []
for f in factor:
    atoms = sc.copy()

    delta = np.array([[f, 0., 0.],
                      [0., f, 0.],
                      [0., 0., f]])
    atoms.set_cell(np.dot(atoms.get_cell(), delta),
                   scale_atoms=True)

    calc = Vasp('./NDFT/bulk=sc/type=eos/factor={:.2f}'.format(f),
                xc='pbe',
                kpts=[14]*3,
                encut=350,
                nsw=0,
                atoms=atoms)
    calcs += [calc]
    nrg += [calc.potential_energy]
Vasp.stop_if(None in nrg)

plt.plot(factor, nrg)
plt.show()
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=sc/type=eos/factor=1.00 submitted: 1443254.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=sc/type=eos/factor=1.00 Queued: 1443254.gilgamesh.cheme.cmu.edu

*** diam
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
import numpy as np
from ase.lattice.cubic import Diamond
import matplotlib.pyplot as plt
VASPRC['queue.walltime'] = '24:00:00'

# Fraction of equilibrium lattice constant to be calculated
#factor = np.append(np.arange(0.85, 1.2, 0.01),
#                   np.arange(1.2, 2.125, 0.05))
factor = [1.00]

diam = Diamond('Pd',
                latticeconstant=5.800)

nrg, calcs = [], []
for f in factor:
    atoms = diam.copy()

    delta = np.array([[f, 0., 0.],
                      [0., f, 0.],
                      [0., 0., f]])
    atoms.set_cell(np.dot(atoms.get_cell(), delta),
                   scale_atoms=True)

    calc = Vasp('./NDFT/bulk=diam/type=eos/factor={:.2f}'.format(f),
                xc='pbe',
                kpts=[9]*3,
                encut=350,
                nsw=0,
                atoms=atoms)
    calcs += [calc]
    nrg += [calc.potential_energy]
Vasp.stop_if(None in nrg)

plt.plot(factor, nrg)
plt.show()

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=diam/type=eos/factor=1.00 submitted: 1443255.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=diam/type=eos/factor=1.00 Queued: 1443255.gilgamesh.cheme.cmu.edu

*** all
#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState
from ase.units import kJ


factor = np.append(np.arange(0.85, 1.2, 0.01),
                   np.arange(1.2, 2.125, 0.05))
factor = np.delete(factor, 15)

E_fcc, E_bcc, E_hcp, E_sc, E_diamond = [], [], [], [], []
Energy = [E_fcc, E_bcc, E_hcp, E_sc, E_diamond]

V_fcc, V_bcc, V_hcp, V_sc, V_diamond = [], [], [], [], []
Volume = [V_fcc, V_bcc, V_hcp, V_sc, V_diamond]

structure = ['fcc', 'bcc', 'hcp', 'sc','diam']

for i, struc in enumerate(structure):
    
    for j,x in enumerate(factor):
        wd = 'NDFT/bulk={0}/type=eos/factor={1:1.2f}'.format(struc,x)

        calc = Vasp(wd)
        atoms = calc.get_atoms()

        Energy[i].append(atoms.get_potential_energy()/len(atoms))
        Volume[i].append(atoms.get_volume()/len(atoms))

'''
if ready:
    for i in range (4):
        eos = EquationOfState(Volume[i], Energy[i])
        eos.plot('images/eos-{0}.png'.format(structure[i]))
     
'''

for i in range(5):
    plt.plot(Volume[i], Energy[i], label='{0}'.format(structure[i]))
    plt.legend()
    plt.xlim([5, 40])
    plt.xlabel('Volume $\AA^3$/Atom')
    plt.ylabel('Energy eV/Atom')
    
    eos = EquationOfState(Volume[i], Energy[i])
    v0, e0, B = eos.fit()
    print v0
plt.savefig('figures/eos-DFT.png')
            

#+END_SRC

#+RESULTS:
: 16.1590488245
: 16.2672564781
: 16.2287594512
: 18.706797844
: 25.477211224

[[./figures/eos-DFT.png]]
#+BEGIN_SRC python
from ase.db import connect
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState
from ase.units import kJ
import numpy as np
from vasp import Vasp

factor = np.arange(0.85, 1.2, 0.01)
             #      np.arange(1.2, 2.125, 0.05))
configs = ['fcc', 'bcc', 'hcp', 'sc', 'diam']

for config in configs:
    nrg, vol = [], []
    for f in factor:
        calc = Vasp('./NDFT/bulk={0}/type=eos/factor={1:.2f}'.format(config,f))
        atoms = calc.get_atoms()
        nrg += [atoms.get_potential_energy()]
        vol += [atoms.get_volume()]

    vol = np.array(vol)
    nrg = np.array(nrg)

# Fit the data to SJEOS
    eos = EquationOfState(vol, nrg)
    v0, e0, B = eos.fit()
    print '{0}'.format(config)
    print v0, e0, B
#+END_SRC

#+RESULTS:
#+begin_example
fcc
15.2979724806 -5.22438476072 1.09507457295
bcc
15.4257962561 -5.18249419589 1.06469804063
hcp
30.7291538438 -10.3875916525 1.08254355793
sc
17.8024966568 -4.72110919112 0.782438954048
diam
194.846481429 -32.6504639127 0.428150007251
#+end_example

** MD
*** 0:8
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
from vasp import Vasp
from vasp.vasprc import VASPRC

VASPRC['queue.walltime'] = '24:00:00'

calc1 = Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db0/2-20/-parameters-checkpoint-0.json')
images = Trajectory('./database/db0/MD-0:8.traj', 'r')
E1, E2 = [], []

for atoms in images:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in images:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)
res = E1-E2
res = np.array(res)
x = np.absolute(res)
t = []

for i in range(len(x)):
    if x[i] > 0.002:
        t += [i]



Ne, nrg, res, s = [], [], [], []
calcs = []

Ne = [images[i].get_potential_energy() for i in t]

for i in t:        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=0_8/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9]*3,
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy/8.0 for calc in calcs]
Vasp.stop_if(None in nrg)

plt.plot(range(len(E1)), E1, 'b-', label='NN prediction')
plt.plot(range(len(E2)), E2, 'r--', label='NN prediction')
plt.scatter(t, nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(E1)))
plt.ylabel('Potential energy (eV)')

plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/0-8md-1.png')

#+END_SRC

#+RESULTS:

[[./figures/0-8md-1.png]]
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
from vasp import Vasp
from vasp.vasprc import VASPRC

VASPRC['queue.walltime'] = '24:00:00'

images = Trajectory('./database/db0/MD-0:8.traj', 'r')

calcs = []
Ne = [images[i].get_potential_energy() for i in range(200)]

for i in range(200):        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=0_8/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9]*3,
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy/8.0 for calc in calcs]
Vasp.stop_if(None in nrg)

plt.plot(range(len(Ne)), E1, 'b-', label='NN prediction')
plt.scatter(t, nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(E1)))
plt.ylabel('Potential energy (eV)')

plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.show()

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory

from vasp import Vasp
from vasp.vasprc import VASPRC

VASPRC['queue.walltime'] = '24:00:00'
calcs = []
for i in range(200):        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=0_8/MD={}'.format(i))
        calcs +=[calc] 
        calc.set_memory()
        calc.calculate()

#+END_SRC
#+RESULTS:

*** 1:7
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db0/MD-1:8.traj', 'r')
#Ne = [images[i].get_potential_energy() for i in range(0, 100)]
Ne = [images[i].get_potential_energy() for i in range(0, 51)]
#for i in np.arange(0, 100, 4):
for i in range(51):        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_7/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9]*3,
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)

plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-7md-1.png')
#+END_SRC

#+RESULTS:

[[./figures/1-7md-1.png]]

*** 1:11
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne,Ne0, nrg, res, s = [], [], [], [], []
calcs = []
images = Trajectory('./database/db0/MD-1:12.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(0, 22)]
for i in np.arange(0, 22):

        calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_11/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9,9,5],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)

plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-11md-1.png')
#+END_SRC

#+RESULTS:

[[./figures/1-11md-1.png]]

*** 1:17
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db0/MD-1:18.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(38)]
for i in np.arange(0, 38):
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_17/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9, 5, 5],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)

plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-17md-1.png')
#+END_SRC

#+RESULTS:

[[./figures/1-17md-1.png]]
*** 1:26
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db0/MD-1:27.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(16)]
for i in np.arange(0, 16):
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_26/MD={}'.format(i),
                     xc='pbe',
                     kpts=[5, 5, 5],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)


plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-26md-1.png')
#+END_SRC

#+RESULTS:

[[./figures/1-26md-1.png]]

*** 1:35
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db0/MD-1:36.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(0, len(images))]
for i in np.arange(0, len(images)):
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_35/MD={}'.format(i),
                     xc='pbe',
                     kpts=[5, 5, 3],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)


plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-35md-1.png')
#+END_SRC

#+RESULTS:

[[./figures/1-35md-1.png]]
*** 1:47
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db0/MD-1:48.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(0, len(images))]
for i in np.arange(0, len(images)):
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_47/MD={}'.format(i),
                     xc='pbe',
                     kpts=[5, 3, 3],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)


plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-47md-1.png')
#+END_SRC

#+RESULTS:

[[./figures/1-47md-1.png]]

*** 1:63
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db0/MD-1:64.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(0, len(images))]
for i in np.arange(0, len(images)):
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_63/MD={}'.format(i),
                     xc='pbe',
                     kpts=[3, 3, 3],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)

plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-63md-1.png')
#+END_SRC

#+RESULTS:

[[./figures/1-63md-1.png]]

** Vacancy Diffusion NEB
*** 2*2*2
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '8GB'
VASPRC['wall.time'] = '24:00:00'
fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 2, 2])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb-initial',
          xc='pbe',
          kpts=[9, 9, 9],
          encut=350,
          atoms=ini)

fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb-final',
            xc='pbe',
            kpts=[9, 9, 9],
            encut=350,
            atoms=fin)

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb',
            xc='pbe',
            kpts=[9, 9, 9],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/222-NEB.png')
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.675637
:          Iterations: 15
:          Function evaluations: 30

[[./figures/NEB-7.png]]

#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d
from ase.calculators.singlepoint import SinglePointCalculator as SPC

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
images, energies = calc.get_neb()

En, E = [], []
calc2 = Amp('./database/db1/2-24-2/-parameters-checkpoint-0.json')

for atoms in images:
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

En = np.array(En)
E = En-En[0]
x = range(len(images))
xarray = np.linspace(0, len(images))
f1 = interp1d(x, energies, kind='cubic', bounds_error=False)
f2 = interp1d(x, E, kind='cubic', bounds_error=False)
plt.plot(x, energies, 'bo', label = 'NEB')
plt.plot(x, E, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')

plt.savefig('./figures/NEB-NN-222.png')

#+END_SRC

#+RESULTS:

[[./figures/NEB-NN-222.png]]
#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
from ase.calculators.singlepoint import SinglePointCalculator as SPC
from ase.db import connect

db = connect('database/db2/data.db')
E0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb-initial').potential_energy
E = []
calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
images, energies = calc.get_neb()


[atoms.set_calculator(SPC(atoms, energy=energies[i]))
for i, atoms in enumerate(images)]

for i, atoms in enumerate(images):
    E += [atoms.get_potential_energy()+E0]

for i, image in enumerate (images):

    db.write(atoms, {'bulk':'fcc', 'dbkey':2, 'type':'neb', 'supercell':222})
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d
from ase.calculators.singlepoint import SinglePointCalculator as SPC

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
calc.view()
#+END_SRC

#+RESULTS:

**** MD for NEB
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db1')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from vasp import Vasp

calc = Vasp("../../NDFT/bulk=fcc/type=neb/supercell=222/neb")
images, energies = calc.get_neb()


atoms = images[4]

atoms.set_calculator(Amp(load="./2-24-2/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MDimage4.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('image4')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1444076.gilgamesh.cheme.cmu.edu

*** 2*2*3
c0-end
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['wall.time'] = '24:00:00'
fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 2, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-initial',
          xc='pbe',
          kpts=[9, 9, 5],
          encut=350,
          atoms=ini)
c0.calculate()
fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-final',
            xc='pbe',
            kpts=[9, 9, 5],
            encut=350,
            atoms=fin)
cend.calculate()
#+END_SRC

#+RESULTS:
: No calculation_required.
: No calculation_required.


#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '8GB'

fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 2, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-initial',
          xc='pbe',
          kpts=[9, 9, 5],
          encut=350,
          atoms=ini)

fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-final',
            xc='pbe',
            kpts=[9, 9, 5],
            encut=350,
            atoms=fin)

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb',
            xc='pbe',
            kpts=[9, 9, 5],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/223-NEB.png')
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.752733
:          Iterations: 15
:          Function evaluations: 30

[[./figures/223-NEB.png]]
#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb')
images, energies = calc.get_neb()
En, E = [], []
calc2 = Amp('./database/db1/2-24-2/-parameters-checkpoint-0.json')

for atoms in images:
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

En = np.array(En)
E = En-En[0]
x = range(len(images))
xarray = np.linspace(0, len(images))
f1 = interp1d(x, energies, kind='cubic', bounds_error=False)
f2 = interp1d(x, E, kind='cubic', bounds_error=False)
plt.plot(x, energies, 'bo', label = 'NEB')
plt.plot(x, E, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')

plt.savefig('./figures/NEB-NN-223.png')
#+END_SRC

#+RESULTS:

[[./figures/NEB-NN-223.png]]

**** MD
#+BEGIN_SRC python
,#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

for n in [1, 2, 3, 4]:
    label = '223-Image{0}'.format(n)
    wd = os.path.join(home, './database/db1/' + label)

    if not os.path.exists(wd):
        os.makedirs(wd)

    os.chdir(wd)
    run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from vasp import Vasp

calc = Vasp("../../../NDFT/bulk=fcc/type=neb/supercell=223/neb")
images, energies = calc.get_neb()


atoms = images[{0}]

atoms.set_calculator(Amp(load="../2-24-2/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./{1}.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''.format(n, label)

    cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

    with open('submit.py', 'w') as f:
        f.write(run_md)
    os.chmod('submit.py', 0777)

    with open('submit.sh', 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', 'submit.sh'])
    time.sleep(5)
    os.unlink('submit.sh')
    os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1444078.gilgamesh.cheme.cmu.edu
: 1444079.gilgamesh.cheme.cmu.edu
: 1444080.gilgamesh.cheme.cmu.edu
: 1444081.gilgamesh.cheme.cmu.edu

#+END_SRC
**** test
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['wall.time'] = '24:00:00'
fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 2, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=test/supercell=223/neb-initial',
          xc='pbe',
          kpts=[9, 9, 5],
          encut=350,
          atoms=ini)
c0.calculate()
fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=test/supercell=223/neb-final',
            xc='pbe',
            kpts=[9, 9, 5],
            encut=350,
            atoms=fin)
cend.calculate()
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/supercell=223/neb-initial submitted: 1447139.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/supercell=223/neb-final submitted: 1447140.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python

from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '8GB'

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=test/supercell=223/neb-initial')
ini = c0.get_atoms()

cend = Vasp('NDFT/bulk=fcc/type=test/supercell=223/neb-final')
fin = cend.get_atoms()

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=test/supercell=223/neb',
            xc='pbe',
            kpts=[9, 9, 5],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/223-NEB-test.png')
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.752733
:          Iterations: 15
:          Function evaluations: 30

[[./figures/223-NEB-test.png]]
*** 2*3*3
c0-end
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['wall.time'] = '24:00:00'
fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 3, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-initial',
          xc='pbe',
          kpts=[9, 5, 5],
          encut=350,
          atoms=ini)
c0.calculate()
fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-final',
            xc='pbe',
            kpts=[9, 5, 5],
            encut=350,
            atoms=fin)
cend.calculate()
#+END_SRC

#+RESULTS:
: No calculation_required.
: No calculation_required.


#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '8GB'


# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-initial')
ini = c0.get_atoms()

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-final')
fin = cend.get_atoms()

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb',
            xc='pbe',
            kpts=[9, 5, 5],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/233-NEB.png')
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.711185
:          Iterations: 15
:          Function evaluations: 30

[[./figures/233-NEB.png]]

#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb')
images, energies = calc.get_neb()
En, E = [], []
calc2 = Amp('./database/db1/2-24-2/-parameters-checkpoint-0.json')

for atoms in images:
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

En = np.array(En)
E = En-En[0]
x = range(len(images))
xarray = np.linspace(0, len(images))
f1 = interp1d(x, energies, kind='cubic', bounds_error=False)
f2 = interp1d(x, E, kind='cubic', bounds_error=False)
plt.plot(x, energies, 'bo', label = 'NEB')
plt.plot(x, E, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')

plt.savefig('./figures/NEB-NN-233.png')
#+END_SRC

#+RESULTS:

[[./figures/NEB-NN-233.png]]
*** 3*3*3
c0-end
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
				    latticeconstant = 3.939)


atoms = fcc.repeat([3, 3, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb-initial',
          xc='pbe',
          kpts=[5, 5, 5],
          encut=350,
          atoms=ini)
c0.calculate()
fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb-final',
            xc='pbe',
            kpts=[5, 5, 5],
            encut=350,
            atoms=fin)
cend.calculate()
#+END_SRC

#+RESULTS:
: No calculation_required.
: No calculation_required.


#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '8GB'


# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb-initial')
ini = c0.get_atoms()

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb-final')
fin = cend.get_atoms()

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb',
            xc='pbe',
            kpts=[5, 5, 5],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/333-NEB.png')
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.745283
:          Iterations: 15
:          Function evaluations: 30

[[./images/333-NEB.png]]

#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d
from ase.calculators.singlepoint import SinglePointCalculator as SPC

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb')
images, energies = calc.get_neb()

En, E = [], []
calc2 = Amp('./database/db1/2-24-2/-parameters-checkpoint-0.json')

for atoms in images:
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

En = np.array(En)
E = En-En[0]
x = range(len(images))
xarray = np.linspace(0, len(images))
f1 = interp1d(x, energies, kind='cubic', bounds_error=False)
f2 = interp1d(x, E, kind='cubic', bounds_error=False)
plt.plot(x, energies, 'bo', label = 'NEB')
plt.plot(x, E, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')

plt.savefig('./figures/NEB-NN-333.png')

#+END_SRC

#+RESULTS:

[[./figures/NEB-NN-333.png]]

**** MD
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

for n in [1, 2, 3, 4]:
    label = '333-Image{0}'.format(n)
    wd = os.path.join(home, './database/db1/' + label)

    if not os.path.exists(wd):
        os.makedirs(wd)

    os.chdir(wd)
    run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from vasp import Vasp

calc = Vasp("../../../NDFT/bulk=fcc/type=neb/supercell=223/neb")
images, energies = calc.get_neb()


atoms = images[{0}]

atoms.set_calculator(Amp(load="../2-24-2/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./{1}.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''.format(n, label)

    cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

    with open('submit.py', 'w') as f:
        f.write(run_md)
    os.chmod('submit.py', 0777)

    with open('submit.sh', 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', 'submit.sh'])
    time.sleep(5)
    os.unlink('submit.sh')
    os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1446868.gilgamesh.cheme.cmu.edu
: 1446869.gilgamesh.cheme.cmu.edu
: 1446870.gilgamesh.cheme.cmu.edu
: 1446871.gilgamesh.cheme.cmu.edu

#+END_SRC
*** Comparison
#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d
from ase.calculators.singlepoint import SinglePointCalculator as SPC

calc1 = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
images1, energies1 = calc1.get_neb()

calc2 = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb')
images2, energies2 = calc2.get_neb()

calc3 = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb')
images3, energies3 = calc3.get_neb()

calc4 = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb')
images4, energies4 = calc4.get_neb()

x = range(len(images1))
xarray = np.linspace(0, len(images1))
f1 = interp1d(x, energies1, kind='cubic', bounds_error=False)
f2 = interp1d(x, energies2, kind='cubic', bounds_error=False)
f3 = interp1d(x, energies3, kind='cubic', bounds_error=False)
f4 = interp1d(x, energies4, kind='cubic', bounds_error=False)


plt.plot(x, energies1, 'bo', label='222')
plt.plot(x, energies2, 'ro', label='223')
plt.plot(x, energies3, 'co', label='233')
plt.plot(x, energies4, 'mo', label='333')


plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.plot(xarray, f3(xarray), 'c-')
plt.plot(xarray, f4(xarray), 'm-')

plt.annotate('',xy=(1,0.03),xytext=((1,0.1)),arrowprops=dict(arrowstyle="->",connectionstyle="arc3"))
plt.annotate('',xy=(4,0.67),xytext=((4,0.6)),arrowprops=dict(arrowstyle="->",connectionstyle="arc3"))

plt.xlabel('Images')
plt.ylabel('Reference Potential Energy(eV/atom)')
plt.legend(loc = 'best')
plt.legend()
plt.savefig('./figures/NEB-all.png')
#+END_SRC

#+RESULTS:

[[./figures/NEB-all.png]]

#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d
from ase.calculators.singlepoint import SinglePointCalculator as SPC

calc1 = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
calc0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb-initial')
E0 = calc0.potential_energy
images1, energies1 = calc1.get_neb()
energies1 = energies1 + E0

calc2 = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb')
images2, energies2 = calc2.get_neb()
calc0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-initial')
E0 = calc0.potential_energy
energies2 = energies2 + E0


calc3 = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb')
images3, energies3 = calc3.get_neb()
calc0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-initial')
E0 = calc0.potential_energy
energies3 = energies3 + E0

calc4 = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb')
images4, energies4 = calc4.get_neb()
calc0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb-initial')
E0 = calc0.potential_energy
energies4 = energies4 + E0

x = range(len(images1))
xarray = np.linspace(0, len(images1))
f1 = interp1d(x, energies1, kind='cubic', bounds_error=False)
f2 = interp1d(x, energies2, kind='cubic', bounds_error=False)
f3 = interp1d(x, energies3, kind='cubic', bounds_error=False)
f4 = interp1d(x, energies4, kind='cubic', bounds_error=False)


plt.plot(x, energies1, 'bo', label='222')
plt.plot(x, energies2, 'ro', label='223')
plt.plot(x, energies3, 'co', label='233')
plt.plot(x, energies4, 'mo', label='333')


plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.plot(xarray, f3(xarray), 'c-')
plt.plot(xarray, f4(xarray), 'm-')

#plt.annotate('',xy=(1,0.03),xytext=((1,0.1)),arrowprops=dict(arrowstyle="->",connectionstyle="arc3"))
#plt.annotate('',xy=(4,0.67),xytext=((4,0.6)),arrowprops=dict(arrowstyle="->",connectionstyle="arc3"))

plt.xlabel('Images')
plt.ylabel('Reference Potential Energy(eV/atom)')
plt.legend(loc = 'best')
plt.legend()
plt.savefig('./figures/NEB-all-2.png')
#+END_SRC

#+RESULTS:

[[./figures/NEB-all-2.png]]

* DB
** write
#+BEGIN_SRC python
from vasp import Vasp

factor = [0.900, 0.950, 1.000, 1.050]
#factor = [0.900, 0.950, 1.050]
#cells= ['222', '223', '233', '333', '334', '344', '444'] 
cells = ['222']
calcs = []
for cell in cells:

    for x in factor:
    
        #wd = './NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell={0}/factor={1:.3f}'.format(cell,x)
        wd = './NDFT/bulk=fcc/type=vacancy/lattice=cubic/supercell={0}/factor={1:.3f}'.format(cell,x)
        calc = Vasp(wd)

        calc.write_db('./database/db1/data.db', parser='=', overwrite=False, keys={'dbkey':0}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []
for i in range(200):
    wd = './NDFT/bulk=fcc/type=md/order=md0/v_a=0_8/MD={0}'.format(i)

    calc = Vasp(wd)
    calcs += [calc]
    calc.write_db('database/db1/data.db', parser='=', overwrite=False, keys={'dbkey':0}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
import numpy as np

factor = np.append(np.arange(0.85, 1.2, 0.01),
                   np.arange(1.2, 2.125, 0.05))
factor = np.delete(factor, 15)

cells = ['fcc', 'bcc', 'hcp', 'sc', 'diam']
for cell in cells:

    for x in factor:
    
   
        wd = './NDFT/bulk={0}/type=eos/factor={1:.2f}'.format(cell,x)
        calc = Vasp(wd)

        calc.write_db('./database/db1/data.db', parser='=', overwrite=False, keys={'dbkey':0}) 
#+END_SRC

#+RESULTS:
*** MD
*** 0:8
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
from vasp import Vasp
from vasp.vasprc import VASPRC

VASPRC['queue.walltime'] = '24:00:00'

calc1 = Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db0/2-20/-parameters-checkpoint-0.json')
images = Trajectory('./database/db0/MD-0:8.traj', 'r')
E1, E2 = [], []

for atoms in images:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in images:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)
res = E1-E2
res = np.array(res)
x = np.absolute(res)
t = []

for i in range(len(x)):
    if x[i] > 0.002:
        t += [i]


for i in t:        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=0_8/MD={}'.format(i))
    calc.write_db('./database/db1/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

*** 1:7
#+BEGIN_SRC python
from vasp import Vasp

for i in range(51):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_7/MD={}'.format(i))
    calc.write_db('./database/db1/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

*** 1:11
#+BEGIN_SRC python
from vasp import Vasp

for i in range(22):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_11/MD={}'.format(i))
    calc.write_db('./database/db1/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

*** 1:17
#+BEGIN_SRC python
from vasp import Vasp

for i in range(38):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_17/MD={}'.format(i))
    calc.write_db('./database/db1/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

*** 1:26
#+BEGIN_SRC python
from vasp import Vasp

for i in range(16):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_26/MD={}'.format(i))
    calc.write_db('./database/db1/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

*** 1:35
#+BEGIN_SRC python
from vasp import Vasp

for i in range(10):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_35/MD={}'.format(i))
    calc.write_db('./database/db1/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

*** 1:47
#+BEGIN_SRC python
from vasp import Vasp

for i in range(10):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_47/MD={}'.format(i))
    calc.write_db('./database/db1/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

*** 1:63
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db0/MD-1:64.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(0, len(images))]
for i in np.arange(0, len(images)):
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_63/MD={}'.format(i),
                     xc='pbe',
                     kpts=[3, 3, 3],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)

#res = [r for i, r in enumerate(Ne) if i in
#       np.arange(0, len(images), 4) and i != 60]
res = abs(np.array(Ne) - np.array(nrg))

fig, ax = plt.subplots(figsize=(6, 4))
ax.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
ax.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='b', label='DFT prediction')

#ax.set_xlim(min(s), max(s))
ax.set_ylabel('Potential energy (eV)', color='b')
ax.tick_params(axis='y', colors='b')
#ax.set_ylim(-141, -130)
ax.set_xlabel('Time step')
ax.legend(loc=2)

ax1 = ax.twinx()

ax1.scatter(range(len(res)), res, color='r')
ax1.set_ylabel('Absolute residual error (eV)', color='r')
#ax1.set_xlim(min(s), max(s))
ax1.tick_params(axis='y', colors='r')
ax1.set_ylim(0.0, 7.0)

plt.tight_layout()
plt.show()
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md1/v_a=1_63/MD=1 submitted: 1432098.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md1/v_a=1_63/MD=1 Queued: 1432098.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md1/v_a=1_63/MD=3 submitted: 1432099.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md1/v_a=1_63/MD=3 Queued: 1432099.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md1/v_a=1_63/MD=5 submitted: 1432100.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md1/v_a=1_63/MD=5 Queued: 1432100.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md1/v_a=1_63/MD=9 submitted: 1432101.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md1/v_a=1_63/MD=9 Queued: 1432101.gilgamesh.cheme.cmu.edu

** keywords
#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

from ase.db import connect

db = connect('./database/db1/data.db')
data = db.select([])

keys, cnt = {}, 0
for entry in data:
    cnt += 1
    for k, v in entry.key_value_pairs.iteritems():
        
        if k in keys:
            keys[k] += [v]
        else:
            keys[k] = [v]

print ('{0:15s} {1:15s} {2} calculations total'.format('keyword', 'value',cnt))

print('------------------------------------------------------')

for k, v in keys.iteritems():
    vals = list(set(v))
    if len(vals) <= 5:
        val = ", ".join(str(e) for e in vals)
        print('{0:15}: {1}'.format(k, val))

    else:
        val = ", ".join(str(e)[:5] for e in vals[:5])
        print('{0:15s}:{1}, etc...'.format(k, val))
#+END_SRC

#+RESULTS:
#+begin_example
keyword         value           704 calculations total
------------------------------------------------------
MD             :0, 1, 2, 3, 4, etc...
train_set      : False, True
dbkey          : 0, 1
bulk           : sc, hcp, fcc, diam, bcc
lattice        : primitive, cubic
supercell      :233, 333, 334, 344, 444, etc...
v_a            :1_26, 1_47, 1_11, 1_17, 1_7, etc...
factor         :1.25, 1.0, 2.0, 1.45, 0.94, etc...
type           : vacancy, md, eos
order          : md0, md1
#+end_example

* Training
#+BEGIN_SRC python
from ase.db import connect
import os
import random
import numpy as np

db = connect('./database/db1/data.db')

n = db.count()
n_train = int(round(n * 0.9))

n_ids =  np.array(range(n)) + 1

# This will sudo-randomly select 10% of the calculations
# Which is useful for reproducing our results.
random.seed(256)
train_samples = random.sample(n_ids, n_train)
valid_samples = set(n_ids) - set(train_samples)

db.update(list(train_samples), train_set=True)
db.update(list(valid_samples), train_set=False)

with connect('./database/db1/train.db') as db0:
    for d in db.select(['train_set=True']):
        db0.write(d, key_value_pairs=d.key_value_pairs)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *
import os

for n in [18]:
    label = '2-{0}-test'.format(n)
    wd = os.path.join(os.getcwd(), 'database/db1/' + label)

    if not os.path.exists(wd):
        os.makedirs(wd)

    calc = Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json',
               label="./database/db1/{0}/".format(label),
               descriptor=Behler(cutoff=6.0),
               regression=NeuralNetwork(hiddenlayers=(2, '{0}'.format(n))))


    calc.train('./database/db1/data.db', # The training data
               cores=1,
               extend_variables=False) # feature does not work properly and will crash
#+END_SRC

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

# We will try an iteration for n nodes with l hidden layers.
for l in [2]:
    
    #for n in [10, 15, 18, 20, 24, 25, 30]:
    #for n in [15]:
    #for n in [10, 15, 18, 20]:
    for n in [17, 24, 28, 30]:
        label = '{0}-{1}-new'.format(l,n)
        layer=(l,n)
        wd = os.path.join(home, './database/db1/' + label)

        if not os.path.exists(wd):
            os.makedirs(wd)

        os.chdir(wd)

        run_amp = '''#!/usr/bin/env python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

calc = Amp(label="./",
           descriptor=Behler(cutoff=6.0),
           regression=NeuralNetwork(hiddenlayers={0}))

calc.train("~/Research/Bulk/database/db1/train.db", # The training data
           cores=1,
           extend_variables=False) 
'''.format(layer)

        cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=60:00:00
#PBS -l mem=4GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

        with open('submit.py', 'w') as f:
            f.write(run_amp)
        os.chmod('submit.py', 0777)

        with open('submit.sh', 'w') as f:
            f.write(cmd)

        subprocess.call(['qsub', 'submit.sh'])
        time.sleep(5)
        os.unlink('submit.sh')
        os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1432806.gilgamesh.cheme.cmu.edu
: 1432809.gilgamesh.cheme.cmu.edu
: 1432813.gilgamesh.cheme.cmu.edu
: 1432817.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

# We will try an iteration for n nodes with l hidden layers.
for l in [2]:
    
    #for n in [10, 15, 18, 20, 24, 25, 30]:
    #for n in [15]:
    #for n in [10, 15, 18, 20]:
    for n in [18]:
        label = '{0}-{1}-1'.format(l,n)
        layer=(l,n)
        wd = os.path.join(home, './database/db1/' + label)

        if not os.path.exists(wd):
            os.makedirs(wd)

        os.chdir(wd)

        run_amp = '''#!/usr/bin/env python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

calc = Amp(load="../../db0/2-18/",
           label="./",
           descriptor=Behler(cutoff=6.0),
           regression=NeuralNetwork(hiddenlayers={0}))

calc.train("~/Research/Bulk/database/db1/train.db", # The training data
           cores=1,
           extend_variables=False) 

'''.format(layer)

        cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=60:00:00
#PBS -l mem=4GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

        with open('submit.py', 'w') as f:
            f.write(run_amp)
        os.chmod('submit.py', 0777)

        with open('submit.sh', 'w') as f:
            f.write(cmd)

        subprocess.call(['qsub', 'submit.sh'])
        time.sleep(5)
        os.unlink('submit.sh')
        os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1433029.gilgamesh.cheme.cmu.edu
*** 28
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

# We will try an iteration for n nodes with l hidden layers.
for l in [2]:
    
    #for n in [10, 15, 18, 20, 24, 25, 30]:
    #for n in [15]:
    #for n in [10, 15, 18, 20]:
    for n in [24, 28, 30]:
        label = '{0}-{1}-2'.format(l,n)
        layer=(l,n)
        wd = os.path.join(home, './database/db1/' + label)

        if not os.path.exists(wd):
            os.makedirs(wd)

        os.chdir(wd)
        #print os.getcwd()

        run_amp = '''#!/usr/bin/env python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

calc = Amp(load="../2-{0}-new/-parameters-checkpoint-0.json",
           label="./",
           descriptor=Behler(cutoff=6.0),
           regression=NeuralNetwork(hiddenlayers={1}))

calc.train("~/Research/Bulk/database/db1/train.db", # The training data
           cores=1,
           extend_variables=False) 

'''.format(n, layer)

        cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=64:00:00
#PBS -l mem=2GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

        with open('submit.py', 'w') as f:
            f.write(run_amp)
        os.chmod('submit.py', 0777)

        with open('submit.sh', 'w') as f:
            f.write(cmd)

        subprocess.call(['qsub', 'submit.sh'])
        time.sleep(5)
        os.unlink('submit.sh')
        os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1434201.gilgamesh.cheme.cmu.edu
: 1434202.gilgamesh.cheme.cmu.edu
: 1434203.gilgamesh.cheme.cmu.edu
#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *
import os

for n in [28]:
    label = '2-{0}-test'.format(n)
    wd = os.path.join(os.getcwd(), 'database/db1/' + label)

    if not os.path.exists(wd):
        os.makedirs(wd)
    print os.getcwd()

    calc = Amp(load='./database/db1/2-28-new/-parameters-checkpoint-0.json',
               label="./database/db1/{0}/".format(label),
               descriptor=Behler(cutoff=6.0),
               regression=NeuralNetwork(hiddenlayers=(2, '{0}'.format(n))))


    calc.train('./database/db1/data.db', # The training data
               cores=1,
               extend_variables=False) # feature does not work properly and will crash

#+END_SRC

#+RESULTS:

** Update

#+BEGIN_SRC python
from ase.db import connect
from amp import Amp

db = connect('./database/db1/data.db')
calc1 = Amp(load = './database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load = './database/db1/2-30-2/-parameters-checkpoint-0.json')

for d in db.select():
    atoms = db.get_atoms(d.id)
    atoms.set_calculator(calc1)
    nrg1 = atoms.get_potential_energy()

    atoms.set_calculator(calc2)
    nrg2 = atoms.get_potential_energy()
    db.update(d.id, NN24 = nrg1, NN30 = nrg2)
#+END_SRC

#+RESULTS:

** Residual
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from ase.db import connect
from amp import Amp
import os

db = connect('database/db1/data.db')

fig, ax = plt.subplots(1, 2, sharey=True, figsize=(8, 4))

for i, n in enumerate([24, 30]):

    E, nnE, var, ind = [], [], [], []
    for j, d in enumerate(db.select('')):# dbkey=0
	E += [d.energy / d.natoms]
	nnE += [d['NN{}'.format(n)]/ d.natoms]
	var += [j]
	ind += [d.train_set]

    res = np.array(nnE) - np.array(E)
    mask = np.array(ind)
    valid = np.ma.masked_array(res, mask)
    train = np.ma.masked_array(res, ~mask)
    vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
    tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))

    ax[i].text(5, -0.050,
               'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
               color='b', ha='left')
    ax[i].text(5, -0.055,
               'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
               color='r', ha='left')

    ax[i].scatter(var, train, color='b')
    ax[i].scatter(var, valid, color='r')
    ax[i].plot([min(var), max(var)], [0, 0], 'k--')
    ax[i].set_xlim(min(var), max(var))

    ax[i].set_xlabel('Calculation ID')
    ax[i].set_title('8-{0}-{0}-1 framework'.format(n))

ax[0].set_ylim(-0.060, 0.060)
ax[0].set_ylabel('Residual error (eV/atom)')
plt.tight_layout()
plt.savefig('./figures/residual-1.png')
#plt.show()
#+END_SRC

#+RESULTS:

c[[./figures/residual-1.png]]

#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db1/data.db')

S, Qe, Ne = [], [], []

for d in db.select(['type=eos']):
    S += [d.bulk]
    Qe += [d.energy/d.natoms]
    Ne += [d.NN24/d.natoms]
    
S = np.array(S)
Qe = np.array(Qe)
Ne = np.array(Ne)

cmap, hdl = {}, []

#print Ne
for s, c in zip(set(S), ['b', 'r', 'g', 'c', 'm']):
    cmap[s] = c
    hdl +=[mpatches.Patch(color = c, label = s)]

c = []
for s in S:
    c +=[cmap[s]]

RMSE = np.sqrt(sum((Ne-Qe)** 2) / len(Ne - Qe))

(mu, sigma) = norm.fit(Ne- Qe)

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
ax0.plot([min(Qe), 0], [0,0], 'k--', lw =2)
ax0.scatter(Qe, Ne-Qe, marker = 'o', color = c)
ax0.text(min(Qe) + 0.1, 0.14,
         'RMSE: {0:1.3f}'.format(RMSE),
         fontsize = 12, va = 'top', ha = 'left')
ax0.set_xlim(min(Qe), 0)
ax0.set_ylim(-0.02, 0.02)
ax0.set_xlabel('DFT potential energy (eV/atom)')
ax0.set_ylabel('Rsidual error (eV/atom)')
ax0.legend(loc = 'best', handles =hdl, fontsize = 8, frameon = False)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(Ne-Qe, 50,
                            range = (-0.01, 0.01),
                            weights = np.ones_like(Ne-Qe)/ len(Ne),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.05, 0.142, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.05, 0.122, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.01, 0.01)
ax1.set_xlim(0, 0.3)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
plt.tight_layout(w_pad = -0.5)
#plt.savefig('./images/fig-neural-train.png')
plt.show()
#+END_SRC

#+RESULTS:

* Application
** Vacancy formation
*** 222
     
#+BEGIN_SRC python
from jasp import *
with jasp('./DFT/relaxed=True/bulk=fcc/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    E0 = E0 * 8

with jasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=222/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E1 = atoms.get_potential_energy()
    
print E1 - E0*7/8.0
print E0
print E1
#+END_SRC

#+RESULTS:
: 1.06876678
: -41.71703416
: -35.43363811


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 2, 2)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (7/8.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  16:13:13      -35.328610       0.0000
: Vacancy formation energy with NN is: 1.181 eV
: -41.724773802
: -35.3286100665

*** 223
     
#+BEGIN_SRC python
from jasp import *
with jasp('./DFT/relaxed=True/bulk=fcc/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    E0 = E0 * 12

with jasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=223/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E1 = atoms.get_potential_energy()
    
print E1 - E0*11/12.0
print E0
print E1
#+END_SRC

#+RESULTS:
: 1.13686192
: -62.57555124
: -56.22406005


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 2, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (11/12.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  16:14:32      -56.072172       0.5309
BFGS:   1  16:14:36      -56.091612       0.4435
BFGS:   2  16:14:39      -56.145801       0.0936
BFGS:   3  16:14:43      -56.147244       0.0692
BFGS:   4  16:14:47      -56.147925       0.0645
BFGS:   5  16:14:50      -56.148946       0.0661
BFGS:   6  16:14:53      -56.149129       0.0671
BFGS:   7  16:14:56      -56.148790       0.0606
BFGS:   8  16:15:01      -56.148096       0.0570
BFGS:   9  16:15:04      -56.146863       0.0510
BFGS:  10  16:15:08      -56.145654       0.0501
BFGS:  11  16:15:11      -56.145074       0.0409
Vacancy formation energy with NN is: 1.226 eV
-62.587160703
-56.1450743192
#+end_example

*** 233
     
#+BEGIN_SRC python
from jasp import *
with jasp('./DFT/relaxed=True/bulk=fcc/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    E0 = E0 * 18

with jasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=233/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E1 = atoms.get_potential_energy()
    
print E1 - E0*17/18.0
print E0
print E1
#+END_SRC

#+RESULTS:
: 1.15787387
: -93.86332686
: -87.49082372


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 3, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (17/18.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  16:18:08      -87.329792       0.5731
BFGS:   1  16:18:15      -87.362468       0.4904
BFGS:   2  16:18:22      -87.442982       0.1443
BFGS:   3  16:18:29      -87.444341       0.1215
BFGS:   4  16:18:36      -87.444076       0.1065
BFGS:   5  16:18:43      -87.441991       0.0644
BFGS:   6  16:18:50      -87.440384       0.0644
BFGS:   7  16:18:57      -87.438787       0.0587
BFGS:   8  16:19:04      -87.436955       0.0554
BFGS:   9  16:19:11      -87.434154       0.0499
Vacancy formation energy with NN is: 1.231 eV
-93.8807410545
-87.4341539619
#+end_example

*** 333
     
#+BEGIN_SRC python
from jasp import *
with jasp('./DFT/relaxed=True/bulk=fcc/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    E0 = E0 * 27

with jasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=333/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E1 = atoms.get_potential_energy()
    
print E1 - E0*26/27.0
print E0
print E1
#+END_SRC

#+RESULTS:
: 1.10490713
: -140.79499029
: -134.47545389


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (3, 3, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (26/27.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  16:33:47     -134.239261       0.5460
: BFGS:   1  16:34:02     -134.280402       0.4683
: BFGS:   2  16:34:18     -134.379524       0.0728
: BFGS:   3  16:34:37     -134.379948       0.0593
: BFGS:   4  16:34:53     -134.380447       0.0588
: BFGS:   5  16:35:11     -134.382432       0.0477
: Vacancy formation energy with NN is: 1.223 eV
: -140.821111582
: -134.382431999

*** 444
     
#+BEGIN_SRC python
from jasp import *
with jasp('./DFT/relaxed=True/bulk=fcc/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    E0 = E0 * 64

with jasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=444/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E1 = atoms.get_potential_energy()
    
print E1 - E0*63/64.0
print E0
print E1
#+END_SRC

#+RESULTS:
: 0.97281115
: -333.73627328
: -327.54883286


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (4, 4, 4)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (63/64.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  16:16:34     -327.252829       0.2666
: BFGS:   1  16:17:23     -327.264397       0.2274
: BFGS:   2  16:18:20     -327.257182       0.0925
: BFGS:   3  16:19:17     -327.262939       0.0809
: BFGS:   4  16:20:16     -327.300969       0.0292
: Vacancy formation energy with NN is: 1.282 eV
: -333.798190416
: -327.300969026

*** Dilute limitation
#+BEGIN_SRC python
from jasp import *
with jasp('./DFT/relaxed=True/bulk=fcc/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    E0 = E0 * 64

with jasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=444/factor=1.000') as calc:
    atoms = calc.get_atoms()
    E1 = atoms.get_potential_energy()
    
print E1 - E0*63/64.0
#+END_SRC

#+RESULTS:
: 0.97281115

#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
import matplotlib.pyplot as plt
Ev = []
con = []

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=444/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev += [E1 - E0*63]
con +=[1.0/63]

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=344/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev += [E1 - E0*47]
con +=[1.0/47]

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=334/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev += [E1 - E0*35]
con +=[1.0/35]

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=333/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev += [E1 - E0*26]
con +=[1.0/26]

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=233/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev += [E1 - E0*17]
con +=[1.0/17]

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=223/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev += [E1 - E0*11]
con +=[1.0/11]

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=222/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev += [E1 - E0*7]
con +=[1.0/7]

'''
calc = Vasp('./NDFT/bulk=fcc/type=vacancy/lattice=cubic/supercell=222/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev += [E1 - E0*31]
con +=[1.0/31]
'''

print Ev
print con
plt.plot(con, Ev, 'o')
plt.xlabel('Vacancy Concentration')
plt.ylabel('Vacacny formation energy/eV')
plt.savefig('./figures/vac-dil.png')
#+END_SRC

#+RESULTS:
: [0.962775879999981, 1.0137826999999788, 1.0703328399999918, 1.1007655899999804, 1.1551659400000034, 1.1351097299999964, 1.0676517500000031]
: [0.015873015873015872, 0.02127659574468085, 0.02857142857142857, 0.038461538461538464, 0.058823529411764705, 0.09090909090909091, 0.14285714285714285]

[[./figures/vac-dil.png]]
**** 222
#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 2, 2)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (7/8.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print 1.0/7
print ve
#+END_SRC

#+RESULTS:
: BFGS:   0  10:50:20      -35.328610       0.0000
: Vacancy formation energy with NN is: 1.181 eV
: 0.142857142857
: 1.18056701029

**** 223
#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 2, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (11/12.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print 1.0/11
print ve
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  10:50:59      -56.072172       0.5309
BFGS:   1  10:51:02      -56.091612       0.4435
BFGS:   2  10:51:06      -56.145801       0.0936
BFGS:   3  10:51:10      -56.147244       0.0692
BFGS:   4  10:51:13      -56.147925       0.0645
BFGS:   5  10:51:16      -56.148946       0.0661
BFGS:   6  10:51:19      -56.149129       0.0671
BFGS:   7  10:51:23      -56.148790       0.0606
BFGS:   8  10:51:27      -56.148096       0.0570
BFGS:   9  10:51:30      -56.146863       0.0510
BFGS:  10  10:51:34      -56.145654       0.0501
BFGS:  11  10:51:38      -56.145074       0.0409
Vacancy formation energy with NN is: 1.226 eV
0.0909090909091
1.22648965859
#+end_example

**** 233
#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 3, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (17/18.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print 1.0/7
print ve
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  10:53:19      -87.329792       0.5731
BFGS:   1  10:53:26      -87.362468       0.4904
BFGS:   2  10:53:33      -87.442982       0.1443
BFGS:   3  10:53:40      -87.444341       0.1215
BFGS:   4  10:53:47      -87.444076       0.1065
BFGS:   5  10:53:54      -87.441991       0.0644
BFGS:   6  10:54:01      -87.440384       0.0644
BFGS:   7  10:54:08      -87.438787       0.0587
BFGS:   8  10:54:15      -87.436955       0.0554
BFGS:   9  10:54:21      -87.434154       0.0499
Vacancy formation energy with NN is: 1.231 eV
0.142857142857
1.23099036736
#+end_example

** MD
*** Bulk
**** 8000
#+BEGIN_SRC python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

# Set up a crystal
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 2, 2))

# Describe the interatomic interactions with the Effective Medium Theory
atoms.set_calculator(Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json'))
# We want to run MD with constant energy using the Langevin algorithm
# with a time step of 5 fs, the temperature T and the friction
# coefficient to 0.02 atomic units.
dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):  # store a reference to atoms in the definition.
    """Function to print the potential, kinetic and total energy."""
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=20)

# We also want to save the positions of all atoms after every time step.
traj = Trajectory('./database/db1/MD0-8-0.traj', 'w', atoms)
dyn.attach(traj.write, interval=20)

# Now run the dynamics
dyn.run(8000)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db1')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 2, 2))

atoms.set_calculator(Amp(load="./2-24-2/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=20)

traj = Trajectory("./MD0-8.traj", "w", atoms)
dyn.attach(traj.write, interval=20)

dyn.run(8000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('0-8')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1439388.gilgamesh.cheme.cmu.edu


#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
import jbtools.gilgamesh as jb

Ne = []
for i, atoms in enumerate(Trajectory('./database/db0/MD.traj', 'r')):

    Ne += [atoms.get_potential_energy()]

plt.plot(range(len(Ne)), Ne, 'bo')
#plt.savefig('./images/MD-NN.png')
plt.show()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db1/MD0-8-0.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
#plt.show()
plt.xlabel('MD Step')
plt.ylabel('Energy eV')
plt.legend()
plt.savefig('./figures/MD0-8-2.png')

#+END_SRC

#+RESULTS:

[[./figures/MD0-8-2.png]]
**** 4000
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db0')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 2, 2))

atoms.set_calculator(Amp(load="./2-18/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=20)

traj = Trajectory("./MD-0:8.traj", "w", atoms)
dyn.attach(traj.write, interval=20)

dyn.run(4000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=8GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('0:8')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1429517.gilgamesh.cheme.cmu.edu
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db0/2-20/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db0/MD-0:8.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
#plt.show()
plt.xlabel('MD Step')
plt.ylabel('Energy eV')
plt.legend()
plt.savefig('./figures/0:8-md1.png')
#plt.show()

#+END_SRC

#+RESULTS:

[[./figures/0:8-md1.png]]

*** Vacancy
**** 1:7
#+BEGIN_SRC python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

# Set up a crystal
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 2, 2))

del atoms[0]
# Describe the interatomic interactions with the Effective Medium Theory
atoms.set_calculator(Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json'))
# We want to run MD with constant energy using the Langevin algorithm
# with a time step of 5 fs, the temperature T and the friction
# coefficient to 0.02 atomic units.
dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):  # store a reference to atoms in the definition.
    """Function to print the potential, kinetic and total energy."""
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

# We also want to save the positions of all atoms after every time step.
traj = Trajectory('./database/db1/MD1-8-0.traj', 'w', atoms)
dyn.attach(traj.write, interval=10)

# Now run the dynamics
dyn.run(2000)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db1/MD1-7-0.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/MD1-7-2.png')
#+END_SRC

#+RESULTS:

[[./figures/MD1-7-2.png]]

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db1')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 2, 2))

del atoms[0]

atoms.set_calculator(Amp(load="./2-24-2/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD1-7.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('1:7')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1439389.gilgamesh.cheme.cmu.edu


The energy of MD=60 is too high to calculate.

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db0/MD-1:8.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(0, 50)]

calcs = [Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_7/MD={}'.format(i),
            xc='pbe',
            kpts=[9]*3,
            encut=350,
            nsw=0,
            atoms=images[i]) for i in range(50)]

[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)

#res = [r for i, r in enumerate(Ne) if i in
#       np.arange(0, len(images), 4) and i != 60]
res = abs(np.array(Ne) - np.array(nrg))

fig, ax = plt.subplots(figsize=(6, 4))
ax.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
ax.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='b', label='DFT prediction')

#ax.set_xlim(min(s), max(s))
ax.set_ylabel('Potential energy (eV)', color='b')
ax.tick_params(axis='y', colors='b')
#ax.set_ylim(-141, -130)
ax.set_xlabel('Time step')
ax.legend(loc=2)

ax1 = ax.twinx()

ax1.scatter(range(len(res)), res, color='r')
ax1.set_ylabel('Absolute residual error (eV)', color='r')
#ax1.set_xlim(min(s), max(s))
ax1.tick_params(axis='y', colors='r')
ax1.set_ylim(0.0, 7.0)

plt.tight_layout()
plt.show()
#+END_SRC

#+RESULTS:

**** 1:11
#+BEGIN_SRC python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

# Set up a crystal
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 2, 3))

del atoms[0]
# Describe the interatomic interactions with the Effective Medium Theory
atoms.set_calculator(Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json'))
# We want to run MD with constant energy using the Langevin algorithm
# with a time step of 5 fs, the temperature T and the friction
# coefficient to 0.02 atomic units.
dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):  # store a reference to atoms in the definition.
    """Function to print the potential, kinetic and total energy."""
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

# We also want to save the positions of all atoms after every time step.
traj = Trajectory('./database/db1/MD1-11-0.traj', 'w', atoms)
dyn.attach(traj.write, interval=10)

# Now run the dynamics
dyn.run(2000)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db1')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 2, 3))

del atoms[0]

atoms.set_calculator(Amp(load="./2-24-2/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD1-11.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('1-11')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1439390.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db1/MD1-11-0.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/MD1-11-2.png')
#+END_SRC

#+RESULTS:

[[./figures/MD1-11-2.png]]

**** 1:17
#+BEGIN_SRC python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

# Set up a crystal
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 3, 3))

del atoms[0]
# Describe the interatomic interactions with the Effective Medium Theory
atoms.set_calculator(Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json'))
# We want to run MD with constant energy using the Langevin algorithm
# with a time step of 5 fs, the temperature T and the friction
# coefficient to 0.02 atomic units.
dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):  # store a reference to atoms in the definition.
    """Function to print the potential, kinetic and total energy."""
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

# We also want to save the positions of all atoms after every time step.
traj = Trajectory('./database/db1/MD1-17-0.traj', 'w', atoms)
dyn.attach(traj.write, interval=10)

# Now run the dynamics
dyn.run(2000)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db1')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 3, 3))

del atoms[0]

atoms.set_calculator(Amp(load="./2-24-2/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD1-17.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(1000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('1-17')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC
#+RESULTS:
: 1439391.gilgamesh.cheme.cmu.edu
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db1/MD1-17-0.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/MD1-17-2.png')
#+END_SRC

#+RESULTS:

[[./figures/MD1-17-2.png]]
**** 1:26
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db1')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(3, 3, 3))

del atoms[0]

atoms.set_calculator(Amp(load="./2-24-2/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD1-26.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('1-26')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1442443.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db1/MD1-26.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)
res = E1-E2
res = np.array(res)
x = np.absolute(res)

t = []

for i in range(len(x)):
    if x[i] > 0.002:
        t += [i]

print t
plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,50])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/MD1-26-2.png')
#+END_SRC

#+RESULTS:
: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 198, 199]

[[./figures/MD1-26-2.png]]
**** 1:35
#+BEGIN_SRC python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

# Set up a crystal
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(3, 3, 4))

del atoms[0]
# Describe the interatomic interactions with the Effective Medium Theory
atoms.set_calculator(Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json'))
# We want to run MD with constant energy using the Langevin algorithm
# with a time step of 5 fs, the temperature T and the friction
# coefficient to 0.02 atomic units.
dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):  # store a reference to atoms in the definition.
    """Function to print the potential, kinetic and total energy."""
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

# We also want to save the positions of all atoms after every time step.
traj = Trajectory('./database/db1/MD1-35-0.traj', 'w', atoms)
dyn.attach(traj.write, interval=10)

# Now run the dynamics
dyn.run(1000)
#+END_SRC

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db1')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(3, 3, 4))

del atoms[0]

atoms.set_calculator(Amp(load="./2-24-2/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD1-35-1.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(1000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('1-35')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1442929.gilgamesh.cheme.cmu.edu
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db1')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(3, 3, 4))

del atoms[0]

atoms.set_calculator(Amp(load="./2-24-2/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD1-35-0.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(1000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('1-35-0')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1443163.gilgamesh.cheme.cmu.edu

**** 1:47
#+BEGIN_SRC python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

# Set up a crystal
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(3, 4, 4))

del atoms[0]
# Describe the interatomic interactions with the Effective Medium Theory
atoms.set_calculator(Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json'))
# We want to run MD with constant energy using the Langevin algorithm
# with a time step of 5 fs, the temperature T and the friction
# coefficient to 0.02 atomic units.
dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):  # store a reference to atoms in the definition.
    """Function to print the potential, kinetic and total energy."""
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

# We also want to save the positions of all atoms after every time step.
traj = Trajectory('./database/db1/MD1-47-0.traj', 'w', atoms)
dyn.attach(traj.write, interval=10)

# Now run the dynamics
dyn.run(1000)
#+END_SRC

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db1')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(3, 4, 4))

del atoms[0]

atoms.set_calculator(Amp(load="./2-24-2/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD1-47-1.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(1000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('1-47')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1442936.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db1/MD1-47.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,100])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/MD1-47-2.png')
#+END_SRC

#+RESULTS:

[[./figures/MD1-47-2.png]]
**** 1:63
#+BEGIN_SRC python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

# Set up a crystal
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(4, 4, 4))

del atoms[0]
# Describe the interatomic interactions with the Effective Medium Theory
atoms.set_calculator(Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json'))
# We want to run MD with constant energy using the Langevin algorithm
# with a time step of 5 fs, the temperature T and the friction
# coefficient to 0.02 atomic units.
dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):  # store a reference to atoms in the definition.
    """Function to print the potential, kinetic and total energy."""
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

# We also want to save the positions of all atoms after every time step.
traj = Trajectory('./database/db1/MD1-63-0.traj', 'w', atoms)
dyn.attach(traj.write, interval=10)

# Now run the dynamics
dyn.run(500)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db1')

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(4, 4, 4))

del atoms[0]

atoms.set_calculator(Amp(load="./2-24-2/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD1-63-1.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(500)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('1-63')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1440295.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db1/MD1-63-1.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)
res = E1-E2
res = np.array(res)
x = np.absolute(res)
print x
t = []

for i in range(len(x)):
    if x[i] > 0.002:
        t += [i]

print t
plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,50])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/MD1-63-2.png')
#+END_SRC

#+RESULTS:
: [ 0.     0.     0.     0.     0.001  0.001  0.001  0.002  0.001  0.     0.
:   0.     0.001  0.001  0.001  0.001  0.     0.001  0.002  0.003  0.002  0.
:   0.     0.001  0.002  0.003  0.002  0.     0.001  0.003  0.003  0.002
:   0.001  0.001  0.002  0.003  0.002  0.001  0.001  0.002  0.003  0.002
:   0.002  0.002  0.002  0.002  0.003  0.002  0.002  0.002]
: [19, 25, 29, 30, 31, 35, 36, 39, 40, 41, 46, 48]

[[./figures/MD1-63-2.png]]
** EOS
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState
from ase.db import connect
from amp import Amp
from ase.visualize import view
import os
import json
import time
from ase.units import kJ

db = connect('./database/db1/data.db')

f, ax = plt.subplots(1, 5, figsize = (12, 5))
tag = ['FCC', 'BCC', 'HCP', 'SC', 'Diamond']

for i, key in enumerate(['fcc', 'bcc', 'hcp', 'sc', 'diam']):

    V, Qe, Re, Ne = [], [], [], []

    for d in db.select(['bulk={0}'.format(key), 'type=eos']):
        V += [d.volume / d.natoms]
        Qe += [d.energy / d.natoms]
        Ne += [d.NN24 / d.natoms]

    srt = [j[0] for j in sorted(enumerate(V), key = lambda x:x[1])]
    V = np.array(V)[srt]
    Qe = np.array(Qe)[srt]
    Ne = np.array(Ne)[srt]

    ax[i].plot(V, Qe, 'k-', lw=2, label = 'DFT')
    ax[i].plot(V, Ne, 'r--', lw=2, label = 'Neural')

    if i >0:
        ax[i].set_yticklabels([])

    ax[i].set_ylim(-6 , 0)
    ax[i].set_xlim(0, 150)
    ax[i].set_xticks([0, 40, 80, 120])
    ax[i].set_title('{0}'.format(tag[i]))

ax[0].set_ylabel('Potantial energy (eV/atom)')
ax[2].set_xlabel('Volume ($\AA$/atom)')
ax[4].legend(loc = 'best', fontsize = 12)
plt.tight_layout(w_pad=-1.3)
plt.savefig('./figures/eos-NN.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/eos-NN.png]]

#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt


E1, E2 = [], []

factor = np.linspace(0.85, 2.5, 1000)
for x in factor :

    atoms = FaceCenteredCubic('Pd',
                              directions=[[0, 1, 1],
                                          [1, 0, 1],
                                          [1, 1, 0]],
                              latticeconstant=3.933)
    
    delta = np.array([[x, 0., 0.],
                      [0., x, 0.],
                      [0., 0., x]])
    atoms.set_cell(np.dot(atoms.get_cell(), delta),
                   scale_atoms=True)
    calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
    calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
    
    atoms.set_calculator(calc1)
    E1 += [atoms.get_potential_energy()]

    atoms.set_calculator(calc2)
    E2 += [atoms.get_potential_energy()]

E1 = np.array(E1)
E2 = np.array(E2)
res = abs(E1 - E2)
#print E1


f, ax = plt.subplots(2, 1, sharex=True)
ax[0].plot(factor, E1, 'b', lw=2, label='2-24')
ax[0].plot(factor, E2, 'r', lw=2, label='2-30')
ax[0].plot([0.85, 0.85], [2, -6], 'k--')
ax[0].plot([2.1, 2.1], [2, -6], 'k--')
ax[0].set_ylabel('Potential energy (eV)')
ax[0].set_xlim(0.6, 2.5)
ax[0].set_ylim(-6, 2)
ax[0].legend(loc='best')
ax[1].plot(factor, res)
ax[1].plot([0.85, 0.85], [0, 0.5], 'k--')
ax[1].plot([2.07, 2.1], [0, 0.5], 'k--')
ax[1].set_ylabel('NN energy difference (eV)')
ax[1].set_ylim(0, 0.5)
ax[1].set_xlabel('Strain/stretch factor (%)')
plt.tight_layout(w_pad=0.0)
plt.savefig('./figures/app-eos.png')
#+END_SRC

#+RESULTS:

[[./figures/app-eos.png]]

** Bulk Properties
*** Cohesive energy
Atomic energy
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase import Atoms, Atom
from ase.visualize import view
VASPRC['queue.walltime'] = '24:00:00'

atoms = Atoms([Atom('Pd', [5, 5, 5])],
              cell = (7, 8, 9))

calc = Vasp('NDFT/atomic-Pd',
          xc = 'pbe',
          encut = 350,
          kpts = [1]*3,
          atoms = atoms) 

calc.calculate()

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/atomic-Pd submitted: 1442984.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
from vasp import Vasp
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')

calc = Vasp ('./NDFT/atomic-Pd') 
Eatom = calc.potential_energy
 
calc = Vasp ('./NDFT/bulk=fcc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEfcc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEfcc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=bcc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEbcc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEbcc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=hcp/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEhcp = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEhcp = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=sc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEsc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEsc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=diam/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEdiam = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEdiam = atoms.get_potential_energy()/len(atoms)
print DEfcc-Eatom, NEfcc-Eatom
print DEbcc-Eatom, NEbcc-Eatom
print DEhcp-Eatom, NEhcp-Eatom
print DEsc-Eatom, NEsc-Eatom
print DEdiam-Eatom, NEdiam-Eatom
#+END_SRC

#+RESULTS:
: -3.75476834 -3.75589508423
: -3.71312559 -3.73790838482
: -3.72459561 -3.76095602827
: -3.2532599 -3.26704062214
: -2.6162620675 -2.61824650251

*** Bulk Modulus
#+BEGIN_SRC python
from ase.db import connect
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState
from ase.units import kJ
import numpy as np
from vasp import Vasp
from amp import Amp

factor = np.arange(0.85, 1.2, 0.01)
calc2 = Amp(load = './database/db1/2-24-2/-parameters-checkpoint-0.json')
             #      np.arange(1.2, 2.125, 0.05))
configs = ['fcc', 'bcc', 'hcp', 'sc', 'diam']

for config in configs:
    nrg, vol = [], []
    nn = []
    for f in factor:
        calc = Vasp('./NDFT/bulk={0}/type=eos/factor={1:.2f}'.format(config,f))
        atoms = calc.get_atoms()
        nrg += [atoms.get_potential_energy()/len(atoms)]
        vol += [atoms.get_volume()/len(atoms)]
        atoms.set_calculator(calc2)
        nn +=[atoms.get_potential_energy()/len(atoms)]
        

    vol = np.array(vol)
    nrg = np.array(nrg)
    nn = np.array(nn)
# Fit the data to SJEOS
    eos = EquationOfState(vol, nrg)
    v0, e0, B0 = eos.fit()
    eos = EquationOfState(vol, nn)
    v1, e1, B1 = eos.fit()
    print '{0}'.format(config)
    print v0, e0, B0
    print v1, e1, B1
#+END_SRC

#+RESULTS:
#+begin_example
fcc
15.2979724806 -5.22438476072 1.09507457295
15.3564270183 -5.21520156705 1.07945263208
bcc
15.4257962561 -5.18249419589 1.06469804063
15.3991596967 -5.19211684448 1.08071951009
hcp
15.3645769219 -5.19379582623 1.08254355793
15.3341063992 -5.21621811798 1.09987534388
sc
17.8024966568 -4.72110919112 0.782438954048
17.8334288446 -4.71777979115 0.775358668286
diam
24.3558101786 -4.08130798908 0.428150007251
24.346708419 -4.08117208591 0.428715107213
#+end_example

*** Elastic Constant
**** 11, 12
#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.04, 41)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=11/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
    #calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
#+END_SRC

#+RESULTS:
: [ 2.21553499 -0.34127471]
: [ 2.91735716 -0.34129709]

**** 44
#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.04, 41)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=44/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
    #calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
#+END_SRC

#+RESULTS:
: [ 0.66616554 -0.34127543]
: [ 0.89696565 -0.34135456]

**** calculation
#+BEGIN_SRC python
B = 1.09507457295
a = 2.21553499/6
b = 0.66616554

C4 = b/2
C2 = (3*B - 2*a)/3
C1 = 2*a + C2

print C1, C2, C4
print C1 * 160.2177
print C2 * 160.2177
print C4 * 160.2177
#+END_SRC

#+RESULTS:
: 1.58741568184 0.848904018506 0.33308277
: 254.332089488
: 136.009449366
: 53.365755319

**** reference 
#+BEGIN_SRC python
from vasp import Vasp
calc = Vasp('~/Research/Bulk/DFT/bulk=fcc/type=elastic/elastic')

EM = calc.get_elastic_moduli()

print EM
#+END_SRC

#+RESULTS:
: [[ 206.71093  155.54113  155.54113    0.         0.         0.     ]
:  [ 155.54113  206.71093  155.54113    0.         0.         0.     ]
:  [ 155.54113  155.54113  206.71093    0.         0.         0.     ]
:  [   0.         0.         0.        59.78395    0.         0.     ]
:  [   0.         0.         0.         0.        59.78395    0.     ]
:  [   0.         0.         0.         0.         0.        59.78395]]

** NEB-MD
*** 222 image1
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db1/MDimage1.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)
res = E1-E2
res = np.array(res)
x = np.absolute(res)
t = []

for i in range(len(x)):
    if x[i] > 0.002:
        t += [i]
print t
plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/222-MD1.png')
#+END_SRC

#+RESULTS:
: [20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 86, 87, 88, 89, 90, 91, 92, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199]

[[./figures/222-MD1.png]]

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db1/MDimage1.traj', 'r')
#Ne = [images[i].get_potential_energy() for i in range(0, 100)]
Ne = [images[i].get_potential_energy() for i in range(0, 200)]
#for i in np.arange(0, 100, 4):
for i in range(200):        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=1/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9]*3,
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
#+END_SRC

*** 222 image2
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db1/MDimage2.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)
res = E1-E2
res = np.array(res)
x = np.absolute(res)
t = []

for i in range(len(x)):
    if x[i] > 0.002:
        t += [i]
print t
plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/222-MD2.png')
#+END_SRC

#+RESULTS:
: [0, 1, 5, 6, 7, 8, 12, 13, 14, 15, 16, 17, 20, 21, 22, 23, 24, 25, 26, 28, 29, 30, 31, 32, 33, 34, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 108, 109, 110, 111, 112, 113, 114, 116, 117, 118, 119, 120, 121, 126, 127, 128, 129, 132, 134, 135, 136, 138, 144, 145, 149, 159, 160, 161, 164, 167, 172, 174, 175, 177, 178, 179, 180, 183, 184, 185, 186, 187, 188, 189, 190, 192, 193, 195, 196, 197, 198, 199]

[[./figures/222-MD2.png]]

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db1/MDimage2.traj', 'r')


for i in range(50):        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=2/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9]*3,
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
#+END_SRC

*** 222 image3
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db1/MDimage3.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)
res = E1-E2
res = np.array(res)
x = np.absolute(res)
t = []

for i in range(len(x)):
    if x[i] > 0.002:
        t += [i]
print t
plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/222-MD3.png')
#+END_SRC

#+RESULTS:
: [0, 1, 2, 4, 5, 6, 7, 8, 9, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199]

[[./figures/222-MD3.png]]

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db1/MDimage3.traj', 'r')


for i in range(50):        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=3/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9]*3,
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
#+END_SRC

*** 222 image4
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db1/MDimage4.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)
res = E1-E2
res = np.array(res)
x = np.absolute(res)
t = []

for i in range(len(x)):
    if x[i] > 0.002:
        t += [i]
print t
plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/222-MD4.png')
#+END_SRC

#+RESULTS:
: [0, 1, 2, 3, 4, 5, 6, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199]

[[./figures/222-MD4.png]]

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db1/MDimage4.traj', 'r')

for i in range(50):        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=4/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9]*3,
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
#+END_SRC


* 3rd DFT
** MD
*** 1:7
#+BEGIN_SRC python
a = range(200)
print a
del a[168]
del a[190]
print a

[168, 190]
#+END_SRC

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db1/MD1-7-0.traj')
E1, E2 = [], []
ind = []
for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)

E = abs(E1-E2)
for i, e in enumerate(E):
    if e > 0.02:
        ind += [i]

print ind
print len(ind)
#+END_SRC

#+RESULTS:
: [86, 87, 88, 90, 91, 92, 97, 98, 99, 100, 101, 106, 107, 108, 109, 111, 112, 116, 117, 118, 120, 121, 122, 123, 129, 130, 131, 132, 133, 134, 141, 142, 143, 144, 145, 150, 151, 152, 153, 176, 177, 178, 179, 180, 181, 182, 183, 184, 188, 189, 190, 191, 196, 197, 198, 199]
: 56

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db1/MD1-7-0.traj', 'r')
#Ne = [images[i].get_potential_energy() for i in range(0, 100)]
Ne = [images[i].get_potential_energy() for i in range(0, 200)]
#for i in np.arange(0, 100, 4):
for i in range(200):        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9]*3,
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)

plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-7md-2.png')
#+END_SRC


#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp

Ne, nrg, res, s = [], [], [], []
calcs = []
a = range(200)
#del a[168]
#del a[189]
images = Trajectory('./database/db1/MD1-7-0.traj', 'r')

calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
#Ne = [images[i].get_potential_energy() for i in range(0, 100)]
E1, E2 = [], []


#for i in np.arange(0, 100, 4):
for i in a:        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/MD={}'.format(i))

        nrg += [calc.potential_energy]
        
        atoms = images[i]

        atoms.set_calculator(calc1)
        E1.append(atoms.get_potential_energy())

        atoms.set_calculator(calc2)
        E2.append(atoms.get_potential_energy())

plt.plot(range(len(E1)), E1, 'b-', label='NN1')
plt.plot(range(len(E2)), E2, 'r--', label='NN2')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT')

plt.xlim((0, len(E1)))
plt.ylabel('Potential energy (eV)')

plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-7md-2.png')
#+END_SRC

#+RESULTS:

[[./figures/1-7md-2.png]]

*** 1:11
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne,Ne0, nrg, res, s = [], [], [], [], []
calcs = []
images = Trajectory('./database/db1/MD1-11-0.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(len(images))]
for i in range(len(images)):

        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_11/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9,9,5],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)

plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-11md-2.png')
#+END_SRC

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp

Ne, nrg, res, s = [], [], [], []
calcs = []
a = range(200)
#del a[168]
#del a[189]
images = Trajectory('./database/db1/MD1-11-0.traj', 'r')

calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
#Ne = [images[i].get_potential_energy() for i in range(0, 100)]
E1, E2 = [], []


#for i in np.arange(0, 100, 4):
for i in a:        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_11/MD={}'.format(i))

        nrg += [calc.potential_energy]
        
        atoms = images[i]

        atoms.set_calculator(calc1)
        E1.append(atoms.get_potential_energy())

        atoms.set_calculator(calc2)
        E2.append(atoms.get_potential_energy())

plt.plot(range(len(E1)), E1, 'b-', label='NN1')
plt.plot(range(len(E2)), E2, 'r--', label='NN2')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT')

plt.xlim((0, len(E1)))
plt.ylabel('Potential energy (eV)')

plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-11md-2.png')
#+END_SRC

#+RESULTS:

[[./figures/1-11md-2.png]]

*** 1:17
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db1/MD1-17-0.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(len(images))]
for i in range(len(images)):
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_17/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9, 5, 5],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_17/MD=151 submitted: 1443166.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_17/MD=151 Queued: 1443166.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_17/MD=174 submitted: 1443167.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_17/MD=174 Queued: 1443167.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp

Ne, nrg, res, s = [], [], [], []
calcs = []
a = range(200)
#del a[168]
#del a[189]
images = Trajectory('./database/db1/MD1-17-0.traj', 'r')

calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
#Ne = [images[i].get_potential_energy() for i in range(0, 100)]
E1, E2 = [], []


#for i in np.arange(0, 100, 4):
for i in a:        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_17/MD={}'.format(i))

        nrg += [calc.potential_energy]
        
        atoms = images[i]

        atoms.set_calculator(calc1)
        E1.append(atoms.get_potential_energy())

        atoms.set_calculator(calc2)
        E2.append(atoms.get_potential_energy())

plt.plot(range(len(E1)), E1, 'b-', label='NN1')
plt.plot(range(len(E2)), E2, 'r--', label='NN2')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT')

plt.xlim((0, len(E1)))
plt.ylabel('Potential energy (eV)')

plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-17md-2.png')
#+END_SRC

#+RESULTS:


[[./figures/1-17md-2.png]]
*** 1:26
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
#VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db1/MD1-26.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(200)]
for i in range(200):
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD={}'.format(i),
                     xc='pbe',
                     kpts=[5, 5, 5],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)


plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-26md-2.png')
#+END_SRC

#+RESULTS:
#+begin_example
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD=70 submitted: 1443232.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD=70 Queued: 1443232.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD=77 submitted: 1443233.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD=77 Queued: 1443233.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD=81 submitted: 1443234.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD=81 Queued: 1443234.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD=88 submitted: 1443235.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD=88 Queued: 1443235.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD=90 submitted: 1443236.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD=90 Queued: 1443236.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD=142 submitted: 1443237.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD=142 Queued: 1443237.gilgamesh.cheme.cmu.edu
#+end_example

[[./figures/1-26md-2.png]]

*** 1:35
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db1/MD1-35-0.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(0, len(images))]
for i in np.arange(0, len(images)):
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD={}'.format(i),
                     xc='pbe',
                     kpts=[5, 5, 3],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)


plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-35md-1.png')
#+END_SRC

#+RESULTS:
#+begin_example
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=0 submitted: 1443256.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=0 Queued: 1443256.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=1 submitted: 1443257.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=1 Queued: 1443257.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=2 submitted: 1443258.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=2 Queued: 1443258.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=3 submitted: 1443259.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=3 Queued: 1443259.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=4 submitted: 1443260.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=4 Queued: 1443260.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=5 submitted: 1443261.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=5 Queued: 1443261.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=6 submitted: 1443262.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=6 Queued: 1443262.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=7 submitted: 1443263.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=7 Queued: 1443263.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=8 submitted: 1443264.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=8 Queued: 1443264.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=9 submitted: 1443265.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=9 Queued: 1443265.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=10 submitted: 1443266.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=10 Queued: 1443266.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=11 submitted: 1443267.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=11 Queued: 1443267.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=12 submitted: 1443268.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=12 Queued: 1443268.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=13 submitted: 1443269.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=13 Queued: 1443269.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=14 submitted: 1443270.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=14 Queued: 1443270.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=15 submitted: 1443271.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=15 Queued: 1443271.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=16 submitted: 1443272.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=16 Queued: 1443272.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=17 submitted: 1443273.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=17 Queued: 1443273.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=18 submitted: 1443274.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=18 Queued: 1443274.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=19 submitted: 1443275.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=19 Queued: 1443275.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=20 submitted: 1443276.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=20 Queued: 1443276.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=21 submitted: 1443277.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=21 Queued: 1443277.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=22 submitted: 1443278.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=22 Queued: 1443278.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=23 submitted: 1443279.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=23 Queued: 1443279.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=24 submitted: 1443280.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=24 Queued: 1443280.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=25 submitted: 1443281.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=25 Queued: 1443281.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=26 submitted: 1443282.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=26 Queued: 1443282.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=27 submitted: 1443283.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=27 Queued: 1443283.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=28 submitted: 1443284.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=28 Queued: 1443284.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=29 submitted: 1443285.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=29 Queued: 1443285.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=30 submitted: 1443286.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=30 Queued: 1443286.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=31 submitted: 1443287.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=31 Queued: 1443287.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=32 submitted: 1443288.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=32 Queued: 1443288.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=33 submitted: 1443289.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=33 Queued: 1443289.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=34 submitted: 1443290.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=34 Queued: 1443290.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=35 submitted: 1443291.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=35 Queued: 1443291.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=36 submitted: 1443292.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=36 Queued: 1443292.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=37 submitted: 1443293.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=37 Queued: 1443293.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=38 submitted: 1443294.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=38 Queued: 1443294.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=39 submitted: 1443295.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=39 Queued: 1443295.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=40 submitted: 1443296.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=40 Queued: 1443296.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=41 submitted: 1443297.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=41 Queued: 1443297.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=42 submitted: 1443298.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=42 Queued: 1443298.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=43 submitted: 1443299.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=43 Queued: 1443299.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=44 submitted: 1443300.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=44 Queued: 1443300.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=45 submitted: 1443301.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=45 Queued: 1443301.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=46 submitted: 1443302.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=46 Queued: 1443302.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=47 submitted: 1443303.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=47 Queued: 1443303.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=48 submitted: 1443304.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=48 Queued: 1443304.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=49 submitted: 1443305.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=49 Queued: 1443305.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=50 submitted: 1443306.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=50 Queued: 1443306.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=51 submitted: 1443307.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=51 Queued: 1443307.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=52 submitted: 1443308.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=52 Queued: 1443308.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=53 submitted: 1443309.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=53 Queued: 1443309.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=54 submitted: 1443310.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=54 Queued: 1443310.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=55 submitted: 1443311.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=55 Queued: 1443311.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=56 submitted: 1443312.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=56 Queued: 1443312.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=57 submitted: 1443313.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=57 Queued: 1443313.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=58 submitted: 1443314.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=58 Queued: 1443314.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=59 submitted: 1443315.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=59 Queued: 1443315.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=60 submitted: 1443316.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=60 Queued: 1443316.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=61 submitted: 1443317.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=61 Queued: 1443317.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=62 submitted: 1443318.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=62 Queued: 1443318.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=63 submitted: 1443319.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=63 Queued: 1443319.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=64 submitted: 1443320.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=64 Queued: 1443320.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=65 submitted: 1443321.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=65 Queued: 1443321.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=66 submitted: 1443322.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=66 Queued: 1443322.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=67 submitted: 1443323.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=67 Queued: 1443323.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=68 submitted: 1443324.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=68 Queued: 1443324.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=69 submitted: 1443325.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=69 Queued: 1443325.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=70 submitted: 1443326.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=70 Queued: 1443326.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=71 submitted: 1443327.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=71 Queued: 1443327.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=72 submitted: 1443328.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=72 Queued: 1443328.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=73 submitted: 1443329.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=73 Queued: 1443329.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=74 submitted: 1443330.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=74 Queued: 1443330.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=75 submitted: 1443331.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=75 Queued: 1443331.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=76 submitted: 1443332.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=76 Queued: 1443332.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=77 submitted: 1443333.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=77 Queued: 1443333.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=78 submitted: 1443334.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=78 Queued: 1443334.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=79 submitted: 1443335.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=79 Queued: 1443335.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=80 submitted: 1443336.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=80 Queued: 1443336.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=81 submitted: 1443337.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=81 Queued: 1443337.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=82 submitted: 1443338.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=82 Queued: 1443338.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=83 submitted: 1443339.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=83 Queued: 1443339.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=84 submitted: 1443340.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=84 Queued: 1443340.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=85 submitted: 1443341.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=85 Queued: 1443341.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=86 submitted: 1443342.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=86 Queued: 1443342.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=87 submitted: 1443343.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=87 Queued: 1443343.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=88 submitted: 1443344.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=88 Queued: 1443344.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=89 submitted: 1443345.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=89 Queued: 1443345.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=90 submitted: 1443346.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=90 Queued: 1443346.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=91 submitted: 1443347.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=91 Queued: 1443347.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=92 submitted: 1443348.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=92 Queued: 1443348.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=93 submitted: 1443349.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=93 Queued: 1443349.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=94 submitted: 1443350.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=94 Queued: 1443350.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=95 submitted: 1443351.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=95 Queued: 1443351.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=96 submitted: 1443352.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=96 Queued: 1443352.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=97 submitted: 1443353.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=97 Queued: 1443353.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=98 submitted: 1443354.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=98 Queued: 1443354.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=99 submitted: 1443355.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD=99 Queued: 1443355.gilgamesh.cheme.cmu.edu
#+end_example

[[./figures/1-35md-1.png]]
*** 1:47
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db1/MD1-47-0.traj', 'r')
Ne = [images[i].get_potential_energy() for i in range(0, len(images))]
for i in np.arange(0, len(images)):
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_47/MD={}'.format(i),
                     xc='pbe',
                     kpts=[5, 3, 3],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)


plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-47md-1.png')
#+END_SRC

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC


Ne, nrg, res, s = [], [], [], []
calcs = []

a = range(200)

for i in a 
:
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_47/MD={}'.format(i))
  
        nrg += [calc.potential_energy]

#+END_SRC

#+RESULTS:



[[./figures/1-47md-1.png]]

*** 1:63
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC

Ne, nrg, res, s = [], [], [], []
calcs = []

a = range(50)
del a[9]
images = Trajectory('./database/db1/MD1-63-1.traj', 'r')
Ne = [images[i].get_potential_energy() for i in a]
for i in a:
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_63/MD={}'.format(i),
                     xc='pbe',
                     kpts=[3, 3, 3],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)

plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-63md-2.png')
#+END_SRC

#+RESULTS:

[[./figures/1-63md-2.png]]

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC

Ne, nrg, res, s = [], [], [], []
calcs = []

a = [9]
images = Trajectory('./database/db1/MD1-63-1.traj', 'r')
Ne = [images[i].get_potential_energy() for i in a]
for i in a:
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_63/MD={}'.format(i),
                     xc='pbe',
                     kpts=[3, 3, 3],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_63/MD=9 submitted: 1446539.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_63/MD=9 Queued: 1446539.gilgamesh.cheme.cmu.edu

** NEB-MD
*** 222 image1
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db1/MDimage1.traj', 'r')
#Ne = [images[i].get_potential_energy() for i in range(0, 100)]
Ne = [images[i].get_potential_energy() for i in [22]]
#for i in np.arange(0, 100, 4):
for i in [22]:        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=1/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9]*3,
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=1/MD=22 submitted: 1446559.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=1/MD=22 Queued: 1446559.gilgamesh.cheme.cmu.edu

*** 222 image2
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db1/MDimage2.traj', 'r')


for i in range(50):        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=2/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9]*3,
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
#+END_SRC

*** 222 image3
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db1/MDimage3.traj', 'r')


for i in range(50):        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=3/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9]*3,
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
#+END_SRC

*** 222 image4
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db1/MDimage4.traj', 'r')

for i in range(50):        
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=4/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9]*3,
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
#+END_SRC

** Elastic Constant
*** C11, C12
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.cubic import FaceCenteredCubic
from ase.lattice.cubic import BodyCenteredCubic
from ase.lattice.cubic import SimpleCubic
from ase.lattice.hexagonal import HexagonalClosedPacked
from ase.lattice.cubic import Diamond
from ase.visualize import view
import numpy as np

VASPRC['queue.walltime'] = '24:00:00'

factor = np.linspace(0, 0.04, 41)

#factor = np.linspace(0.85, 1.2, 10)

Energy = []

Volume = []

# FCC
for x in factor:
    fcc = FaceCenteredCubic('Pd',
                            directions = [[0, 1, 1],
                                          [1, 0, 1],
                                          [1, 1, 0]],
                            latticeconstant = 3.939)
    atoms = fcc
#Vary the cell   '     
    delta = np.array([[1.0+x, 0., 0.],
                      [0., 1.0+x, 0.],
                      [0., 0., 1.0/(1.0+x)**2]])
    atoms.set_cell(np.dot(atoms.get_cell(), delta),
                       scale_atoms = True)

    wd = './NDFT/bulk=fcc/type=elastic/dirs=11/factor={:.3f}'.format(x)
       
    calc = Vasp(wd,
              xc = 'PBE',
              kpts = [14]*3,
              encut = 350,
              nsw = 0,
              atoms = atoms)

            
    calc.calculate()


#+END_SRC

#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.04, 41)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=11/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
    #calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')

    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
plt.plot(factor, Ed/Vd[0], 'bo', label = 'DFT')
plt.plot(factor, En/Vd[0], 'ro', label = 'NN')
plt.plot(factor, func(factor, *poptd), 'b-', label = 'DFT fit')
plt.plot(factor, func(factor, *poptn), 'r-', label = 'NN fit')

plt.xlabel('Strain')
plt.ylabel('Energy Density [eV/$\AA^3$]')
plt.legend(loc='best')
plt.savefig('./figures/elastic-1.png')
#plt.show()
#+END_SRC

#+RESULTS:
: [ 2.21553499 -0.34127471]
: [ 2.91735716 -0.34129709]

[[./figures/elastic-1.png]]

*** C44
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.cubic import FaceCenteredCubic
from ase.visualize import view
import numpy as np

VASPRC['queue.walltime'] = '24:00:00'

factor = np.linspace(0, 0.04, 41)

#factor = np.linspace(0.85, 1.2, 10)

Energy = []

Volume = []

# FCC
for x in factor:
    fcc = FaceCenteredCubic('Pd',
                            directions = [[0, 1, 1],
                                          [1, 0, 1],
                                          [1, 1, 0]],
                            latticeconstant = 3.939)
    atoms = fcc
#Vary the cell   '     
    delta = np.array([[1.0, x, 0.],
                      [x, 1.0, 0.],
                      [0., 0., 1.0/(1.0-x**2)]])
    atoms.set_cell(np.dot(atoms.get_cell(), delta),
                       scale_atoms = True)

    wd = 'NDFT/bulk=fcc/type=elastic/dirs=44/factor={0:1.3f}'.format(x)
       
    calc = Vasp(wd,
              xc = 'PBE',
              kpts = [14]*3,
              encut = 350,
              nsw = 0,
              atoms = atoms) 

	      
    calc.calculate()


#+END_SRC

#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.04, 41)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=44/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

    #calc2 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
    calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
plt.plot(factor, Ed/Vd[0], 'bo', label = 'DFT')
plt.plot(factor, En/Vd[0], 'ro', label = 'NN')
plt.plot(factor, func(factor, *poptd), 'b-', label = 'DFT fit')
plt.plot(factor, func(factor, *poptn), 'r-', label = 'NN fit')

plt.xlabel('Strain')
plt.ylabel('Energy Density [eV/$\AA^3$]')
plt.legend(loc='best')
plt.savefig('./figures/elastic-2.png')
#plt.show()
#+END_SRC

#+RESULTS:
: [ 0.66616554 -0.34127543]
: [ 0.72645129 -0.34129566]

[[./figures/elastic-2.png]]
** Vacancy Diffusion NEB
*** 2*2*2
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic
VASPRC['wall.time'] = '24:00:00'
fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 2, 2])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/order=neb1/supercell=222/neb-initial',
          xc='pbe',
          kpts=[9, 9, 9],
          encut=350,
          atoms=ini)
c0.calculate()

fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/order=neb1/supercell=222/neb-final',
            xc='pbe',
            kpts=[9, 9, 9],
            encut=350,
            atoms=fin)
cend.calculate()
#+END_SRC

#+RESULTS:
: No calculation_required.
: No calculation_required.

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '16GB'
#VASPRC['wall.time'] = '24:00:00'
fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 2, 2])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/order=neb1/supercell=222/neb-initial',
          xc='pbe',
          kpts=[9, 9, 9],
          encut=350,
          atoms=ini)

fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/order=neb1/supercell=222/neb-final',
            xc='pbe',
            kpts=[9, 9, 9],
            encut=350,
            atoms=fin)

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(9)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=neb/order=neb1/supercell=222/neb',
            xc='pbe',
            kpts=[9, 9, 9],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/222-NEB-13.png')
#+END_SRC

#+RESULTS:


[[./figures/222-NEB-13.png]]

#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d
from ase.calculators.singlepoint import SinglePointCalculator as SPC

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
images, energies = calc.get_neb()

En, E = [], []
calc2 = Amp('./database/db1/2-24-2/-parameters-checkpoint-0.json')

for atoms in images:
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

En = np.array(En)
E = En-En[0]
x = range(len(images))
xarray = np.linspace(0, len(images))
f1 = interp1d(x, energies, kind='cubic', bounds_error=False)
f2 = interp1d(x, E, kind='cubic', bounds_error=False)
plt.plot(x, energies, 'bo', label = 'NEB')
plt.plot(x, E, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')

plt.savefig('./figures/NEB-NN-222.png')

#+END_SRC

#+RESULTS:

[[./figures/NEB-NN-222.png]]
#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
from ase.calculators.singlepoint import SinglePointCalculator as SPC
from ase.db import connect

db = connect('database/db2/data.db')
E0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb-initial').potential_energy
E = []
calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
images, energies = calc.get_neb()


[atoms.set_calculator(SPC(atoms, energy=energies[i]))
for i, atoms in enumerate(images)]

for i, atoms in enumerate(images):
    E += [atoms.get_potential_energy()+E0]

for i, image in enumerate (images):

    db.write(atoms, {'bulk':'fcc', 'dbkey':2, 'type':'neb', 'supercell':222})
#+END_SRC

#+RESULTS:

*** 2*2*3
c0-end
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['wall.time'] = '24:00:00'
fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 2, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-initial',
          xc='pbe',
          kpts=[9, 9, 5],
          encut=350,
          atoms=ini)
c0.calculate()
fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-final',
            xc='pbe',
            kpts=[9, 9, 5],
            encut=350,
            atoms=fin)
cend.calculate()
#+END_SRC

#+RESULTS:
: No calculation_required.
: No calculation_required.


#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '8GB'

fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 2, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-initial',
          xc='pbe',
          kpts=[9, 9, 5],
          encut=350,
          atoms=ini)

fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-final',
            xc='pbe',
            kpts=[9, 9, 5],
            encut=350,
            atoms=fin)

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb',
            xc='pbe',
            kpts=[9, 9, 5],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/223-NEB.png')
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.752733
:          Iterations: 15
:          Function evaluations: 30

[[./figures/223-NEB.png]]
#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb')
images, energies = calc.get_neb()
En, E = [], []
calc2 = Amp('./database/db1/2-24-2/-parameters-checkpoint-0.json')

for atoms in images:
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

En = np.array(En)
E = En-En[0]
x = range(len(images))
xarray = np.linspace(0, len(images))
f1 = interp1d(x, energies, kind='cubic', bounds_error=False)
f2 = interp1d(x, E, kind='cubic', bounds_error=False)
plt.plot(x, energies, 'bo', label = 'NEB')
plt.plot(x, E, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')

plt.savefig('./figures/NEB-NN-223.png')
#+END_SRC

#+RESULTS:

[[./figures/NEB-NN-223.png]]
*** 2*3*3
c0-end

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['wall.time'] = '24:00:00'
fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 3, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-initial',
          xc='pbe',
          kpts=[9, 5, 5],
          encut=350,
          atoms=ini)
c0.calculate()
fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-final',
            xc='pbe',
            kpts=[9, 5, 5],
            encut=350,
            atoms=fin)
cend.calculate()
#+END_SRC

#+RESULTS:
: No calculation_required.
: No calculation_required.

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '8GB'


# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-initial')
ini = c0.get_atoms()

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-final')
fin = cend.get_atoms()

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb',
            xc='pbe',
            kpts=[9, 5, 5],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/233-NEB.png')
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.711185
:          Iterations: 15
:          Function evaluations: 30

[[./figures/233-NEB.png]]

#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb')
images, energies = calc.get_neb()
En, E = [], []
calc2 = Amp('./database/db1/2-24-2/-parameters-checkpoint-0.json')

for atoms in images:
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

En = np.array(En)
E = En-En[0]
x = range(len(images))
xarray = np.linspace(0, len(images))
f1 = interp1d(x, energies, kind='cubic', bounds_error=False)
f2 = interp1d(x, E, kind='cubic', bounds_error=False)
plt.plot(x, energies, 'bo', label = 'NEB')
plt.plot(x, E, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')

plt.savefig('./figures/NEB-NN-233.png')
#+END_SRC

#+RESULTS:

[[./figures/NEB-NN-233.png]]
*** 3*3*3
c0-end
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
				    latticeconstant = 3.939)


atoms = fcc.repeat([3, 3, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb-initial',
          xc='pbe',
          kpts=[5, 5, 5],
          encut=350,
          atoms=ini)
c0.calculate()
fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb-final',
            xc='pbe',
            kpts=[5, 5, 5],
            encut=350,
            atoms=fin)
cend.calculate()
#+END_SRC

#+RESULTS:
: No calculation_required.
: No calculation_required.


#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '8GB'


# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb-initial')
ini = c0.get_atoms()

cend = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb-final')
fin = cend.get_atoms()

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(7)]dd
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb',
            xc='pbe',
            kpts=[5, 5, 5],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('.images/333-NEB.png')
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/neb submitted: 1443516.gilgamesh.cheme.cmu.edu

** Surface
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc111
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

#VASPRC['queue.walltime'] = '24:00:00'

factor = [1.00]
a0 = 3.939
nrg = []

atoms = fcc111('Pd', size=(4, 4, 5), a = a0,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)


calc = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=44/factor=1.00',
            xc='pbe',
            kpts=[3, 3, 1],
            encut=350,
            ibrion=2,
            nsw=25,
            atoms=atoms)
		

calc.set_memory()
nrg += [calc.potential_energy]
slab = calc.get_atoms()
view(slab)
print nrg
#+END_SRC

#+RESULTS:

* DB
** write
*** DBkey0

#+BEGIN_SRC python
from vasp import Vasp

factor = [0.900, 0.950, 1.000, 1.050]
#factor = [0.900, 0.950, 1.050]
cells= ['222', '223', '233', '333', '334', '344', '444'] 
#cells = ['222']
calcs = []
for cell in cells:

    for x in factor:
    
        wd = './NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell={0}/factor={1:.3f}'.format(cell,x)
        #wd = './NDFT/bulk=fcc/type=vacancy/lattice=cubic/supercell={0}/factor={1:.3f}'.format(cell,x)
        calc = Vasp(wd)

        calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':0}) 
#+END_SRC


#+BEGIN_SRC python
from vasp import Vasp
calcs = []
for i in range(200):
    wd = './NDFT/bulk=fcc/type=md/order=md0/v_a=0_8/MD={0}'.format(i)

    calc = Vasp(wd)
    calcs += [calc]
    calc.write_db('database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':0}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
import numpy as np

factor = np.append(np.arange(0.85, 1.2, 0.01),
                   np.arange(1.2, 2.125, 0.05))


cells = ['fcc', 'bcc', 'hcp', 'sc', 'diam']
hfor cell in cells:

    for x in factor:
    
   
        wd = './NDFT/bulk={0}/type=eos/factor={1:.2f}'.format(cell,x)
        calc = Vasp(wd)

        calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':0}) 
#+END_SRC

#+RESULTS:

*** DBkey1
**** 0:8
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
from vasp import Vasp
from vasp.vasprc import VASPRC

VASPRC['queue.walltime'] = '24:00:00'

calc1 = Amp(load='./database/db0/2-18/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db0/2-20/-parameters-checkpoint-0.json')
images = Trajectory('./database/db0/MD-0:8.traj', 'r')
E1, E2 = [], []

for atoms in images:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in images:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)
res = E1-E2
res = np.array(res)
x = np.absolute(res)
t = []

for i in range(len(x)):
    if x[i] > 0.002:
        t += [i]


for i in t:        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=0_8/MD={}'.format(i))
    calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp

for i in range(200):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=0_8/MD={}'.format(i))
    calc.write_db('./database/db2/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

**** 1:7
#+BEGIN_SRC python
from vasp import Vasp

for i in range(51):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_7/MD={}'.format(i))
    calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

**** 1:11
#+BEGIN_SRC python
from vasp import Vasp

for i in range(22):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_11/MD={}'.format(i))
    calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

**** 1:17
#+BEGIN_SRC python
from vasp import Vasp

for i in range(38):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_17/MD={}'.format(i))
    calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

**** 1:26
#+BEGIN_SRC python
from vasp import Vasp

for i in range(16):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_26/MD={}'.format(i))
    calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

**** 1:35
#+BEGIN_SRC python
from vasp import Vasp

for i in range(10):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_35/MD={}'.format(i))
    calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

**** 1:47
#+BEGIN_SRC python
from vasp import Vasp

for i in range(10):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_47/MD={}'.format(i))
    calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':1}) 
#+END_SRC

#+RESULTS:

**** 1:63
#+BEGIN_SRC python
from vasp import Vasp

for i in range(10):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_63/MD={}'.format(i))
    calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':1})
#+END_SRC

#+RESULTS:

*** DBkey2
#+BEGIN_SRC python
from vasp import Vasp
import numpy as np

factor = np.linspace(0, 0.04, 41)

for x in factor:
    wd = './NDFT/bulk=fcc/type=elastic/dirs=11/factor={:.3f}'.format(x)

    calc = Vasp(wd)
    calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
import numpy as np

factor = np.linspace(0, 0.04, 41)

for x in factor: 
    wd = './NDFT/bulk=fcc/type=elastic/dirs=44/factor={:.3f}'.format(x)

    calc = Vasp(wd)
    calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC


#+RESULTS:

#+BEGIN_SRC python
'''
from vasp import Vasp
import numpy as np
from ase.calculators.singlepoint import SinglePointCalculator as SPC
from ase.db import connect

db = connect('database/db2/data.db')
E0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-initial').potential_energy
E = []
calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb')
images, energies = calc.get_neb()

E = E0 + energies


[atoms.set_calculator(SPC(atoms, energy=E[i]))
for i, atoms in enumerate(images)]

#for i, atoms in enumerate(images):
#    E += [atoms.get_potential_energy()]


for i, atoms in enumerate (images):
    db.write(atoms, {'bulk':'fcc', 'dbkey':2, 'type':'neb', 'supercell':223})
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
'''
from vasp import Vasp
import numpy as np
from ase.calculators.singlepoint import SinglePointCalculator as SPC
from ase.db import connect

db = connect('database/db2/data.db')
E0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-initial').potential_energy
E = []
calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb')
images, energies = calc.get_neb()

E = E0 + energies


[atoms.set_calculator(SPC(atoms, energy=E[i]))
for i, atoms in enumerate(images)]

#for i, atoms in enumerate(images):
#    E += [atoms.get_potential_energy()]


for i, atoms in enumerate (images):
    db.write(atoms, {'bulk':'fcc', 'dbkey':2, 'type':'neb', 'supercell':233})
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp

for cell in ['222', '223', '233', '333']:

    for i in range(9):
        wd = './NDFT/bulk=fcc/type=neb/supercell={0}/image={1}'.format(cell, i)
        calc = Vasp(wd)
        calc.write_db('database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []
for i in range(200):
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/MD={0}'.format(i)
    calc = Vasp(wd)
    
    calc.write_db('database/db2/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []
for i in range(200):
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_11/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db2/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []
for i in range(200):
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_17/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db2/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []
for i in range(200):
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db2/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []
for i in range(100):
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_47/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db2/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)
del a[9]
for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_63/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db2/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (100)

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db2/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []

#a = range(0, 21)
#a = range (23, 50)
a = range(0, 50)
del a[11]
del a[21]
#print a

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=1/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db2/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 


#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=2/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db2/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=3/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db2/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=4/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db2/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:
*** Chose data
**** 1-7
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db1/MD1-7-0.traj')
E1, E2 = [], []
ind = []
for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)

E = abs(E1-E2)
for i, e in enumerate(E):
    if e > 0.02:
        ind += [i]

print ind
print len(ind)
#+END_SRC

#+RESULTS:
: [86, 87, 88, 90, 91, 92, 97, 98, 99, 100, 101, 106, 107, 108, 109, 111, 112, 116, 117, 118, 120, 121, 122, 123, 129, 130, 131, 132, 133, 134, 141, 142, 143, 144, 145, 150, 151, 152, 153, 176, 177, 178, 179, 180, 181, 182, 183, 184, 188, 189, 190, 191, 196, 197, 198, 199]
: 56

**** 1-11
#+BEGIN_SRC python
import numpy as np
from amp import Amp
from vasp import Vasp

error = []
for i in range(200):

    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_11/MD={0}'.format(i)
    calc = Vasp(wd)
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    
    calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc1)
    E1 = atoms.get_potential_energy()

    error += [abs(E0 - E1)]


print  error
#+END_SRC

#+BEGIN_SRC python
import numpy as np

a = np.array([0.058930826630614774, 0.002797799755789754, 0.049353207615304484, 0.08088517666350725, 0.020742698756016864, 0.03774100445641437, 0.021176475719471455, 0.08406015176426962, 0.05529908636516012, 0.0010132526513331186, 0.013631783940482478, 0.05386039548609034, 0.06722637299041168, 0.025011465383471432, 0.007759523127084833, 0.022841862746773245, 0.03933754893682817, 0.0040137937735025275, 0.03216590957350718, 0.0026933239847295454, 0.058383660434678575, 0.061395195223880705, 0.01988222824208208, 0.005017412456751913, 0.02808666016517236, 0.02186687770961271, 0.01906674500084904, 0.0018946514851378993, 0.05350734851131733, 0.044710030207284035, 0.045768506648620644, 0.04571212012583459, 0.014673922653912541, 0.0222965601121885, 0.01214436226133131, 0.0016589837150391418, 0.006374694609071696, 0.04317113640203729, 0.04372613039753759, 0.0602538019776091, 0.019777123248303496, 0.003883295502909334, 0.0461764243217786, 0.05556203386262126, 0.011158986809149951, 0.00520698296175226, 0.08803559229279045, 0.020147647367871002, 0.03154981138066404, 0.04870710463049477, 0.1011242990015333, 0.06879541096351005, 0.03942277507218961, 0.09306624527260965, 0.08294646934503902, 0.03501480560091608, 0.035075986534536696, 0.07316637890220079, 0.12058382244847365, 0.1018721991645819, 0.12626653145019162, 0.04316692934868627, 0.008020505460699212, 0.02928194701528497, 0.10149802393249985, 0.116905008974733, 0.06090711967781459, 0.104154797434731, 0.09490780850769909, 0.05728763275044457, 0.008625945211910846, 0.11510500183192107, 0.1339858571534407, 0.07744055559573582, 0.005004334820561951, 0.03397482193817325, 0.047761066574253164, 0.04222248452243349, 0.016105877721052764, 0.098616281884496, 0.07650739094347614, 0.005555724921137539, 0.012586243825083443, 0.010134395006225816, 0.013919680484512753, 0.03343942359853713, 0.025447690972924875, 0.00957924212840311, 0.0653095888906563, 0.002659831945514668, 0.004175673127214452, 0.07348261293842029, 0.10445565935074086, 0.004219894108032918, 0.03931177563854504, 0.028420679387792802, 0.023160298925169798, 0.04211545287329699, 0.13186199191484604, 0.09280054579372887, 0.04321948527693564, 0.09758092350647729, 0.03256877495534383, 0.03997388670831725, 0.1549021765639651, 0.15193571724099542, 0.059218750697432654, 0.1459158547668764, 0.16385856465031878, 0.14863360681558646, 0.09709691272610144, 0.05511218596510048, 0.07693573655842556, 0.09851334329440675, 0.1359569085429797, 0.12207552283310719, 0.08451025780760091, 0.03686960737043421, 0.12313150965349706, 0.0879444727958969, 0.055582584882237995, 0.05578366261977408, 0.05803627256860722, 0.08066834282421098, 0.12464740876335156, 0.07131460594776229, 0.026440002067808166, 0.08430845617622396, 0.13938113144460118, 0.0972221062678571, 0.027891137823694123, 0.05266643400597104, 0.13984115877133263, 0.11897820055162356, 0.07208143834481717, 0.12378146767209586, 0.21478702415044637, 0.21057450970089064, 0.0951827807741239, 0.026971722032911316, 0.03521492631026746, 0.04674843360520242, 0.06380920020597358, 0.15790467151539644, 0.14524179569906437, 0.06705954117118296, 0.0292927735383941, 0.08984606029451214, 0.052150572889992475, 0.2009288877317701, 0.18882646144296444, 0.1638528338883205, 0.15733377122401038, 0.15501595671691604, 0.10151102097696452, 0.07608093511731084, 0.13636127164519252, 0.13531417014473135, 0.19056617716165647, 0.21959086957559748, 0.12917841832454968, 0.23316878944169872, 0.2124454596048082, 0.1508990520660376, 0.1207200066109948, 0.06333826370667595, 0.0036077794261970553, 0.0012459540238651812, 0.17828442142744905, 0.21248007499914934, 0.27399457625461565, 0.1809788531464136, 0.1119335081578825, 0.16607237778961093, 0.11439675200676902, 0.09551741773731948, 0.08455162693086038, 0.18622833116679516, 0.2289454709928762, 0.06996560126466989, 0.14369725363260244, 0.1664691894350696, 0.03607570936417659, 0.008303758544229822, 0.1765608549179234, 0.07099050375339999, 0.16514947595435103, 0.14286582102297984, 0.15114425196522063, 0.23231234590099348, 0.12766094204331324, 0.1849425032798493, 0.1820415220153606, 0.037647419451850794, 0.0669375255203164, 0.11571275369113465, 0.21402825266284964, 0.11377855264904468, 0.09255268772342617, 0.09822172999381706])


ind = []
for i, n in enumerate(a):
    if n > 0.05:
        ind += [i]

print ind
print len(ind)

#+END_SRC

#+RESULTS:
: [0, 3, 7, 8, 11, 12, 20, 21, 28, 39, 43, 46, 50, 51, 53, 54, 57, 58, 59, 60, 64, 65, 66, 67, 68, 69, 71, 72, 73, 79, 80, 88, 91, 92, 98, 99, 101, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 118, 119, 120, 121, 122, 123, 124, 125, 127, 128, 129, 131, 132, 133, 134, 135, 136, 137, 138, 142, 143, 144, 145, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 184, 185, 186, 187, 188, 189, 190, 191, 192, 194, 195, 196, 197, 198, 199]
: 121

**** 1-17
#+BEGIN_SRC python
import numpy as np
from amp import Amp
from vasp import Vasp

error = []
for i in range(200):

    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_17/MD={0}'.format(i)
    calc = Vasp(wd)
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    
    calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc1)
    E1 = atoms.get_potential_energy()

    error += [abs(E0 - E1)]


print  error
#+END_SRC

#+BEGIN_SRC python
import numpy as np

a = np.array([0.02816583686801266, 0.024573757311642908, 0.005468077361328483, 0.04561606107424154, 0.016222527966419875, 0.04944255969910216, 0.006731893422326607, 0.05441287928712768, 0.01881057730535929, 0.04242075492163622, 0.01899994364197255, 0.04178542395391105, 0.025039922483017563, 0.034619051823909786, 0.04530585277875332, 0.0053666283740057, 0.00838275603101124, 0.03480479206115206, 0.030115794468201784, 0.021187367045172323, 0.03688493771385026, 0.02863624406870713, 0.04046800502605663, 0.035289133990247024, 0.02930099368801109, 0.04948951344098873, 0.045491235486011306, 0.03568735258212996, 0.005857757493458848, 0.009877355891362072, 0.037213862776852125, 0.042802340851551435, 0.027444790265704455, 0.024586892709024255, 0.03937551795834793, 0.036603318691561526, 0.03016182713743376, 0.008202819852414223, 0.020199412249255033, 0.02655354015745104, 0.003402967996606776, 0.0279773431519601, 0.0401439421041232, 0.07540075104328992, 0.041058752193322334, 0.017619943869291887, 0.026605003600195687, 0.06595203296588181, 0.0022779928679454997, 0.05709405737664497, 0.02154128641414843, 0.06439210141665797, 0.04803111112535419, 0.004943930886057046, 0.011626708419527176, 0.05469898418130015, 0.04256502248287575, 0.021974740436789375, 0.014051506608183217, 0.03999138260799384, 0.01086187733049826, 0.028113232235170926, 0.0672113593040109, 0.007545306435289945, 0.023337024488412794, 0.01673928378342282, 0.09732613415570768, 0.03230042462537597, 0.03193474460059065, 0.023126640051529535, 0.06026887638617495, 0.0384707231713719, 0.001439460135586046, 0.009609980840622256, 0.08468126755315097, 0.12697178760885208, 0.01586657629800925, 0.021173325849716207, 0.03657013860745906, 0.08818585958553626, 0.05578068755578158, 0.06407813286152475, 0.0669466816182478, 0.035836217214296084, 0.01107208678345728, 0.04666735630893015, 0.013554704617746438, 0.048246401796887994, 0.06299719773046775, 0.0859522478814796, 0.07450152432234347, 0.006807591237816268, 0.012656778637094135, 0.03789040357573015, 0.07494441171878918, 0.13485661784973502, 0.13502420902102585, 0.07579299371016646, 0.003440401989209363, 0.025389727655991123, 0.019146719292237435, 0.08444424948163487, 0.08368932738443391, 0.005504874190449982, 0.04621050758649403, 0.02233045296307523, 0.05668117337519618, 0.0214376319263323, 0.042289173707928285, 0.06227649206968522, 0.038426893823654495, 0.02754487456506638, 0.04699807900205144, 0.11260842782735381, 0.0531213347052244, 0.02502216294601567, 0.03622393668652535, 0.060881787082948335, 0.06642744352647867, 0.07932654026375019, 0.03815120409413453, 0.0011010819677608197, 0.04465726754895627, 0.09665519550969748, 0.05372528229759155, 0.05158087982680115, 0.06882325327289607, 0.1580774680622028, 0.11506156247354227, 0.015635255205239673, 0.008615812922272426, 0.10369220605865337, 0.12519467337465073, 0.031062072166662347, 0.08326444283976286, 0.12542275354410037, 0.11367988488009928, 0.0021547121081084697, 0.01817775694316026, 0.07681928728138132, 0.1062251001378911, 0.05259009070206844, 0.07410909234960172, 0.13246774110915283, 0.0004668140151125044, 0.057560959861291394, 0.08931109806707127, 0.14392107630729356, 0.018872523846127365, 0.05800733569732586, 0.11823794958117162, 0.13318045218882446, 0.044574834133385366, 0.02524271639241249, 0.03311223909200578, 0.11272276981914331, 0.009715796905354068, 0.1171635019061199, 0.16566144423239848, 0.14709390330267524, 0.12629360042204496, 0.12037687075505232, 0.10062518734333992, 0.0811791545339986, 0.004896477749284145, 0.14804194608714738, 0.1373672464456206, 0.14197243564240125, 0.12648142308837862, 0.15803260285868248, 0.12008537461656488, 0.027123007142392908, 0.10028491854163235, 0.21417725743357607, 0.1816869513299082, 0.08821036567725571, 0.1771000008817083, 0.21223333124264343, 0.14395344360822548, 0.04414173977700386, 0.06643376370014664, 0.13107927692169596, 0.07903761431882117, 0.12407484807485503, 0.07976722469328479, 0.15920616732172732, 0.17146415634873335, 0.2115311840208136, 0.06478848391748215, 0.01486509898757049, 0.13578149060347755, 0.18596497296512382, 0.1464823091530434, 0.2533628418810707, 0.1935636593391905, 0.039757432904337975, 0.031174975424491436, 0.1731009344610328, 0.15095530127553047, 0.07153561629543503])


ind = []
for i, n in enumerate(a):
    if n > 0.05:
        ind += [i]

print ind
print len(ind)

#+END_SRC

#+RESULTS:
: [7, 43, 47, 49, 51, 55, 62, 66, 70, 74, 75, 79, 80, 81, 82, 88, 89, 90, 94, 95, 96, 97, 101, 102, 106, 109, 113, 114, 117, 118, 119, 123, 124, 125, 126, 127, 128, 131, 132, 134, 135, 136, 139, 140, 141, 142, 143, 145, 146, 147, 149, 150, 151, 155, 157, 158, 159, 160, 161, 162, 163, 165, 166, 167, 168, 169, 170, 172, 173, 174, 175, 176, 177, 178, 180, 181, 182, 183, 184, 185, 186, 187, 188, 190, 191, 192, 193, 194, 197, 198, 199]
: 91

**** 1-26
#+BEGIN_SRC python
import numpy as np
from amp import Amp
from vasp import Vasp

error = []
for i in range(200):

    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD={0}'.format(i)
    calc = Vasp(wd)
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    
    calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc1)
    E1 = atoms.get_potential_energy()

    error += [abs(E0 - E1)]


print  error
#+END_SRC

#+BEGIN_SRC python
import numpy as np

a = np.array([0.07411741149203976, 0.02954248750253896, 0.05583655460068826, 0.12697752313405886, 0.08098504961668596, 0.016990457595170483, 0.03563260670222235, 0.11077077446347516, 0.08531393519771768, 0.013401119621505586, 0.04121413728123002, 0.12191980282904069, 0.08851825544311964, 0.02528018192072068, 0.030149338133753645, 0.11507037835883693, 0.08105568470659819, 0.022278911218023723, 0.0430003221677282, 0.0908711705565679, 0.10244451902036644, 0.03235398769439257, 0.027027856101341285, 0.06595270509876627, 0.06739241046241773, 0.024779021585658256, 0.010647396740921522, 0.0522197161506881, 0.09074182220649618, 0.023593334612172612, 0.002048417108397871, 0.02322071939710213, 0.07719600729100762, 0.038158121303183634, 0.034285149829884176, 0.022338563267965128, 0.08104493780396638, 0.03990929510348451, 0.004162690562651505, 0.000182724354488073, 0.06043476901740519, 0.06737634367615897, 0.004366739324154878, 0.00171733850623923, 0.03100175128781757, 0.12883206399271785, 0.058525082751316404, 0.018981388337209637, 0.008602832570261398, 0.05931051648562402, 0.0025830500864856276, 0.01642836983091911, 0.05545640558295872, 0.05344401022651368, 0.0010300690867666162, 0.01775248570223198, 0.08379144407294348, 0.07271990305997633, 0.013216321045035784, 0.03741004072287524, 0.05778818257451235, 0.013622924590833918, 0.008402347103469765, 0.03342147160094555, 0.03414680056209818, 0.06614635877460273, 0.028660334551688038, 0.05003520436906683, 0.04771003442297683, 0.06860512835706345, 0.04164648398946724, 0.04948778622159011, 0.04914712955661571, 0.031638571946245975, 0.03426126579790889, 0.051505544591918806, 0.01697431065272781, 0.08414890084992521, 0.011355779533744226, 0.05888907188187886, 0.018581007761895307, 0.010359027698171985, 0.042060677930692236, 0.04281902596036957, 0.0026024686598304925, 0.017942331711992665, 0.05386280216387718, 0.0542231430444815, 0.003100420216128441, 0.019453144447965087, 0.06552383956764629, 0.07983723800273879, 0.010469918272292489, 0.014206184627767016, 0.020328607839417145, 0.016456712142542074, 0.018284806395513442, 0.05666578239413411, 0.008236877919358676, 0.020920803764283846, 0.013879251315302099, 0.04505862810799499, 0.005900560825608636, 0.04890307075558553, 0.012004700593081452, 0.0017546156170169525, 0.04204038444677849, 0.03858926451155753, 0.051368303329383025, 0.002157165800014127, 0.03517882991198462, 0.03538939282387332, 0.005747300610153161, 0.04079020780994824, 0.06156640138360103, 0.00965281271678009, 0.08625128479826571, 0.07508717281820054, 0.10203376117581797, 0.02348609354331188, 0.0654295555210922, 0.04835409663411383, 0.01987808065868535, 0.006697800275503596, 0.08404754145468019, 0.09283929878662889, 0.044580743461665406, 0.026248031435898156, 0.053506710821096704, 0.0593759733789625, 0.10197394922204239, 0.0406337331288853, 0.04282631250890745, 0.009022186748694594, 0.03601108609964854, 0.06139667760922407, 0.07083634096176183, 0.05515165554322721, 0.06100923554868132, 0.016923049625773956, 0.08987913275390724, 0.025042202162381955, 0.05641271061031716, 0.06212734655352392, 0.08630623991123798, 0.019120571744224435, 0.026493967035435162, 0.001239155912287515, 0.016059538676529428, 0.11814775047761827, 0.1352135031850139, 0.0327498897363796, 0.0051148577206561185, 0.0008889118671788765, 0.11606743662866847, 0.14439844469711716, 0.0613640638532047, 0.001586847901563715, 0.014964570635612517, 0.045599351854463066, 0.059079007025985675, 0.1201003536581311, 0.006707994740850154, 0.021911256730135165, 0.06968839920699565, 0.05722772914998586, 0.010284158120157372, 0.05804763296055171, 0.071494618597427, 0.0864365071828388, 0.06040696459336914, 0.06848851565226255, 0.026595772395296535, 0.019942937809531713, 0.05707330535079791, 0.0391890406848745, 0.03686919118840137, 0.04565923196753374, 0.015683793239617216, 0.08586323411947205, 0.05376864628425437, 0.062239232923559484, 0.13128933167726586, 0.0907316383128034, 0.037513866236025706, 0.04639628468501655, 0.05772162953428506, 0.07420482757194691, 0.05183514829889191, 0.030984867342880307, 0.060469153143969834, 0.03144705483987309, 0.0705135487817472, 0.05061525049160309, 0.07667590347199393, 0.0034034921438319543, 0.04589374172988414, 0.05780838692496104, 0.012138759791611164, 0.06101772815608797])


ind = []
for i, n in enumerate(a):
    if n > 0.05:
        ind += [i]

print ind
print len(ind)

#+END_SRC

#+RESULTS:
: [0, 2, 3, 4, 7, 8, 11, 12, 15, 16, 19, 20, 23, 24, 27, 28, 32, 36, 40, 41, 45, 46, 49, 52, 53, 56, 57, 60, 65, 67, 69, 75, 77, 79, 86, 87, 90, 91, 97, 108, 114, 116, 117, 118, 120, 124, 125, 128, 129, 130, 135, 136, 137, 138, 140, 142, 143, 144, 149, 150, 154, 155, 156, 160, 161, 164, 165, 167, 168, 169, 170, 171, 174, 179, 180, 181, 182, 183, 186, 187, 188, 190, 192, 193, 194, 197, 199]
: 87

**** 1-35
#+BEGIN_SRC python
import numpy as np
from amp import Amp
from vasp import Vasp

error = []
for i in range(100):

    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD={0}'.format(i)
    calc = Vasp(wd)
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    
    calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc1)
    E1 = atoms.get_potential_energy()

    error += [abs(E0 - E1)]


print  error
#+END_SRC


#+BEGIN_SRC python
import numpy as np

a = np.array([0.08796965805677814, 0.058057593859729195, 0.0710059713752571, 0.11434034124707182, 0.10058972905684982, 0.055661099799408476, 0.06743993893093148, 0.11584842232224446, 0.09414328552054485, 0.058747140353631266, 0.07873765673718935, 0.1363054833003332, 0.10656323506694321, 0.04649455074175535, 0.03518726010153728, 0.09132132578341157, 0.16066269795618382, 0.10790728180131737, 0.06398119128974145, 0.06089305008021029, 0.10424046619124283, 0.10400472899723923, 0.0461435030491657, 0.11276547129685355, 0.14914986164049537, 0.1253616395453605, 0.04469014321497866, 0.006560869630391153, 0.054324591539455014, 0.12206870295105432, 0.08239102173894253, 0.043262158904639136, 0.10189897794703029, 0.10839591845649466, 0.10222940545909864, 0.08408052077643902, 0.07785423196929742, 0.09887857267909794, 0.0678178626233148, 0.09398743871824422, 0.06816800642073417, 0.10650801408931443, 0.09635651954607738, 0.06863690455958249, 0.04678083425727664, 0.0999441031644892, 0.138586316220767, 0.06070472455891718, 0.03052550981166746, 0.0623832216371909, 0.11548607080351303, 0.08303006977618566, 0.08394731481251938, 0.06294165606317392, 0.04017985692033221, 0.0950742979849224, 0.12108649320526865, 0.11163546109449385, 0.0813957600306594, 0.10976238923771575, 0.08669009674977701, 0.019287991516932834, 0.0847202458816696, 0.09926417763554696, 0.13304675571123425, 0.07151953470258832, 0.028462396394701273, 0.053099703354803296, 0.13336130003671087, 0.044463265880182234, 0.011936694887594967, 0.0867157800803966, 0.17830826726347482, 0.10093981260152418, 0.018066948672469607, 0.023738505400302756, 0.12283903463446677, 0.14182172428186846, 0.06969992729275987, 0.012324302036745394, 0.05680703953584043, 0.05962879833697343, 0.010245318146388627, 0.10235086517340619, 0.21161735116908176, 0.18932344523619804, 0.006952243040444728, 0.007084410290730148, 0.07692102438616644, 0.15634340313368966, 0.15214305200365175, 0.13334754134683635, 0.05464686187571033, 0.03929106757712475, 0.10293888580969224, 0.15967318697394717, 0.09379856602780023, 0.10632403725441009, 0.11259183892710212, 0.14133820167549516])


ind = []
for i, n in enumerate(a):
    if n > 0.05:
        ind += [i]

print ind
print len(ind)

#+END_SRC

#+RESULTS:
: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 20, 21, 23, 24, 25, 28, 29, 30, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 45, 46, 47, 49, 50, 51, 52, 53, 55, 56, 57, 58, 59, 60, 62, 63, 64, 65, 67, 68, 71, 72, 73, 76, 77, 78, 80, 81, 83, 84, 85, 88, 89, 90, 91, 92, 94, 95, 96, 97, 98, 99]
: 80

**** 1-47
#+BEGIN_SRC python
import numpy as np
from amp import Amp
from vasp import Vasp

error = []
for i in range(100):

    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_47/MD={0}'.format(i)
    calc = Vasp(wd)
    atoms = calc.get_atoms()
    E0 = atoms.get_potential_energy()
    
    calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc1)
    E1 = atoms.get_potential_energy()

    error += [abs(E0 - E1)]


print  error
#+END_SRC


#+BEGIN_SRC python
import numpy as np

a = np.array([0.12495008235387672, 0.0987504264638801, 0.11859495618219285, 0.14446440733343024, 0.1341602309968266, 0.12804619462403366, 0.11059963835535314, 0.11201248098706174, 0.14683715660228813, 0.15803614156411072, 0.1490846188239061, 0.14953403571297486, 0.1668282869777613, 0.11222567297085106, 0.09876482406252762, 0.17721003811325886, 0.21837555102905526, 0.178279757642116, 0.09614482079393838, 0.11501186682318121, 0.11050549959205114, 0.11812894029449694, 0.14578834183865297, 0.1696607451102352, 0.15466470392695442, 0.1371473414267257, 0.10254079510872316, 0.1377572727770655, 0.1909365556072089, 0.17397784568748875, 0.1846228998304298, 0.23475590258212264, 0.18345498880287892, 0.12121902029952025, 0.13061280805476372, 0.18893208625385682, 0.1983350475950374, 0.17206078793876145, 0.11991585709378683, 0.202771951331016, 0.19773548119920292, 0.16143689003175155, 0.12436446452528571, 0.13236085233086214, 0.22832634331621193, 0.18347175676493066, 0.12180942604302913, 0.21849337030593574, 0.23439970385501852, 0.17024872903104438, 0.15517239638055003, 0.18354620826036694, 0.16918129425116035, 0.08518404599095675, 0.15240287103881656, 0.11618917907546233, 0.12244822219480511, 0.08278841334194453, 0.042052006463563885, 0.18549890017322923, 0.1596822136205276, 0.16977178790347125, 0.07457728218102488, 0.14913251699670127, 0.25148848541394386, 0.17413647830076684, 0.2268514381246689, 0.21823233222431782, 0.19760910676072285, 0.11998202915063416, 0.038077282909796395, 0.18731172818991126, 0.2465200710530837, 0.20870898288544026, 0.1409474912219082, 0.10970715681622778, 0.18065378136944332, 0.1155426773974284, 0.12441121571242775, 0.2560961815156588, 0.2727079805039523, 0.1542788126726009, 0.1550879377306842, 0.2593662290331622, 0.24208679230650887, 0.16538578453722153, 0.1774447521888476, 0.2164467618212882, 0.2060228301770053, 0.22298078839040159, 0.15217987089346252, 0.1724618309921766, 0.1520666493763656, 0.19560534702605992, 0.14305129569660835, 0.12225159802855501, 0.2960528062563128, 0.15846633377626063, 0.18159227002990974, 0.1783507079498179])


ind = []
for i, n in enumerate(a):
    if n > 0.05:
        ind += [i]

print ind
print len(ind)

#+END_SRC

#+RESULTS:
: [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]
: 98

*** Surface
#+BEGIN_SRC python
from vasp import Vasp
import numpy as np

factor = [1.00]

for x in factor:
    wd = 'NDFT/surface=fcc111/supercell=22/factor={:.2f}'.format(x)

    calc = Vasp(wd)
    calc.write_db('./database/db2/train-surface.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:

** DB3
*** DBkey2
#+BEGIN_SRC pythdon
from vasp import Vasp
import numpy as np

factor = np.linspace(0, 0.04, 41)

for x in factor:
    wd = './NDFT/bulk=fcc/type=elastic/dirs=11/factor={:.3f}'.format(x)

    calc = Vasp(wd)
    calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
import numpy as np

factor = np.linspace(0, 0.04, 41)

for x in factor:
    wd = './NDFT/bulk=fcc/type=elastic/dirs=44/factor={:.3f}'.format(x)

    calc = Vasp(wd)
    calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:


#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
from ase.calculators.singlepoint import SinglePointCalculator as SPC
from ase.db import connect

db = connect('database/db2/data.db')
E0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb-initial').potential_energy
E = []
calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb')
images, energies = calc.get_neb()

E = E0 + energies


[atoms.set_calculator(SPC(atoms, energy=E[i]))
for i, atoms in enumerate(images)]

#for i, atoms in enumerate(images):
#    E += [atoms.get_potential_energy()]


for i, atoms in enumerate (images):
    db.write(atoms, {'bulk':'fcc', 'dbkey':2, 'type':'neb', 'supercell':223})
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
from ase.calculators.singlepoint import SinglePointCalculator as SPC
from ase.db import connect

db = connect('database/db2/data.db')
E0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb-initial').potential_energy
E = []
calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb')
images, energies = calc.get_neb()

E = E0 + energies


[atoms.set_calculator(SPC(atoms, energy=E[i]))
for i, atoms in enumerate(images)]

#for i, atoms in enumerate(images):
#    E += [atoms.get_potential_energy()]


for i, atoms in enumerate (images):
    db.write(atoms, {'bulk':'fcc', 'dbkey':2, 'type':'neb', 'supercell':233})
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp

for cell in ['222', '223', '233', '333']:

    for i in range(9):
        wd = './NDFT/bulk=fcc/type=neb/supercell={0}/image={1}'.format(cell, i)
        calc = Vasp(wd)
        calc.write_db('database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []
a = [86, 87, 88, 90, 91, 92, 97, 98, 99, 100, 101, 106, 107, 108, 109, 111, 112, 116, 117, 118, 120, 121, 122, 123, 129, 130, 131, 132, 133, 134, 141, 142, 143, 144, 145, 150, 151, 152, 153, 176, 177, 178, 179, 180, 181, 182, 183, 184, 188, 189, 190, 191, 196, 197, 198, 199]
for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/MD={0}'.format(i)  
    calc = Vasp(wd)
    
    calc.write_db('database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []
a = [0, 3, 7, 8, 11, 12, 20, 21, 28, 39, 43, 46, 50, 51, 53, 54, 57, 58, 59, 60, 64, 65, 66, 67, 68, 69, 71, 72, 73, 79, 80, 88, 91, 92, 98, 99, 101, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 118, 119, 120, 121, 122, 123, 124, 125, 127, 128, 129, 131, 132, 133, 134, 135, 136, 137, 138, 142, 143, 144, 145, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 184, 185, 186, 187, 188, 189, 190, 191, 192, 194, 195, 196, 197, 198, 199]
for i in a:  
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_11/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []
a =  [7, 43, 47, 49, 51, 55, 62, 66, 70, 74, 75, 79, 80, 81, 82, 88, 89, 90, 94, 95, 96, 97, 101, 102, 106, 109, 113, 114, 117, 118, 119, 123, 124, 125, 126, 127, 128, 131, 132, 134, 135, 136, 139, 140, 141, 142, 143, 145, 146, 147, 149, 150, 151, 155, 157, 158, 159, 160, 161, 162, 163, 165, 166, 167, 168, 169, 170, 172, 173, 174, 175, 176, 177, 178, 180, 181, 182, 183, 184, 185, 186, 187, 188, 190, 191, 192, 193, 194, 197, 198, 199]
for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_17/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []
a = [0, 2, 3, 4, 7, 8, 11, 12, 15, 16, 19, 20, 23, 24, 27, 28, 32, 36, 40, 41, 45, 46, 49, 52, 53, 56, 57, 60, 65, 67, 69, 75, 77, 79, 86, 87, 90, 91, 97, 108, 114, 116, 117, 118, 120, 124, 125, 128, 129, 130, 135, 136, 137, 138, 140, 142, 143, 144, 149, 150, 154, 155, 156, 160, 161, 164, 165, 167, 168, 169, 170, 171, 174, 179, 180, 181, 182, 183, 186, 187, 188, 190, 192, 193, 194, 197, 199]
for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.db import connect

db = connect('./database/db3/data.db')


del db[1089]
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 20, 21, 23, 24, 25, 28, 29, 30, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 45, 46, 47, 49, 50, 51, 52, 53, 55, 56, 57, 58, 59, 60, 62, 63, 64, 65, 67, 68, 71, 72, 73, 76, 77, 78, 80, 81, 83, 84, 85, 88, 89, 90, 91, 92, 94, 95, 96, 97, 98, 99]

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []
for i in range(100):
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_47/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)
del a[9]
for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_63/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []

#a = range(0, 21)
#a = range (23, 50)
a = range(0, 50)
del a[11]
del a[21]
#print a

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=1/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 


#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=2/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=3/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=4/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('database/db2/data.db', parser='=', overwrite=False, keys={'dbkey':2}) 
#+END_SRC

#+RESULTS:
** keywords
#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

from ase.db import connect

db = connect('./database/db2/train-surface.db')
data = db.select(['calculator'])

keys, cnt = {}, 0
for entry in data:
    cnt += 1
    for k, v in entry.key_value_pairs.iteritems():
        
        if k in keys:
            keys[k] += [v]
        else:
            keys[k] = [v]

print ('{0:15s} {1:15s} {2} calculations total'.format('keyword', 'value',cnt))

print('------------------------------------------------------')

for k, v in keys.iteritems():
    vals = list(set(v))
    if len(vals) <= 5:
        val = ", ".join(str(e) for e in vals)
        print('{0:15}: {1}'.format(k, val))

    else:
        val = ", ".join(str(e)[:5] for e in vals[:5])
        print('{0:15s}:{1}, etc...'.format(k, val))
#+END_SRC

#+RESULTS:
#+begin_example
keyword         value           1971 calculations total
------------------------------------------------------
dirs           : 11, 44
MD             :0, 1, 2, 3, 4, etc...
train_set      : True
image          : 1, 2, 3, 4
dbkey          : 0, 1, 2
bulk           : sc, hcp, fcc, diam, bcc
lattice        : primitive, cubic
supercell      :33, 233, 333, 334, 22, etc...
v_a            :1_26, 1_47, 1_63, 1_11, 1_17, etc...
surface        : fcc111
factor         :1.75, 1.5, 2.0, 0.0, 1.0, etc...
type           : eos, md, vacancy, elastic
order          : md2, md0, md1
#+end_example

* Training
** Training Set
#+BEGIN_SRC python
from ase.db import connect
import os
import random
import numpy as np

db = connect('./database/db2/data.db')

n = db.count()
n_train = int(round(n * 0.9))

n_ids =  np.array(range(n)) + 1

# This will sudo-randomly select 10% of the calculations
# Which is useful for reproducing our results.
random.seed(256)
train_samples = random.sample(n_ids, n_train)
valid_samples = set(n_ids) - set(train_samples)

db.update(list(train_samples), train_set=True)
db.update(list(valid_samples), train_set=False)

with connect('./database/db2/train-sur.db') as db0:
    for d in db.select(['train_set=True']):
        db0.write(d, key_value_pairs=d.key_value_pairs)
#+END_SRC

#+RESULTS:

** Train
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

# We will try an iteration for n nodes with l hidden layers.
for l in [2]:
    
    for n in [15, 18, 20, 25, 30]:

        label = '{0}-{1}-0'.format(l,n)
        layer=(l,n)
        wd = os.path.join(home, './database/db2/' + label)

        if not os.path.exists(wd):
            os.makedirs(wd)

        os.chdir(wd)

        run_amp = '''#!/usr/bin/env python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

calc = Amp(label="./",
           descriptor=Behler(cutoff=6.5),
           regression=NeuralNetwork(hiddenlayers={0}))

calc.train("~/Research/Bulk/database/db2/train.db", # The training data
           cores=2,
           extend_variables=False) 
'''.format(layer)

        cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=2
#PBS -l walltime=168:00:00
#PBS -l mem=16GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

        with open('submit.py', 'w') as f:
            f.write(run_amp)
        os.chmod('submit.py', 0777)

        with open('submit.sh', 'w') as f:
            f.write(cmd)

        subprocess.call(['qsub', 'submit.sh'])
        time.sleep(5)
        os.unlink('submit.sh')
        os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1446899.gilgamesh.cheme.cmu.edu
: 1446900.gilgamesh.cheme.cmu.edu
: 1446901.gilgamesh.cheme.cmu.edu
: 1446902.gilgamesh.cheme.cmu.edu
: 1446903.gilgamesh.cheme.cmu.edu
: 1446904.gilgamesh.cheme.cmu.edu
#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *
import os

for n in [15]:
    label = '2-{0}-0'.format(n)
    wd = os.path.join(os.getcwd(), 'database/db2/' + label)

    if not os.path.exists(wd):
        os.makedirs(wd)

    calc = Amp(load='./database/db2/2-{0}-0/-parameters-checkpoint-1.json'.format(n),
               label="./database/db2/{0}/".format(label),
               descriptor=Behler(cutoff=6.0),
               regression=NeuralNetwork(hiddenlayers=(2, '{0}'.format(n))))


    calc.train('./database/db2/train.db', # The training data
               cores=1,
               extend_variables=False) # feature does not work properly and will crash
#+END_SRC

#+RESULTS:

retrain
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

# We will try an iteration for n nodes with l hidden layers.
for l in [2]:
    
    for n in [30]:

        label = '{0}-{1}-sur2'.format(l,n)
        layer=(l,n)
        wd = os.path.join(home, './database/db2/' + label)

        if not os.path.exists(wd):
            os.makedirs(wd)

        os.chdir(wd)

        run_amp = '''#!/usr/bin/env python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

calc = Amp(load="./-parameters-checkpoint-1.json",
           label="./",
           descriptor=Behler(cutoff=6.5),
           regression=NeuralNetwork(hiddenlayers={1}))

calc.train("~/Research/Bulk/database/db2/train-sur.db", # The training data
           cores=4,
           extend_variables=False) 
'''.format(n, layer)

        cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=168:00:00
#PBS -l mem=16GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

        with open('submit.py', 'w') as f:
            f.write(run_amp)
        os.chmod('submit.py', 0777)

        with open('submit.sh', 'w') as f:
            f.write(cmd)

        subprocess.call(['qsub', 'submit.sh'])
        time.sleep(5)
        os.unlink('submit.sh')
        os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1449339.gilgamesh.cheme.cmu.edu

*** sur
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

# We will try an iteration for n nodes with l hidden layers.
for l in [2]:
    
    for n in [10, 15]:

        label = '{0}-{1}-sur'.format(l,n)
        layer=(l,n)
        wd = os.path.join(home, './database/db2/' + label)

        if not os.path.exists(wd):
            os.makedirs(wd)

        os.chdir(wd)

        run_amp = '''#!/usr/bin/env python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

calc = Amp(label="./",
           descriptor=Behler(cutoff=6.5),
           regression=NeuralNetwork(hiddenlayers={0}))

calc.train("~/Research/Bulk/database/db2/train-sur.db", # The training data
           cores=2,
           extend_variables=False) 
'''.format(layer)

        cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=2
#PBS -l walltime=168:00:00
#PBS -l mem=8GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

        with open('submit.py', 'w') as f:
            f.write(run_amp)
        os.chmod('submit.py', 0777)

        with open('submit.sh', 'w') as f:
            f.write(cmd)

        subprocess.call(['qsub', 'submit.sh'])
        time.sleep(5)
        os.unlink('submit.sh')
        os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1447032.gilgamesh.cheme.cmu.edu
: 1447033.gilgamesh.cheme.cmu.edu

** Update

#+BEGIN_SRC python
from ase.db import connect
from amp import Amp

db = connect('./database/db2/data.db')
calc1 = Amp(load = './database/db2/2-20-0/-parameters-checkpoint-0.json')
calc2 = Amp(load = './database/db2/2-30-sur2/-parameters-checkpoint-0.json')

for d in db.select():
    atoms = db.get_atoms(d.id)
    atoms.set_calculator(calc1)
    nrg1 = atoms.get_potential_energy()

    atoms.set_calculator(calc2)
    nrg2 = atoms.get_potential_energy()
    db.update(d.id, NN20 = nrg1, NN30 = nrg2)
#+END_SRC

#+RESULTS:

** Residual
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from ase.db import connect
from amp import Amp
import os

db = connect('database/db2/data.db')

fig, ax = plt.subplots(1, 2, sharey=True, figsize=(8, 4))

for i, n in enumerate([20, 30]):

    E, nnE, var, ind = [], [], [], []
    for j, d in enumerate(db.select('')):# dbkey=0
	E += [d.energy / d.natoms]
	nnE += [d['NN{}'.format(n)]/ d.natoms]
	var += [j]
	ind += [d.train_set]

    res = np.array(nnE) - np.array(E)
    mask = np.array(ind)
    valid = np.ma.masked_array(res, mask)
    train = np.ma.masked_array(res, ~mask)
    vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
    tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))

    ax[i].text(200, -0.050,
               'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
               color='b', ha='left')
    ax[i].text(200, -0.057,
               'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
               color='r', ha='left')

    ax[i].scatter(var, train, color='b')
    ax[i].scatter(var, valid, color='r')
    ax[i].plot([min(var), max(var)], [0, 0], 'k--')
    ax[i].set_xlim(min(var), max(var))

    ax[i].set_xlabel('Calculation ID')
    ax[i].set_title('8-{0}-{0}-1 framework'.format(n))

ax[0].set_ylim(-0.060, 0.060)
ax[0].set_ylabel('Residual error (eV/atom)')
plt.tight_layout()
plt.savefig('./figures/residual-2.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/residual-2.png]]
Large error configurations
#+BEGIN_SRC python
import numpy as np
from ase.db import connect
ids = []
db = connect('database/db2/data.db')
for i, d in enumerate(db.select('')):
    E = d.energy / d.natoms
    nE = d.NN30/ d.natoms
    if abs(E - nE) > 0.04:
        ids += [i]

print ids
#+END_SRC

#+RESULTS:
: [233, 244, 245, 301, 340, 355, 409, 410]



#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db2/data.db')

S, Qe, Ne = [], [], []

for d in db.select([]):
    S += [d.v_a]
    Qe += [d.energy/d.natoms]
    Ne += [d.NN30/d.natoms]
    
S = np.array(S)
Qe = np.array(Qe)
Ne = np.array(Ne)

cmap, hdl = {}, []

for s, c in zip(set(S), ['b', 'r', 'g', 'c', 'm']):
    cmap[s] = c
    hdl +=[mpatches.Patch(color = c, label = s)]

c = []
for s in S:
    c +=[cmap[s]]

RMSE = np.sqrt(sum((Ne-Qe)** 2) / len(Ne - Qe))

(mu, sigma) = norm.fit(Ne- Qe)

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
ax0.plot([min(Qe), 0], [0,0], 'k--', lw =2)
ax0.scatter(Qe, Ne-Qe, marker = 'o', color = c)
ax0.text(min(Qe) + 0.1, 0.14,
         'RMSE: {0:1.3f}'.format(RMSE),
         fontsize = 12, va = 'top', ha = 'left')
ax0.set_xlim(min(Qe), 0)
ax0.set_ylim(-0.045, 0.045)
ax0.set_xlabel('DFT potential energy (eV/atom)')
ax0.set_ylabel('Rsidual error (eV/atom)')
ax0.legend(loc = 'best', handles =hdl, fontsize = 8, frameon = False)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(Ne-Qe, 50,
                            range = (-0.01, 0.01),
                            weights = np.ones_like(Ne-Qe)/ len(Ne),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.05, 0.142, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.05, 0.122, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.01, 0.01)
ax1.set_xlim(0, 0.3)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
plt.tight_layout(w_pad = -0.5)
#plt.savefig('./images/fig-neural-train.png')
plt.show()

#+END_SRC

#+RESULTS:

* Application
** MD
*** Trajectory
**** NEB
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

for cell in ['222', '223', '233', '333']:
    
    for img in [1, 2, 3, 4]:
        
        label = '{0}-{1}'.format(cell, img)
        
        wd = os.path.join(home, './database/db2/' + label)

        if not os.path.exists(wd):
            os.makedirs(wd)

        os.chdir(wd)


        run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from vasp import Vasp

calc = Vasp("./../../../NDFT/bulk=fcc/type=neb/supercell=222/neb")
images, energies = calc.get_neb()


atoms = images[1]

atoms.set_calculator(Amp(load="./../2-30-0/-parameters-checkpoint-1.json"))
        
dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

        cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

        with open('submit.py', 'w') as f:
            f.write(run_md)
        os.chmod('submit.py', 0777)

        with open('submit.sh', 'w') as f:
            f.write(cmd)

        subprocess.call(['qsub', 'submit.sh'])
        time.sleep(5)
        os.unlink('submit.sh')
        os.chdir(wd)
#+END_SRC

#+BEGIN_SRC python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from vasp import Vasp

import os
import subprocess
import time

home = os.getcwd()

for cell in ['222', '223', '233', '333']:
    
    for img in [1, 2, 3, 4]:
        
        label = '{0}-{1}'.format(cell, img)
        
        wd = os.path.join(home, './database/db2/' + label)

        if not os.path.exists(wd):
            os.makedirs(wd)

        os.chdir(wd)


        calc = Vasp("./../../../NDFT/bulk=fcc/type=neb/supercell=222/neb")
        images, energies = calc.get_neb()


        atoms = images[1]

        atoms.set_calculator(Amp(load="./../2-30-0/-parameters-checkpoint-1.json"))
        
        dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


        def printenergy(a=atoms):
            epot = a.get_potential_energy() / len(a)
            ekin = a.get_kinetic_energy() / len(a)
    
        dyn.attach(printenergy, interval=10)

        traj = Trajectory("./MD.traj", "w", atoms)
        dyn.attach(traj.write, interval=10)

        dyn.run(2000)

#+END_SRC

**** Surface
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

label = '225-surface'
wd = os.path.join(home, './database/db2/' + label)

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(2, 2, 5), a=3.939, vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(Amp(load="./../2-30-0/-parameters-checkpoint-1.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD-fixed.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1451040.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

label = '335-surface'
wd = os.path.join(home, './database/db2/' + label)

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(3, 3, 5), a=3.939, vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(Amp(load="./../2-30-0/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD-fixed.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=48:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIRq
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1451727.gilgamesh.cheme.cmu.edu


#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db2/2-20-0/-parameters-checkpoint-0.json')
images = Trajectory('./database/db2/225-surface/MD.traj', 'r')
Ed = []
En = [images[i].get_potential_energy() for i in range(200)]
for i in range(200):
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md0/v_a=0_20/MD={}'.format(i))
    Ed += [calc.potential_energy]

plt.plot(range(len(En)), En, 'b-', label='NN prediction')
plt.scatter(range(len(Ed)), Ed, facecolor='none',
	   edgecolor='r', label='DFT calculation')

plt.xlim([0, 200])
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('222surface-md.png')
plt.show()
#+END_SRC

[[./figures/222surface-md.png]]

*** NN Predict
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db2/2-20-0/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db2/333-4/MD.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
plt.show()
#plt.savefig('./figures/MD1-7-2.png')
#+END_SRC

#+RESULTS:

*** Bulk
**** 8000
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

label = '0-8'
wd = os.path.join(home, './database/db2/' + label)

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(2, 2, 2))
atoms.set_calculator(Amp(load="./../2-30-0/-parameters-checkpoint-1.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(8000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=48:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1451037.gilgamesh.cheme.cmu.edu

*** Vacancy
**** 1-63
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

label = '1-63'
wd = os.path.join(home, './database/db2/' + label)

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

atoms = FaceCenteredCubic("Pd",
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939,
                          size=(4, 4, 4))

del atoms[0]
atoms.set_calculator(Amp(load="./../2-30-0/-parameters-checkpoint-1.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=20)

traj = Trajectory("./MD-long.traj", "w", atoms)
dyn.attach(traj.write, interval=20)

dyn.run(4000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=168:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1451758.gilgamesh.cheme.cmu.edu


#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
import jbtools.gilgamesh as jb

Ne = []
for i, atoms in enumerate(Trajectory('./database/db0/MD.traj', 'r')):

    Ne += [atoms.get_potential_energy()]

plt.plot(range(len(Ne)), Ne, 'bo')
#plt.savefig('./images/MD-NN.png')
plt.show()
#+END_SRC

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db2/2-20-0/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
traj = Trajectory('./database/db2/1-63/MD.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
#plt.show()
plt.xlabel('MD Step')
plt.ylabel('Energy eV')
plt.legend()
plt.savefig('./figures/MD1-63-3.png')

#+END_SRC

#+RESULTS:

[[./figures/MD1-63-3.png]]

** NEB-NN
#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb')
images, energies = calc.get_neb()

En, E = [], []
calc2 = Amp(load='./networks/db10/18-18/checkpoint-parameters.json')

for atoms in images:
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

En = np.array(En)
E = En-En[0]
x = range(len(images))
xarray = np.linspace(0, len(images))
f1 = interp1d(x, energies, kind='cubic', bounds_error=False)
f2 = interp1d(x, E, kind='cubic', bounds_error=False)
plt.plot(x, energies, 'bo', label = 'NEB')
plt.plot(x, E, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
plt.show()
#+END_SRC
#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
from amp import Amp

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
images, energies = calc.get_neb()

calc0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb-initial')
E0 = calc0.potential_energy

energies = np.array(energies)
energies += E0

print energies


En, E = [], []
calc2 = Amp('./database/db2/2-30-0/-parameters-checkpoint-0.json')

for atoms in images:
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

print En
#+END_SRC

#+RESULTS:
: [-35.43371164 -35.42570645 -35.19608912 -34.88827938 -34.75807484
:  -34.88827927 -35.19608898 -35.42570641 -35.43371169]
: [-35.322470231901875, -35.31849228646374, -35.156207100533905, -34.85637361556328, -34.68250391909649, -34.85637347354207, -35.15620697841968, -35.31849225982069, -35.32247023190192]

** Bulk Properties
*** Cohesive energy
Atomic energy
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase import Atoms, Atom
from ase.visualize import view
VASPRC['queue.walltime'] = '24:00:00'

atoms = Atoms([Atom('Pd', [5, 5, 5])],
              cell = (7, 8, 9))

calc = Vasp('NDFT/atomic-Pd',
          xc = 'pbe',
          encut = 350,
          kpts = [1]*3,
          atoms = atoms) 

calc.calculate()

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/atomic-Pd submitted: 1442984.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
from vasp import Vasp
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')

calc = Vasp ('./NDFT/atomic-Pd') 
Eatom = calc.potential_energy
 
calc = Vasp ('./NDFT/bulk=fcc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEfcc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEfcc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=bcc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEbcc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEbcc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=hcp/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEhcp = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEhcp = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=sc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEsc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEsc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=diam/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEdiam = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEdiam = atoms.get_potential_energy()/len(atoms)
print DEfcc-Eatom, NEfcc-Eatom
print DEbcc-Eatom, NEbcc-Eatom
print DEhcp-Eatom, NEhcp-Eatom
print DEsc-Eatom, NEsc-Eatom
print DEdiam-Eatom, NEdiam-Eatom
#+END_SRC

#+RESULTS:
: -3.75476834 -3.75589508423
: -3.71312559 -3.73790838482
: -3.72459561 -3.76095602827
: -3.2532599 -3.26704062214
: -2.6162620675 -2.61824650251

*** Bulk Modulus
#+BEGIN_SRC python
from ase.db import connect
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState
from ase.units import kJ
import numpy as np
from vasp import Vasp
from amp import Amp

factor = np.arange(0.85, 1.2, 0.01)
calc2 = Amp(load = './database/db1/2-24-2/-parameters-checkpoint-0.json')
             #      np.arange(1.2, 2.125, 0.05))
configs = ['fcc', 'bcc', 'hcp', 'sc', 'diam']

for config in configs:
    nrg, vol = [], []
    nn = []
    for f in factor:
        calc = Vasp('./NDFT/bulk={0}/type=eos/factor={1:.2f}'.format(config,f))
        atoms = calc.get_atoms()
        nrg += [atoms.get_potential_energy()/len(atoms)]
        vol += [atoms.get_volume()/len(atoms)]
        atoms.set_calculator(calc2)
        nn +=[atoms.get_potential_energy()/len(atoms)]
        

    vol = np.array(vol)
    nrg = np.array(nrg)
    nn = np.array(nn)
# Fit the data to SJEOS
    eos = EquationOfState(vol, nrg)
    v0, e0, B0 = eos.fit()
    eos = EquationOfState(vol, nn)
    v1, e1, B1 = eos.fit()
    print '{0}'.format(config)
    print v0, e0, B0
    print v1, e1, B1
#+END_SRC

#+RESULTS:
#+begin_example
fcc
15.2979724806 -5.22438476072 1.09507457295
15.3564270183 -5.21520156705 1.07945263208
bcc
15.4257962561 -5.18249419589 1.06469804063
15.3991596967 -5.19211684448 1.08071951009
hcp
15.3645769219 -5.19379582623 1.08254355793
15.3341063992 -5.21621811798 1.09987534388
sc
17.8024966568 -4.72110919112 0.782438954048
17.8334288446 -4.71777979115 0.775358668286
diam
24.3558101786 -4.08130798908 0.428150007251
24.346708419 -4.08117208591 0.428715107213
#+end_example

*** Elastic Constant
**** 11, 12
#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.01, 11)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=11/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load='./database/db2/2-30-0/-parameters-checkpoint-1.json')
    #calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
#+END_SRC

#+RESULTS:
: [ 2.22936683 -0.34128023]
: [ 3.51781497 -0.34109004]

#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.01, 11)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=11/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load='./database/db2/2-30-0/-parameters-checkpoint-1.json')
    #calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')

    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
plt.plot(factor, Ed/Vd[0], 'bo', label = 'DFT')
plt.plot(factor, En/Vd[0], 'ro', label = 'NN')
plt.plot(factor, func(factor, *poptd), 'b-', label = 'DFT fit')
plt.plot(factor, func(factor, *poptn), 'r-', label = 'NN fit')

plt.xlabel('Strain')
plt.ylabel('Energy Density [eV/$\AA^3$]')
plt.legend(loc='best')
#plt.savefig('./figures/elastic-1.png')
plt.show()
#+END_SRC

#+RESULTS:
: [ 2.22936683 -0.34128023]
: [ 3.51781497 -0.34109004]

**** 44
#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.01, 11)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=44/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load='./database/db2/2-30-0/-parameters-checkpoint-1.json')
    #calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
#+END_SRC

#+RESULTS:
: [ 0.73280411 -0.34127966]
: [ 0.8152848 -0.3410909]

**** calculation
#+BEGIN_SRC python
'''
B = 1.09507457295
a = 2.21553499/6
b = 0.66616554
'''

B = 1.0950
a = 3.0178/6
b = 0.8153
C4 = b/2
C2 = (3*B - 2*a)/3
C1 = 2*a + C2

print C1, C2, C4
print C1 * 160.2177
print C2 * 160.2177
print C4 * 160.2177
#+END_SRC

#+RESULTS:
: 1.76562222222 0.759688888889 0.40765
: 282.883931513
: 121.715606493
: 65.312745405

**** reference 
#+BEGIN_SRC python
from vasp import Vasp
calc = Vasp('~/Research/Bulk/DFT/bulk=fcc/type=elastic/elastic')

EM = calc.get_elastic_moduli()

print EM
#+END_SRC

#+RESULTS:
: [[ 206.71093  155.54113  155.54113    0.         0.         0.     ]
:  [ 155.54113  206.71093  155.54113    0.         0.         0.     ]
:  [ 155.54113  155.54113  206.71093    0.         0.         0.     ]
:  [   0.         0.         0.        59.78395    0.         0.     ]
:  [   0.         0.         0.         0.        59.78395    0.     ]
:  [   0.         0.         0.         0.         0.        59.78395]]

** Vacancy formation
*** 222
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=222/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*7
print Ev
#+END_SRC

#+RESULTS:
: 1.06765175


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 2, 2)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (7/8.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  10:04:17      -35.323077       0.0000
: Vacancy formation energy with NN is: 1.158 eV
: -41.6921809084
: -35.3230768877

*** 223
     
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=223/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*11
print Ev
#+END_SRC

#+RESULTS:
: 1.13510973


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 2, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (11/12.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  10:08:55      -56.116879       0.7401
: BFGS:   1  10:09:01      -56.136758       0.6208
: BFGS:   2  10:09:07      -56.172858       0.1487
: BFGS:   3  10:09:13      -56.173163       0.1054
: BFGS:   4  10:09:19      -56.173243       0.0910
: BFGS:   5  10:09:24      -56.173405       0.0330
: Vacancy formation energy with NN is: 1.153 eV
: -62.5382713626
: -56.1734049327

*** 233
     
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=233/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*17
print Ev
#+END_SRC

#+RESULTS:
: 1.15516594


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 3, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (17/18.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  10:11:55      -87.352273       0.6760
: BFGS:   1  10:12:09      -87.382656       0.5809
: BFGS:   2  10:12:22      -87.449470       0.1658
: BFGS:   3  10:12:36      -87.449810       0.0709
: BFGS:   4  10:12:49      -87.449782       0.0621
: BFGS:   5  10:13:03      -87.448243       0.0260
: Vacancy formation energy with NN is: 1.148 eV
: -93.8074070438
: -87.4482427447

*** 333
     
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=333/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*26
print E1
print E0*27
print Ev
#+END_SRC

#+RESULTS:
: -134.47545389
: -140.79068946
: 1.10076559


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (3, 3, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (26/27.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  10:15:55     -134.259635       0.5909
: BFGS:   1  10:16:25     -134.295713       0.5128
: BFGS:   2  10:16:59     -134.376645       0.1256
: BFGS:   3  10:17:33     -134.373331       0.0840
: BFGS:   4  10:18:09     -134.373707       0.0736
: BFGS:   5  10:18:45     -134.374974       0.0360
: Vacancy formation energy with NN is: 1.125 eV
: -140.711110566
: -134.374974352

*** 334
     
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=334/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*35

print Ev
#+END_SRC

#+RESULTS:
: 1.07033284


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (3, 3, 4)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (35/36.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  10:40:34     -181.168995       0.4837
BFGS:   1  10:41:20     -181.198978       0.4371
BFGS:   2  10:42:06     -181.292172       0.1463
BFGS:   3  10:42:52     -181.297291       0.0998
BFGS:   4  10:43:38     -181.300006       0.0885
BFGS:   5  10:44:23     -181.306581       0.0545
BFGS:   6  10:45:09     -181.307656       0.0681
BFGS:   7  10:45:55     -181.306891       0.0800
BFGS:   8  10:46:41     -181.304284       0.0811
BFGS:   9  10:47:27     -181.299184       0.0682
BFGS:  10  10:48:13     -181.294990       0.0504
BFGS:  11  10:48:59     -181.293067       0.0459
Vacancy formation energy with NN is: 1.110 eV
-187.614814088
-181.29306683
#+end_example

*** 344
     
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=344/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*47
print Ev

#+END_SRC

#+RESULTS:
: 1.0137827


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (3, 4, 4)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (47/48.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  11:51:49     -243.709851       0.3831
BFGS:   1  11:53:00     -243.735689       0.3473
BFGS:   2  11:54:11     -243.847779       0.1092
BFGS:   3  11:55:22     -243.855635       0.1107
BFGS:   4  11:56:33     -243.868125       0.0804
BFGS:   5  11:57:45     -243.871778       0.0628
BFGS:   6  11:58:56     -243.871070       0.0440
Vacancy formation energy with NN is: 1.070 eV
-250.152955507
-243.871069593
#+end_example

*** 444
     
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=444/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*63
print Ev
#+END_SRC

#+RESULTS:
: 0.96277588


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (4, 4, 4)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (63/64.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  10:22:58     -327.095298       0.2871
: BFGS:   1  10:24:48     -327.119921       0.2601
: BFGS:   2  10:26:53     -327.231549       0.1002
: BFGS:   3  10:28:55     -327.238182       0.0787
: BFGS:   4  10:31:00     -327.259021       0.0256
: Vacancy formation energy with NN is: 1.067 eV
: -333.537447267
: -327.259021011

| Supercell | E_DFT(eV) | E_NN(eV) | Error(eV) | Error(%) |
|       222 |     1.068 |    1.158 |     0.090 |     8.42 |
|       223 |     1.135 |    1.153 |     0.018 |     1.59 |
|       233 |     1.155 |    1.148 |     0.007 |     0.61 |
|       333 |     1.101 |    1.125 |     0.024 |     2.17 |
|       334 |     1.070 |    1.110 |     0.040 |     3.73 |
|       344 |     1.014 |    1.070 |     0.056 |     5.52 |
|       444 |     0.963 |    1.067 |     0.104 |    10.80 |

** EOS
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState
from ase.db import connect
from amp import Amp
from ase.visualize import view
import os
import json
import time
from ase.units import kJ

db = connect('./database/db2/data.db')

f, ax = plt.subplots(1, 5, figsize = (12, 5))
tag = ['FCC', 'BCC', 'HCP', 'SC', 'Diamond']

for i, key in enumerate(['fcc', 'bcc', 'hcp', 'sc', 'diam']):

    V, Qe, Re, Ne = [], [], [], []

    for d in db.select(['bulk={0}'.format(key), 'type=eos']):
        V += [d.volume / d.natoms]
        Qe += [d.energy / d.natoms]
        Ne += [d.NN30 / d.natoms]

    srt = [j[0] for j in sorted(enumerate(V), key = lambda x:x[1])]
    V = np.array(V)[srt]
    Qe = np.array(Qe)[srt]
    Ne = np.array(Ne)[srt]

    ax[i].plot(V, Qe, 'k-', lw=2, label = 'DFT')
    ax[i].plot(V, Ne, 'r--', lw=2, label = 'Neural')

    if i >0:
        ax[i].set_yticklabels([])

    ax[i].set_ylim(-6 , 0)
    ax[i].set_xlim(0, 150)
    ax[i].set_xticks([0, 40, 80, 120])
    ax[i].set_title('{0}'.format(tag[i]))

ax[0].set_ylabel('Potantial energy (eV/atom)')
ax[2].set_xlabel('Volume ($\AA$/atom)')
ax[4].legend(loc = 'best', fontsize = 12)
plt.tight_layout(w_pad=-1.3)
plt.savefig('./figures/eos-NN-2.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/eos-NN-2.png]]

#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt


E1, E2 = [], []

factor = np.linspace(0.85, 2.5, 1000)
for x in factor :

    atoms = FaceCenteredCubic('Pd',
                              directions=[[0, 1, 1],
                                          [1, 0, 1],
                                          [1, 1, 0]],
                              latticeconstant=3.933)
    
    delta = np.array([[x, 0., 0.],
                      [0., x, 0.],
                      [0., 0., x]])
    atoms.set_cell(np.dot(atoms.get_cell(), delta),
                   scale_atoms=True)
    calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
    calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
    
    atoms.set_calculator(calc1)
    E1 += [atoms.get_potential_energy()]

    atoms.set_calculator(calc2)
    E2 += [atoms.get_potential_energy()]

E1 = np.array(E1)
E2 = np.array(E2)
res = abs(E1 - E2)
#print E1


f, ax = plt.subplots(2, 1, sharex=True)
ax[0].plot(factor, E1, 'b', lw=2, label='2-24')
ax[0].plot(factor, E2, 'r', lw=2, label='2-30')
ax[0].plot([0.85, 0.85], [2, -6], 'k--')
ax[0].plot([2.1, 2.1], [2, -6], 'k--')
ax[0].set_ylabel('Potential energy (eV)')
ax[0].set_xlim(0.6, 2.5)
ax[0].set_ylim(-6, 2)
ax[0].legend(loc='best')
ax[1].plot(factor, res)
ax[1].plot([0.85, 0.85], [0, 0.5], 'k--')
ax[1].plot([2.07, 2.1], [0, 0.5], 'k--')
ax[1].set_ylabel('NN energy difference (eV)')
ax[1].set_ylim(0, 0.5)
ax[1].set_xlabel('Strain/stretch factor (%)')
plt.tight_layout(w_pad=0.0)
plt.savefig('./figures/app-eos.png')
#+END_SRC

#+RESULTS:

[[./figures/app-eos.png]]


* 4th DFT
** Surface-MD
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC

Ne, nrg, res, s = [], [], [], []
calcs = []
images = Trajectory('./database/db2/225-surface/MD-fixed.traj', 'r')
#Ne = [images[i].get_potential_energy() for i in range(0, 100)]
Ne = [images[i].get_potential_energy() for i in range(0, 200)]
#for i in np.arange(0, 100, 4):
for i in range(200):        
        calc = Vasp('NDFT/surface=fcc111/type=md/order=md0/v_a=0_20/MD={}'.format(i),
                     xc='pbe',
                     kpts=[9, 9, 1],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)

plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
#plt.show()
plt.savefig('./figures/surf225.png')
#+END_SRC

[[./figures/surf225.png]]
** NEB-MD
*** 222
#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
from vasp.vasprc import VASPRC
VASPRC['queue.walltime']='24:00:00'

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
images, energies = calc.get_neb()

for i, atoms in enumerate(images):

    calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/image={0}'.format(i),
                 xc='pbe',
                 kpts=[9]*3,
                 encut=350,
                 nsw=0,
                 atoms=images[i])
    calc.potential_energy
#+END_SRC

*** 223
#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
from vasp.vasprc import VASPRC
VASPRC['queue.walltime']='24:00:00'

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/neb')
images, energies = calc.get_neb()

for i, atoms in enumerate(images):

    calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=223/image={0}'.format(i),
                 xc='pbe',
                 kpts=[9, 9, 5],
                 encut=350,
                 nsw=0,
                 atoms=images[i])
    calc.potential_energy
#+END_SRC

#+RESULTS:
#+begin_example
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=0 submitted: 1447048.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=0 Queued: 1447048.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=1 submitted: 1447049.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=1 Queued: 1447049.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=2 submitted: 1447050.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=2 Queued: 1447050.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=3 submitted: 1447051.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=3 Queued: 1447051.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=4 submitted: 1447052.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=4 Queued: 1447052.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=5 submitted: 1447053.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=5 Queued: 1447053.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=6 submitted: 1447054.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=6 Queued: 1447054.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=7 submitted: 1447055.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=7 Queued: 1447055.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=8 submitted: 1447056.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=223/image=8 Queued: 1447056.gilgamesh.cheme.cmu.edu
#+end_example

*** 233
#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
from vasp.vasprc import VASPRC
VASPRC['queue.walltime']='24:00:00'

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb')
images, energies = calc.get_neb()

for i, atoms in enumerate(images):

    calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/image={0}'.format(i),
                 xc='pbe',
                 kpts=[9, 5, 5],
                 encut=350,
                 nsw=0,
                 atoms=images[i])
    calc.potential_energy
#+END_SRC

*** 333
#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
from vasp.vasprc import VASPRC
VASPRC['queue.mem']='4GB'

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/neb')
images, energies = calc.get_neb()

for i, atoms in enumerate(images):

    calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=333/image={0}'.format(i),
                 xc='pbe',
                 kpts=[9]*3,
                 encut=350,
                 nsw=0,
                 atoms=images[i])
    calc.potential_energy
#+END_SRC

#+RESULTS:
#+begin_example
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=0 submitted: 1447095.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=0 Queued: 1447095.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=1 submitted: 1447096.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=1 Queued: 1447096.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=2 submitted: 1447097.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=2 Queued: 1447097.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=3 submitted: 1447098.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=3 Queued: 1447098.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=4 submitted: 1447099.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=4 Queued: 1447099.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=5 submitted: 1447100.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=5 Queued: 1447100.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=6 submitted: 1447101.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=6 Queued: 1447101.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=7 submitted: 1447102.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=7 Queued: 1447102.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=8 submitted: 1447103.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=neb/supercell=333/image=8 Queued: 1447103.gilgamesh.cheme.cmu.edu
#+end_example

** Vacancy
2*2*2 = [9, 9, 9]
3*3*3 = [5, 5, 5] 2GB
4*4*4 = [3, 3, 3] 4GB
*** Primitive
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase import Atoms, Atom
from ase.lattice.cubic import FaceCenteredCubic
from ase.visualize import view
import numpy as np

VASPRC['queue.men'] = '4GB'

#factor = [0.9, 0.95, 1.0, 1.05]
factor = [1.000]
energies = []
for x in factor:

    fcc = FaceCenteredCubic('Pd',
                            directions=[[0, 1, 1],
                                        [1, 0, 1],
                                        [1, 1, 0]],
                            latticeconstant = 3.939)

    delta = np.array([[x, 0., 0.],
                      [0., x, 0.],
                      [0., 0., x]])
    fcc.set_cell(np.dot(fcc.get_cell(), delta),
                       scale_atoms = True)

    atoms = fcc.repeat([3, 4, 4])

    cnt = len(atoms)
    del atoms[0]
    atoms.rattle()
    
    wd = './NDFT/bulk=fcc/type=vacancy/vrelax=True/supercell=344/factor={0:1.3f}'.format(x)
    calc = Vasp(wd,
                xc='pbe',
                encut=350,
                kpts = [5, 3, 3],
                ibrion = 2,
                isif = 3,
                nsw = 25,
                atoms = atoms)

    energies.append(calc.potential_energy) 

print energies


#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=vacancy/vrelax=True/supercell=344/factor=1.000 submitted: 1449347.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=vacancy/vrelax=True/supercell=344/factor=1.000 Queued: 1449347.gilgamesh.cheme.cmu.edu
: [None]

#+BEGIN_SRC python
from vasp import Vasp

factor = [0.9, 0.95, 1.0, 1.05]
nrg, calcs = [], []
for f in factor:
    calc = Vasp('./NDFT/bulk=fcc/type=vacancy/lattice=primitive/supercell=222/factor={0:1.3f}'.format(f))
    calcs  += [calc]
    nrg +=[calc.potential_energy]

Vasp.stop_if(None in nrg)


[calc.write_db('database/master.db', parser='=', overwrite=False) for calc in calcs]
#+END_SRC

* DB
#+BEGIN_SRC python
from vasp import Vasp
for i in range(200):        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md0/v_a=0_20/MD={}'.format(i))
    calc.write_db('./database/db3/data.db', parser='=', overwrite=False, keys={'dbkey':3}) 
#+END_SRC

#+RESULTS:

** keywords
#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

from ase.db import connect

db = connect('./database/db3/data.db')
data = db.select([])

keys, cnt = {}, 0
for entry in data:
    cnt += 1
    for k, v in entry.key_value_pairs.iteritems():
        
        if k in keys:
            keys[k] += [v]
        else:
            keys[k] = [v]

print ('{0:15s} {1:15s} {2} calculations total'.format('keyword', 'value',cnt))

print('------------------------------------------------------')

for k, v in keys.iteritems():
    vals = list(set(v))
    if len(vals) <= 5:
        val = ", ".join(str(e) for e in vals)
        print('{0:15}: {1}'.format(k, val))

    else:
        val = ", ".join(str(e)[:5] for e in vals[:5])
        print('{0:15s}:{1}, etc...'.format(k, val))
#+END_SRC
#+RESULTS:
#+begin_example
keyword         value           1739 calculations total
------------------------------------------------------
dirs           : 11, 44
MD             :0, 1, 2, 3, 4, etc...
train_set      : False, True
image          :0, 1, 2, 3, 4, etc...
dbkey          : 0, 1, 2, 3
bulk           : sc, hcp, fcc, diam, bcc
lattice        : primitive
supercell      :233, 333, 334, 344, 444, etc...
v_a            :1_26, 1_47, 1_63, 0_20, 1_11, etc...
vrelax         : False
factor         :1.25, 1.0, 2.0, 1.5, 0.036, etc...
type           : vacancy, md, neb, eos, elastic
order          : md2, md0, md1
surface        : fcc111
#+end_example

* Training
** Training Set
#+BEGIN_SRC python
from ase.db import connect
import os
import random
import numpy as np

db = connect('./database/db3/data.db')

n = db.count()
n_train = int(round(n * 0.9))

n_ids =  np.array(range(n)) + 1

# This will sudo-randomly select 10% of the calculations
# Which is useful for reproducing our results.
random.seed(256)
train_samples = random.sample(n_ids, n_train)
valid_samples = set(n_ids) - set(train_samples)

db.update(list(train_samples), train_set=True)
db.update(list(valid_samples), train_set=False)

with connect('./database/db3/train.db') as db0:
    for d in db.select(['train_set=True']):
        db0.write(d, key_value_pairs=d.key_value_pairs)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.db import connect
import os
import random
import numpy as np

db = connect('./database/db3/data.db')
for d in db.select('train_set=True'):
    atoms = d.toatoms()
    del atoms.constraints

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *
import os
from ase.db import connect
images= []
db = connect('database/db3/train.db')
for d in db.select(''):
    atoms = d.toatoms()
    del atoms.constraints
    images += [atoms]

for n in [10]:
    label = '2-{0}-0'.format(n)
    wd = os.path.join(os.getcwd(), 'database/db3/' + label)

    if not os.path.exists(wd):
        os.makedirs(wd)

    calc = Amp(label="./database/db2/{0}/".format(label),
               descriptor=Behler(cutoff=6.0),
               regression=NeuralNetwork(hiddenlayers=(2, '{0}'.format(n))))


    calc.train(images=images, # The training data
               data_format='db',
               cores=1,
               extend_variables=False) # feature does not work properly and will crash
#+END_SRC

** Training
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

# We will try an iteration for n nodes with l hidden layers.
for l in [2]:
    
    for n in [30]:

        label = '{0}-{1}-0'.format(l,n)
        layer=(l,n)
        wd = os.path.join(home, './database/db3/' + label)

        if not os.path.exists(wd):
            os.makedirs(wd)

        os.chdir(wd)

        run_amp = '''#!/usr/bin/env python
from amp import Amp
from amp.descriptor import *
from amp.regression import *
from ase.db import connect
images = []
db = connect("../train.db")

for d in db.select(''):
    atoms = d.toatoms()
    del atoms.constraints
    images += [atoms]

calc = Amp(load ="-parameters-checkpoint-1.json",
           label="./",
           descriptor=Behler(cutoff=6.5),
           regression=NeuralNetwork(hiddenlayers={0}))

calc.train(images=images,
           data_format="db",
           cores=4,
           extend_variables=False) 
'''.format(layer)

        cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=168:00:00
#PBS -l mem=16GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

        with open('submit.py', 'w') as f:
            f.write(run_amp)
        os.chmod('submit.py', 0777)

        with open('submit.sh', 'w') as f:
            f.write(cmd)

        subprocess.call(['qsub', 'submit.sh'])
        time.sleep(5)
        os.unlink('submit.sh')
        os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1452745.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
from amp import Amp
from ase.io import read
from amp import SimulatedAnnealing
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
import os, shutil

if os.path.exists('networks/db3/10-10/'):
    shutil.rmtree('networks/db3/10-10/')
    os.mkdir('networks/db3/10-10/')
else:
    os.mkdir('networks/db3/10-10/')

calc = Amp(
           label='networks/db/10-10/',
	   dblabel='networks/',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, 8)))

calc.train(images=read('database/AuPd.db', ':'),
	   data_format='db',
	   cores=4,
	   energy_goal=1e-3,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
#+END_SRC

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

for n in [18, 24]:

    wd = 'networks/db3/{0}-{0}/'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)
    os.chdir(wd)

    run_amp = """#!/usr/bin/env python
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing

db = connect('../../../database/db3/data.db')

images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=4,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
""".format(n)

    cmd = '''#!/bin/bash
#PBS -N {}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=24:00:00
#PBS -l mem=8GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

    with open('submit.py', 'w') as f:
        f.write(run_amp)
    os.chmod('submit.py', 0777)

    with open('submit.sh', 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', 'submit.sh'])
    time.sleep(2)
    os.unlink('submit.sh')
    os.chdir(home)
#+END_SRC

#+RESULTS:
: 1453339.gilgamesh.cheme.cmu.edu
: 1453340.gilgamesh.cheme.cmu.edu

load
load=os.path.join(wd, 'checkoutpoint-parameters-0.json'),
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

for n in [10, 15, 18, 20, 24, 25, 30]:

    wd = 'networks/db3/{0}-{0}/'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)
    os.chdir(wd)

    run_amp = """#!/usr/bin/env python
import os
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing

db = connect('../../../database/db3/data.db')
wd = os.getcwd()
images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(load='parameters.json',
           label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=4,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
""".format(n)

    cmd = '''#!/bin/bash
#PBS -N {}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=24:00:00
#PBS -l mem=8GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

    with open('submit.py', 'w') as f:
        f.write(run_amp)
    os.chmod('submit.py', 0777)

    with open('submit.sh', 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', 'submit.sh'])
    time.sleep(2)
    os.unlink('submit.sh')
    os.chdir(home)
#+END_SRC

#+RESULTS:
: 1453747.gilgamesh.cheme.cmu.edu
: 1453748.gilgamesh.cheme.cmu.edu
: 1453749.gilgamesh.cheme.cmu.edu
: 1453750.gilgamesh.cheme.cmu.edu
: 1453751.gilgamesh.cheme.cmu.edu
: 1453752.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing
import os

home = os.getcwd()
wd = 'networks/db3/10-10/'
os.chdir(wd)

db = connect('../../../database/db3/data.db')
wd = os.getcwd()
images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(load='parameters.json',
           label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=4,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
#+END_SRC

#+RESULTS:

** Update

#+BEGIN_SRC python
from ase.db import connect
from amp import Amp

db = connect('./database/db3/data.db')
calc1 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db3/25-25/checkpoint-parameters.json')

for d in db.select():
    atoms = db.get_atoms(d.id)
    atoms.set_calculator(calc1)
    nrg1 = atoms.get_potential_energy()

    atoms.set_calculator(calc2)
    nrg2 = atoms.get_potential_energy()
    db.update(d.id, NN24 = nrg1, NN25 = nrg2)
#+END_SRC

#+RESULTS:

** Residual
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from ase.db import connect
from amp import Amp
import os

db = connect('database/db3/data.db')

fig, ax = plt.subplots(1, 2, sharey=True, figsize=(8, 4))

for i, n in enumerate([24, 25]):

    E, nnE, var, ind = [], [], [], []
    for j, d in enumerate(db.select('')):# dbkey=0
	E += [d.energy / d.natoms]
	nnE += [d['NN{}'.format(n)]/ d.natoms]
	var += [j]
	ind += [d.train_set]

    res = np.array(nnE) - np.array(E)
    mask = np.array(ind)
    valid = np.ma.masked_array(res, mask)
    train = np.ma.masked_array(res, ~mask)
    vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
    tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))

    ax[i].text(200, -0.050,
               'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
               color='b', ha='left')
    ax[i].text(200, -0.057,
               'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
               color='r', ha='left')

    ax[i].scatter(var, train, color='b')
    ax[i].scatter(var, valid, color='r')
    ax[i].plot([min(var), max(var)], [0, 0], 'k--')
    ax[i].set_xlim(min(var), max(var))

    ax[i].set_xlabel('Calculation ID')
    ax[i].set_title('8-{0}-{0}-1 framework'.format(n))

ax[0].set_ylim(-0.060, 0.060)
ax[0].set_ylabel('Residual error (eV/atom)')
plt.tight_layout()
plt.savefig('./figures/residual-3.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/residual-3.png]]
Large error configurations
#+BEGIN_SRC python
import numpy as np
from ase.db import connect
ids = []
db = connect('database/db2/data.db')
for i, d in enumerate(db.select('')):
    E = d.energy / d.natoms
    nE = d.NN30/ d.natoms
    if abs(E - nE) > 0.04:
        ids += [i]

print ids
#+END_SRC

#+RESULTS:
: [233, 244, 245, 301, 340, 355, 409, 410]



#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db3/data.db')

S, Qe, Ne = [], [], []

for d in db.select(['bulk']):
    S += [d.bulk]
    Qe += [d.energy/d.natoms]
    Ne += [d.NN24/d.natoms]
    
S = np.array(S)
Qe = np.array(Qe)
Ne = np.array(Ne)

cmap, hdl = {}, []

for s, c in zip(set(S), ['b', 'r', 'g', 'c', 'm']):
    cmap[s] = c
    hdl +=[mpatches.Patch(color = c, label = s)]

c = []
for s in S:
    c +=[cmap[s]]

RMSE = np.sqrt(sum((Ne-Qe)** 2) / len(Ne - Qe))

(mu, sigma) = norm.fit(Ne- Qe)

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
ax0.plot([min(Qe), 0], [0,0], 'k--', lw =2)
ax0.scatter(Qe, Ne-Qe, marker = 'o', color = c)
ax0.text(min(Qe) + 0.1, 0.14,
         'RMSE: {0:1.3f}'.format(RMSE),
         fontsize = 12, va = 'top', ha = 'left')
ax0.set_xlim(min(Qe), -1)
ax0.set_ylim(-0.045, 0.045)
ax0.set_xlabel('DFT potential energy (eV/atom)')
ax0.set_ylabel('Rsidual error (eV/atom)')
ax0.legend(loc = 'best', handles =hdl, fontsize = 8, frameon = False)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(Ne-Qe, 50,
                            range = (-0.01, 0.01),
                            weights = np.ones_like(Ne-Qe)/ len(Ne),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.05, 0.142, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.05, 0.122, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.06, 0.06)
ax1.set_xlim(0, 0.3)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
plt.tight_layout(w_pad = -0.5)
#plt.savefig('./images/fig-neural-train.png')
plt.show()

#+END_SRC

#+RESULTS:

* Application
** MD
*** Trajectory
**** NEB
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

for cell in ['222', '223', '233', '333']:
    
    for img in [1, 2, 3, 4]:
        
        label = '{0}-{1}'.format(cell, img)
        
        wd = os.path.join(home, './database/db2/' + label)

        if not os.path.exists(wd):
            os.makedirs(wd)

        os.chdir(wd)


        run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from vasp import Vasp

calc = Vasp("./../../../NDFT/bulk=fcc/type=neb/supercell=222/neb")
images, energies = calc.get_neb()


atoms = images[1]

atoms.set_calculator(Amp(load="./../2-30-0/-parameters-checkpoint-1.json"))
        
dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

        cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

        with open('submit.py', 'w') as f:
            f.write(run_md)
        os.chmod('submit.py', 0777)

        with open('submit.sh', 'w') as f:
            f.write(cmd)

        subprocess.call(['qsub', 'submit.sh'])
        time.sleep(5)
        os.unlink('submit.sh')
        os.chdir(wd)
#+END_SRC

#+BEGIN_SRC python
from __future__ import print_function
from ase.lattice.cubic import FaceCenteredCubic
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from vasp import Vasp

import os
import subprocess
import time

home = os.getcwd()

for cell in ['222', '223', '233', '333']:
    
    for img in [1, 2, 3, 4]:
        
        label = '{0}-{1}'.format(cell, img)
        
        wd = os.path.join(home, './database/db2/' + label)

        if not os.path.exists(wd):
            os.makedirs(wd)

        os.chdir(wd)


        calc = Vasp("./../../../NDFT/bulk=fcc/type=neb/supercell=222/neb")
        images, energies = calc.get_neb()


        atoms = images[1]

        atoms.set_calculator(Amp(load="./../2-30-0/-parameters-checkpoint-1.json"))
        
        dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


        def printenergy(a=atoms):
            epot = a.get_potential_energy() / len(a)
            ekin = a.get_kinetic_energy() / len(a)
    
        dyn.attach(printenergy, interval=10)

        traj = Trajectory("./MD.traj", "w", atoms)
        dyn.attach(traj.write, interval=10)

        dyn.run(2000)

#+END_SRC

**** Surface
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

label = '225-surface'
wd = os.path.join(home, './database/db2/' + label)

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(2, 2, 5), a=3.939, vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(Amp(load="./../2-30-0/-parameters-checkpoint-1.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD-fixed.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1451040.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

label = '335-surface'
wd = os.path.join(home, './database/db2/' + label)

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)

run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(3, 3, 5), a=3.939, vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(Amp(load="./../2-30-0/-parameters-checkpoint-0.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD-fixed.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=48:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1451727.gilgamesh.cheme.cmu.edu


#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
calc1 = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
calc2 = Amp(load='./database/db2/2-20-0/-parameters-checkpoint-0.json')
images = Trajectory('./database/db2/225-surface/MD.traj', 'r')
Ed = []
En = [images[i].get_potential_energy() for i in range(200)]
for i in range(200):
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md0/v_a=0_20/MD={}'.format(i))
    Ed += [calc.potential_energy]

plt.plot(range(len(En)), En, 'b-', label='NN prediction')
plt.scatter(range(len(Ed)), Ed, facecolor='none',
	   edgecolor='r', label='DFT calculation')

plt.xlim([0, 200])
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('222surface-md.png')
plt.show()
#+END_SRC

[[./figures/222surface-md.png]]

*** NN Predict
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp

calc1 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db3/25-25/checkpoint-parameters.json')
traj = Trajectory('./database/db3/MD-225.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/MD225-3.png')
#+END_SRC

#+RESULTS:

[[./figures/MD225-3.png]]

#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
images, energies = calc.get_neb()

En, E = [], []
calc2 = Amp('./networks/db3/24-24/checkpoint-parameters.json')

for atoms in images:
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

En = np.array(En)
E = En-En[0]
x = range(len(images))
xarray = np.linspace(0, len(images))
f1 = interp1d(x, energies, kind='cubic', bounds_error=False)
f2 = interp1d(x, E, kind='cubic', bounds_error=False)
plt.plot(x, energies, 'bo', label = 'NEB')
plt.plot(x, E, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
#plt.show()
plt.savefig('./figures/NN-NEB-4.png')
#+END_SRC
#+RESULTS:

[[./figures/NN-NEB-4.png]]
** NEB-NN
#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=233/neb')
images, energies = calc.get_neb()

En, E = [], []
calc2 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')

for atoms in images:
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

En = np.array(En)
E = En-En[0]
x = range(len(images))
xarray = np.linspace(0, len(images))
f1 = interp1d(x, energies, kind='cubic', bounds_error=False)
f2 = interp1d(x, E, kind='cubic', bounds_error=False)
plt.plot(x, energies, 'bo', label = 'NEB')
plt.plot(x, E, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
plt.show()
#+END_SRC
#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
from amp import Amp

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
images, energies = calc.get_neb()

calc0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb-initial')
E0 = calc0.potential_energy

energies = np.array(energies)
energies += E0

print energies


En, E = [], []
calc2 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')

for atoms in images:
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

print En
#+END_SRC

#+RESULTS:
: [-35.43371164 -35.42570645 -35.19608912 -34.88827938 -34.75807484
:  -34.88827927 -35.19608898 -35.42570641 -35.43371169]
: [-35.322470231901875, -35.31849228646374, -35.156207100533905, -34.85637361556328, -34.68250391909649, -34.85637347354207, -35.15620697841968, -35.31849225982069, -35.32247023190192]

** Bulk Properties
*** Cohesive energy
Atomic energy
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase import Atoms, Atom
from ase.visualize import view
VASPRC['queue.walltime'] = '24:00:00'

atoms = Atoms([Atom('Pd', [5, 5, 5])],
              cell = (7, 8, 9))

calc = Vasp('NDFT/atomic-Pd',
          xc = 'pbe',
          encut = 350,
          kpts = [1]*3,
          atoms = atoms) 

calc.calculate()

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/atomic-Pd submitted: 1442984.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
from vasp import Vasp
from amp import Amp
calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')

calc = Vasp ('./NDFT/atomic-Pd') 
Eatom = calc.potential_energy
 
calc = Vasp ('./NDFT/bulk=fcc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEfcc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEfcc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=bcc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEbcc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEbcc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=hcp/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEhcp = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEhcp = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=sc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEsc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEsc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=diam/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEdiam = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEdiam = atoms.get_potential_energy()/len(atoms)
print DEfcc-Eatom, NEfcc-Eatom
print DEbcc-Eatom, NEbcc-Eatom
print DEhcp-Eatom, NEhcp-Eatom
print DEsc-Eatom, NEsc-Eatom
print DEdiam-Eatom, NEdiam-Eatom
#+END_SRC

#+RESULTS:
: -3.75476834 -3.75589508423
: -3.71312559 -3.73790838482
: -3.72459561 -3.76095602827
: -3.2532599 -3.26704062214
: -2.6162620675 -2.61824650251

*** Bulk Modulus
#+BEGIN_SRC python
from ase.db import connect
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState
from ase.units import kJ
import numpy as np
from vasp import Vasp
from amp import Amp

factor = np.arange(0.85, 1.2, 0.01)
calc2 = Amp(load = './database/db1/2-24-2/-parameters-checkpoint-0.json')
             #      np.arange(1.2, 2.125, 0.05))
configs = ['fcc', 'bcc', 'hcp', 'sc', 'diam']

for config in configs:
    nrg, vol = [], []
    nn = []
    for f in factor:
        calc = Vasp('./NDFT/bulk={0}/type=eos/factor={1:.2f}'.format(config,f))
        atoms = calc.get_atoms()
        nrg += [atoms.get_potential_energy()/len(atoms)]
        vol += [atoms.get_volume()/len(atoms)]
        atoms.set_calculator(calc2)
        nn +=[atoms.get_potential_energy()/len(atoms)]
        

    vol = np.array(vol)
    nrg = np.array(nrg)
    nn = np.array(nn)
# Fit the data to SJEOS
    eos = EquationOfState(vol, nrg)
    v0, e0, B0 = eos.fit()
    eos = EquationOfState(vol, nn)
    v1, e1, B1 = eos.fit()
    print '{0}'.format(config)
    print v0, e0, B0
    print v1, e1, B1
#+END_SRC

#+RESULTS:
#+begin_example
fcc
15.2979724806 -5.22438476072 1.09507457295
15.3564270183 -5.21520156705 1.07945263208
bcc
15.4257962561 -5.18249419589 1.06469804063
15.3991596967 -5.19211684448 1.08071951009
hcp
15.3645769219 -5.19379582623 1.08254355793
15.3341063992 -5.21621811798 1.09987534388
sc
17.8024966568 -4.72110919112 0.782438954048
17.8334288446 -4.71777979115 0.775358668286
diam
24.3558101786 -4.08130798908 0.428150007251
24.346708419 -4.08117208591 0.428715107213
#+end_example

*** Elastic Constant
**** 11, 12
#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.01, 11)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=11/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')
    #calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
#+END_SRC

#+RESULTS:
: [ 2.22936683 -0.34128023]
: [ 2.58330265 -0.34127457]

#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.01, 11)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=11/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')
    #calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')

    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
plt.plot(factor, Ed/Vd[0], 'bo', label = 'DFT')
plt.plot(factor, En/Vd[0], 'ro', label = 'NN')
plt.plot(factor, func(factor, *poptd), 'b-', label = 'DFT fit')
plt.plot(factor, func(factor, *poptn), 'r-', label = 'NN fit')

plt.xlabel('Strain')
plt.ylabel('Energy Density [eV/$\AA^3$]')
plt.legend(loc='best')
#plt.savefig('./figures/elastic-1.png')
plt.show()
#+END_SRC

#+RESULTS:
: [ 2.22936683 -0.34128023]
: [ 2.87528197 -0.34126408]

#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.01, 11)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=11/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')
    #calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')

    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())


'''
from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
'''

plt.plot(factor, Ed, 'bo', label = 'DFT')
plt.plot(factor, En, 'ro', label = 'NN')
#plt.plot(factor, func(factor, *poptd), 'b-', label = 'DFT fit')
#plt.plot(factor, func(factor, *poptn), 'r-', label = 'NN fit')
plt.yticks([-5.25, -5.15])
plt.xlabel('Strain')
plt.ylabel('Energy Density [eV/$\AA^3$]')
plt.legend(loc='best')
#plt.savefig('./figures/elastic-1.png')
plt.show()

print En
print Ed
#+END_SRC

#+RESULTS:
: [-5.214233007304841, -5.214186423003589, -5.2140474989201095, -5.213817706828854, -5.213498826222127, -5.213092949310042, -5.212602495229863, -5.212030229207617, -5.211379279349323, -5.210653146172575, -5.20985571664281]
: [-5.21446998, -5.21443415, -5.2143216, -5.21414158, -5.21388803, -5.21360063, -5.21324321, -5.21279459, -5.21225954, -5.21170139, -5.2110564]

**** 44
#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.01, 11)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=44/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

  #  calc2 = Amp(load='./networks/db3/2-25/checkpoint-parameters.json')
    calc2 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')
    #calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
#+END_SRC

#+RESULTS:
: [ 0.73280411 -0.34127966]
: [ 0.71863853 -0.34126554]

**** calculation
#+BEGIN_SRC python
'''
B = 1.09507457295
a = 2.21553499/6
b = 0.66616554
'''

B = 1.0950
a = 3.0178/6
b = 0.8153
C4 = b/2
C2 = (3*B - 2*a)/3
C1 = 2*a + C2

print C1, C2, C4
print C1 * 160.2177
print C2 * 160.2177
print C4 * 160.2177
#+END_SRC

#+RESULTS:
: 1.76562222222 0.759688888889 0.40765
: 282.883931513
: 121.715606493
: 65.312745405

**** reference 
#+BEGIN_SRC python
from vasp import Vasp
calc = Vasp('~/Research/Bulk/DFT/bulk=fcc/type=elastic/elastic')

EM = calc.get_elastic_moduli()

print EM
#+END_SRC

#+RESULTS:
: [[ 206.71093  155.54113  155.54113    0.         0.         0.     ]
:  [ 155.54113  206.71093  155.54113    0.         0.         0.     ]
:  [ 155.54113  155.54113  206.71093    0.         0.         0.     ]
:  [   0.         0.         0.        59.78395    0.         0.     ]
:  [   0.         0.         0.         0.        59.78395    0.     ]
:  [   0.         0.         0.         0.         0.        59.78395]]

** Vacancy formation
*** 222
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=222/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*7
print Ev
#+END_SRC

#+RESULTS:
: 1.06765175


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 2, 2)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (7/8.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  10:04:17      -35.323077       0.0000
: Vacancy formation energy with NN is: 1.158 eV
: -41.6921809084
: -35.3230768877

*** 223
     
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=223/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*11
print Ev
#+END_SRC

#+RESULTS:
: 1.13510973


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 2, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (11/12.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  10:08:55      -56.116879       0.7401
: BFGS:   1  10:09:01      -56.136758       0.6208
: BFGS:   2  10:09:07      -56.172858       0.1487
: BFGS:   3  10:09:13      -56.173163       0.1054
: BFGS:   4  10:09:19      -56.173243       0.0910
: BFGS:   5  10:09:24      -56.173405       0.0330
: Vacancy formation energy with NN is: 1.153 eV
: -62.5382713626
: -56.1734049327

*** 233
     
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=233/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*17
print Ev
#+END_SRC

#+RESULTS:
: 1.15516594


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (2, 3, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (17/18.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  10:11:55      -87.352273       0.6760
: BFGS:   1  10:12:09      -87.382656       0.5809
: BFGS:   2  10:12:22      -87.449470       0.1658
: BFGS:   3  10:12:36      -87.449810       0.0709
: BFGS:   4  10:12:49      -87.449782       0.0621
: BFGS:   5  10:13:03      -87.448243       0.0260
: Vacancy formation energy with NN is: 1.148 eV
: -93.8074070438
: -87.4482427447

*** 333
     
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=333/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*26
print E1
print E0*27
print Ev
#+END_SRC

#+RESULTS:
: -134.47545389
: -140.79068946
: 1.10076559


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (3, 3, 3)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (26/27.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  10:15:55     -134.259635       0.5909
: BFGS:   1  10:16:25     -134.295713       0.5128
: BFGS:   2  10:16:59     -134.376645       0.1256
: BFGS:   3  10:17:33     -134.373331       0.0840
: BFGS:   4  10:18:09     -134.373707       0.0736
: BFGS:   5  10:18:45     -134.374974       0.0360
: Vacancy formation energy with NN is: 1.125 eV
: -140.711110566
: -134.374974352

*** 334
     
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=334/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*35

print Ev
#+END_SRC

#+RESULTS:
: 1.07033284


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (3, 3, 4)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (35/36.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  10:40:34     -181.168995       0.4837
BFGS:   1  10:41:20     -181.198978       0.4371
BFGS:   2  10:42:06     -181.292172       0.1463
BFGS:   3  10:42:52     -181.297291       0.0998
BFGS:   4  10:43:38     -181.300006       0.0885
BFGS:   5  10:44:23     -181.306581       0.0545
BFGS:   6  10:45:09     -181.307656       0.0681
BFGS:   7  10:45:55     -181.306891       0.0800
BFGS:   8  10:46:41     -181.304284       0.0811
BFGS:   9  10:47:27     -181.299184       0.0682
BFGS:  10  10:48:13     -181.294990       0.0504
BFGS:  11  10:48:59     -181.293067       0.0459
Vacancy formation energy with NN is: 1.110 eV
-187.614814088
-181.29306683
#+end_example

*** 344
     
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=344/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*47
print Ev

#+END_SRC

#+RESULTS:
: 1.0137827


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (3, 4, 4)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (47/48.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  11:51:49     -243.709851       0.3831
BFGS:   1  11:53:00     -243.735689       0.3473
BFGS:   2  11:54:11     -243.847779       0.1092
BFGS:   3  11:55:22     -243.855635       0.1107
BFGS:   4  11:56:33     -243.868125       0.0804
BFGS:   5  11:57:45     -243.871778       0.0628
BFGS:   6  11:58:56     -243.871070       0.0440
Vacancy formation energy with NN is: 1.070 eV
-250.152955507
-243.871069593
#+end_example

*** 444
     
#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=444/factor=1.000')
E1 = calc.potential_energy
calc1 = Vasp('./NDFT/bulk=fcc/type=eos/factor=1.00')
E0 = calc1.potential_energy
Ev = E1 - E0*63
print Ev
#+END_SRC

#+RESULTS:
: 0.96277588


#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
calc = Amp(load='./database/db2/2-30-sur2/-parameters-checkpoint-0.json')
atoms = FaceCenteredCubic('Pd',
                          directions=[[0, 1, 1],
                                      [1, 0, 1],
                                      [1, 1, 0]],
                          latticeconstant=3.939)
atoms.set_calculator(calc)
atoms *= (4, 4, 4)

nrg0 = atoms.get_potential_energy()
del atoms[0]
dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg1 = atoms.get_potential_energy()
#fw = calc.split('/')[-2]
ve = nrg1 - (63/64.)*nrg0

print 'Vacancy formation energy with NN is: {0:1.3f} eV'.format(ve)
print nrg0
print nrg1
#+END_SRC

#+RESULTS:
: BFGS:   0  10:22:58     -327.095298       0.2871
: BFGS:   1  10:24:48     -327.119921       0.2601
: BFGS:   2  10:26:53     -327.231549       0.1002
: BFGS:   3  10:28:55     -327.238182       0.0787
: BFGS:   4  10:31:00     -327.259021       0.0256
: Vacancy formation energy with NN is: 1.067 eV
: -333.537447267
: -327.259021011

| Supercell | E_DFT(eV) | E_NN(eV) | Error(eV) | Error(%) |
|       222 |     1.068 |    1.158 |     0.090 |     8.42 |
|       223 |     1.135 |    1.153 |     0.018 |     1.59 |
|       233 |     1.155 |    1.148 |     0.007 |     0.61 |
|       333 |     1.101 |    1.125 |     0.024 |     2.17 |
|       334 |     1.070 |    1.110 |     0.040 |     3.73 |
|       344 |     1.014 |    1.070 |     0.056 |     5.52 |
|       444 |     0.963 |    1.067 |     0.104 |    10.80 |

** EOS
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState
from ase.db import connect
from amp import Amp
from ase.visualize import view
import os
import json
import time
from ase.units import kJ

db = connect('./database/db2/data.db')

f, ax = plt.subplots(1, 5, figsize = (12, 5))
tag = ['FCC', 'BCC', 'HCP', 'SC', 'Diamond']

for i, key in enumerate(['fcc', 'bcc', 'hcp', 'sc', 'diam']):

    V, Qe, Re, Ne = [], [], [], []

    for d in db.select(['bulk={0}'.format(key), 'type=eos']):
        V += [d.volume / d.natoms]
        Qe += [d.energy / d.natoms]
        Ne += [d.NN30 / d.natoms]

    srt = [j[0] for j in sorted(enumerate(V), key = lambda x:x[1])]
    V = np.array(V)[srt]
    Qe = np.array(Qe)[srt]
    Ne = np.array(Ne)[srt]

    ax[i].plot(V, Qe, 'k-', lw=2, label = 'DFT')
    ax[i].plot(V, Ne, 'r--', lw=2, label = 'Neural')

    if i >0:
        ax[i].set_yticklabels([])

    ax[i].set_ylim(-6 , 0)
    ax[i].set_xlim(0, 150)
    ax[i].set_xticks([0, 40, 80, 120])
    ax[i].set_title('{0}'.format(tag[i]))

ax[0].set_ylabel('Potantial energy (eV/atom)')
ax[2].set_xlabel('Volume ($\AA$/atom)')
ax[4].legend(loc = 'best', fontsize = 12)
plt.tight_layout(w_pad=-1.3)
plt.savefig('./figures/eos-NN-2.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/eos-NN-2.png]]

#+BEGIN_SRC python
from amp import Amp
import numpy as np
from ase.lattice.cubic import FaceCenteredCubic
import matplotlib.pyplot as plt


E1, E2 = [], []

factor = np.linspace(0.85, 2.5, 1000)
for x in factor :

    atoms = FaceCenteredCubic('Pd',
                              directions=[[0, 1, 1],
                                          [1, 0, 1],
                                          [1, 1, 0]],
                              latticeconstant=3.933)
    
    delta = np.array([[x, 0., 0.],
                      [0., x, 0.],
                      [0., 0., x]])
    atoms.set_cell(np.dot(atoms.get_cell(), delta),
                   scale_atoms=True)
    calc1 = Amp(load='./database/db1/2-24-2/-parameters-checkpoint-0.json')
    calc2 = Amp(load='./database/db1/2-30-2/-parameters-checkpoint-0.json')
    
    atoms.set_calculator(calc1)
    E1 += [atoms.get_potential_energy()]

    atoms.set_calculator(calc2)
    E2 += [atoms.get_potential_energy()]

E1 = np.array(E1)
E2 = np.array(E2)
res = abs(E1 - E2)
#print E1


f, ax = plt.subplots(2, 1, sharex=True)
ax[0].plot(factor, E1, 'b', lw=2, label='2-24')
ax[0].plot(factor, E2, 'r', lw=2, label='2-30')
ax[0].plot([0.85, 0.85], [2, -6], 'k--')
ax[0].plot([2.1, 2.1], [2, -6], 'k--')
ax[0].set_ylabel('Potential energy (eV)')
ax[0].set_xlim(0.6, 2.5)
ax[0].set_ylim(-6, 2)
ax[0].legend(loc='best')
ax[1].plot(factor, res)
ax[1].plot([0.85, 0.85], [0, 0.5], 'k--')
ax[1].plot([2.07, 2.1], [0, 0.5], 'k--')
ax[1].set_ylabel('NN energy difference (eV)')
ax[1].set_ylim(0, 0.5)
ax[1].set_xlabel('Strain/stretch factor (%)')
plt.tight_layout(w_pad=0.0)
plt.savefig('./figures/app-eos.png')
#+END_SRC

#+RESULTS:

[[./figures/app-eos.png]]


* 5th DFT
** Surface MD
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
from vasp import Vasp
from vasp.vasprc import VASPRC

VASPRC['queue.walltime'] = '24:00:00'

calc1 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db3/25-25/checkpoint-parameters.json')
images = Trajectory('./database/db3/MD-225.traj', 'r')
E1, E2 = [], []

for atoms in images:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in images:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)

#+END_SRC

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
from vasp import Vasp
from vasp.vasprc import VASPRC

VASPRC['queue.walltime'] = '24:00:00'

calc1 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db3/25-25/checkpoint-parameters.json')
images = Trajectory('./database/db3/MD-225.traj', 'r')
E1, E2 = [], []

for atoms in images:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in images:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)


nrg, res, s = [], [], []
calcs = []
A = [0, 2, 4, 5, 6, 7, 10, 11, 12, 13, 16, 17, 18, 19, 21, 24, 25, 26, 27, 28, 29, 30, 32, 33, 37, 38, 40, 41, 43, 44, 45, 46, 50, 52, 54, 55, 60, 61, 63, 64, 65, 66, 73, 74, 75, 76, 82, 87, 92, 93, 102, 103, 104, 107, 108, 113, 114, 119, 121, 123, 124, 128, 129, 133, 138, 139, 142, 145, 146, 147, 148, 149, 150, 154, 155, 158, 159, 160, 167, 170, 179, 180, 184, 189, 191, 193, 194, 195, 197, 198]

for i in A:        
        
        calc = Vasp('NDFT/surface=fcc111/type=md/order=md1/v_a=0_20/MD={}'.format(i))

        nrg += [calc.potential_energy/20]


plt.plot(range(len(E1)), E1, 'b-', label='NN1 prediction')
plt.plot(range(len(E2)), E2, 'r--', label='NN2 prediction')
plt.scatter(A, nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(E1)))
plt.ylabel('Potential energy (eV)')

plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/225MD-3.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/225MD-3.png]]
#+RESULTS:

: [0, 2, 4, 5, 6, 7, 10, 11, 12, 13, 15, 16, 17, 18, 19, 21, 24, 25, 26, 27, 28, 29, 30, 32, 33, 37, 38, 40, 41, 43, 44, 45, 46, 50, 52, 54, 55, 60, 61, 63, 64, 65, 66, 73, 74, 75, 76, 82, 87, 92, 93, 102, 103, 104, 107, 108, 113, 114, 119, 121, 123, 124, 128, 129, 133, 136, 138, 139, 140, 142, 145, 146, 147, 148, 149, 150, 154, 155, 158, 159, 160, 167, 170, 179, 180, 184, 189, 191, 193, 194, 195, 197, 198]


 136 140
#+BEGIN_SRC python
from vasp import Vasp
t = [0, 2, 4, 5, 6, 7, 10, 11, 12, 13, 16, 17, 18, 19, 21, 24, 25, 26, 27, 28, 29, 30, 32, 33, 37, 38, 40, 41, 43, 44, 45, 46, 50, 52, 54, 55, 60, 61, 63, 64, 65, 66, 73, 74, 75, 76, 82, 87, 92, 93, 102, 103, 104, 107, 108, 113, 114, 119, 121, 123, 124, 128, 129 133,  138, 139, 142, 145, 146, 147, 148, 149, 150, 154, 155, 158, 159, 160, 167, 170, 179, 180, 184, 189, 191, 193, 194, 195, 197, 198]

nrg = []
for i in t:        
        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md1/v_a=0_20/MD={}'.format(i))
    nrg +=[calc.potential_energy]
    print t
#+END_SRC

#+BEGIN_SRC python
from vasp import Vasp
import os
t = [136]

nrg = []
for i in t:        
        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md1/v_a=0_20/MD={}'.format(i))

    cwd = os.getcwd()
    print 
tianyug1/Research/Bulk/NDFT/surface=fcc111/type=md/order=md1/v_a=0_20/MD=136
#+END_SRC

#+RESULTS:

#+END_SRC
** Surface vacancy
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc111
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

a0 = 3.939
nrg = []

atoms = fcc111('Pd', size=(4, 4, 5), a = a0,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
del atoms[-1]


calc = Vasp('NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=44',
            xc='pbe',
            kpts=[3, 3, 1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=atoms)

calc.set_memory()
nrg += [calc.potential_energy]
#+END_SRC

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc111
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np
from vasp.vasprc import VASPRC

VASPRC['queue.walltime']='24:00:00'
VASPRC['queue.ppn'] = 4
a0 = 3.939
nrg = []

atoms = fcc111('Pd', size=(3, 3, 5), a = a0,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
del atoms[-1]


calc = Vasp('NDFT/surface=fcc111/type=test/vrelax=False/supercell=33',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=atoms)

calc.set_memory()
nrg += [calc.potential_energy]
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=test/vrelax=False/supercell=33 submitted: 1453764.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=test/vrelax=False/supercell=33 Queued: 1453764.gilgamesh.cheme.cmu.edu
*** Surface vacancy diffusion neb
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111
from ase.constraints import FixAtoms

#VASPRC['queue.mem'] = '8GB'
VASPRC['queue.walltime'] = '24:00:00'

a0 = 3.939
atoms = fcc111('Pd', size=(2, 2, 5), a = a0,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)

ini = atoms.copy()
del ini[-1]
# Get unrelaxed initial and final states for speed.

c0 = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/neb-initial',
          xc='pbe',
          kpts=[9, 9, 1],
          encut=350,
          ibrion=2,
          isif=2,
          nsw=25,
          atoms=ini)

fin = atoms.copy()
del fin[-2]

cend = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/neb-end',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=fin)

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

ini = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/neb-initial').get_atoms()
fin = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/neb-end').get_atoms()
images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/neb',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/surf-vac-NEB.png')
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.502667
:          Iterations: 15
:          Function evaluations: 30

[[./figures/surf-vac-NEB.png]]

#+BEGIN_SRC python
from vasp import Vasp

calc = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/neb')

images, energies = calc.get_neb()

for i in range(len(images)):
    calc = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/image={}'.format(i),
                xc = 'pbe',
                kpts = [9, 9, 1],
                encut = 350,
                nsw  = 0,
                atoms = images[i])
    calc.calculate()

#+END_SRC

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111
from ase.constraints import FixAtoms

VASPRC['queue.mem'] = '8GB'
#VASPRC['queue.walltime'] = '24:00:00'
#VASPRC['queue.ppn'] = 4
a0 = 3.939
atoms = fcc111('Pd', size=(3, 3, 5), a = a0,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)

ini = atoms.copy()
del ini[-1]
# Get unrelaxed initial and final states for speed.

c0 = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/supercell=33/neb-initial',
          xc='pbe',
          kpts=[5, 5, 1],
          encut=350,
          ibrion=2,
          isif=2,
          nsw=25,
          atoms=ini)

fin = atoms.copy()
del fin[-2]

cend = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/supercell=33/neb-end',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=fin)

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

ini = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/supercell=33/neb-initial').get_atoms()
fin = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/supercell=33/neb-end').get_atoms()
images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/supercell=33/neb',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/surf-vac-NEB.png')
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=neb/class=vacancy/supercell=33/neb submitted: 1522722.gilgamesh.cheme.cmu.edu

** Surface adatom
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

calc = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00')
atoms = calc.get_atoms()

add_adsorbate(atoms, 'Pd', height=2.0, position='fcc')
constraint = FixAtoms(mask=[atom.tag >0  for atom in atoms])
atoms.set_constraint(constraint)

calc = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site=fcc',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=atoms)

calc.set_memory()
nrg += [calc.potential_energy]

#+END_SRC


#+RESULTS:

#+BEGIN_SRC python
from ase.lattice.surface import fcc111, add_adsorbate
from ase.visualize import view
from ase.constraints  import FixAtoms

atoms = fcc111('Pd', size=(2, 2, 3), vacuum=10.0)
add_adsorbate(atoms, 'Pd', height=2.0, position='fcc')
constraint = FixAtoms(mask=[atom.tag >0  for atom in atoms])
atoms.set_constraint(constraint)
view(atoms)
#+END_SRC

#+RESULTS:

*** fcc
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

VASPRC['queue.walltime']='24:00:00'
VASPRC['queue.ppn']=2
atoms = fcc111('Pd', size=(2, 2, 5), a = 3.939, vacuum = 6.0)
add_adsorbate(atoms, 'Pd', height=2.0, position='fcc')
constraint = FixAtoms(mask=[atom.tag >3  for atom in atoms])
atoms.set_constraint(constraint)

calc = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site=fcc',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=atoms)

calc.set_memory()
nrg = calc.potential_energy

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=adatom/supercell=22/site=fcc submitted: 1459439.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=adatom/supercell=22/site=fcc Queued: 1459439.gilgamesh.cheme.cmu.edu

*** hcp
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

VASPRC['queue.walltime']='24:00:00'
VASPRC['queue.ppn'] = 2

atoms = fcc111('Pd', size=(2, 2, 5), a = 3.939,  vacuum = 6.0)
add_adsorbate(atoms, 'Pd', height=2.0, position='hcp')
constraint = FixAtoms(mask=[atom.tag >3  for atom in atoms])
atoms.set_constraint(constraint)

calc = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site=hcp',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=atoms)

calc.set_memory()
nrg = calc.potential_energy

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=adatom/supercell=22/site=hcp submitted: 1459440.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=adatom/supercell=22/site=hcp Queued: 1459440.gilgamesh.cheme.cmu.edu

*** bridge
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms, FixScaled
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

VASPRC['queue.walltime']='24:00:00'
VASPRC['queue.ppn'] = 2

atoms = fcc111('Pd', size=(2, 2, 5), a= 3.939, vacuum = 6.0)
add_adsorbate(atoms, 'Pd', height=2.0, position='bridge')
constraint1 = FixAtoms(mask=[atom.tag >3  for atom in atoms])


constraint2 = FixScaled(atoms.get_cell(), 20, [True, True, False])
atoms.set_constraint([constraint1, constraint2])


calc = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site=bridge',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=atoms)

calc.set_memory()
nrg = calc.potential_energy

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=adatom/supercell=22/site=bridge submitted: 1459437.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=adatom/supercell=22/site=bridge Queued: 1459437.gilgamesh.cheme.cmu.edu

*** top
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms, FixScaled
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

VASPRC['queue.walltime']='24:00:00'
VASPRC['queue.ppn'] = 2

atoms = fcc111('Pd', size=(2, 2, 5), a=3.939, vacuum = 6.0)
add_adsorbate(atoms, 'Pd', height=2.0, position='ontop')
constraint1 = FixAtoms(mask=[atom.tag >3  for atom in atoms])


constraint2 = FixScaled(atoms.get_cell(), 20, [True, True, False])
atoms.set_constraint([constraint1, constraint2])


calc = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site=top',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=atoms)

calc.set_memory()
nrg = calc.potential_energy

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=adatom/supercell=22/site=top submitted: 1459438.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=adatom/supercell=22/site=top Queued: 1459438.gilgamesh.cheme.cmu.edu

*** surface adatom diffusion neb
**** top-fcc
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111
from ase.constraints import FixAtoms

VASPRC['queue.mem'] = '8GB'

ini = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site=top').get_atoms()
fin = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site=fcc').get_atoms()
images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc111/type=neb/class=top_fcc/neb',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/top-fcc.png')
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: 0.004509
:          Iterations: 13
:          Function evaluations: 26

[[./figures/top-fcc.png]]
**** fcc-hcp
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111
from ase.constraints import FixAtoms

VASPRC['queue.mem'] = '8GB'

ini = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site=fcc').get_atoms()
fin = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site=hcp').get_atoms()
images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc111/type=neb/class=fcc_hcp/neb',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/fcc-hcp.png')
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.102846
:          Iterations: 14
:          Function evaluations: 28

[[./figures/fcc-hcp.png]]
**** hcp-top
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111
from ase.constraints import FixAtoms

VASPRC['queue.mem'] = '8GB'

ini = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site=hcp').get_atoms()
fin = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site=top').get_atoms()
images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc111/type=neb/class=hcp_top/neb',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/hcp-top.png')
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.659015
:          Iterations: 19
:          Function evaluations: 38

[[./figures/hcp-top.png]]

**** hcp-top-2
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111
from ase.constraints import FixAtoms

#VASPRC['queue.mem'] = '8GB'
VASPRC['queue.walltime'] = '24:00:00'
VASPRC['ppn'] = 4
ini = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site=hcp').get_atoms()

atoms = fcc111('Pd', size=(2, 2, 5), vacuum = 6.0)
add_adsorbate(atoms, 'Pd', height=2.0, position='ontop')
constraint1 = FixAtoms(mask=[atom.tag >3  for atom in atoms])


constraint2 = FixScaled(atoms.get_cell(), 20, [True, True, False])
atoms.set_constraint([constraint1, constraint2])


calc = Vasp('NDFT/surface=fcc111/type=neb/class=hcp_top/neb-end',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=atoms)

calc.set_memory()
nrg = calc.potential_energy
'''
fin = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site=top').get_atoms()
images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc111/type=neb/class=hcp_top/neb',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/hcp-top.png')
'''
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.659015
:          Iterations: 19
:          Function evaluations: 38

[[./figures/hcp-top.png]]

*** fixed all neb
**** position
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms
from ase import Atoms, Atom

#VASPRC['queue.mem'] = '8GB'
VASPRC['queue.walltime'] = '24:00:00'

calc = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00')
slab = calc.get_atoms()

#slab = fcc111('Pd', size=(2, 2, 5), a = 3.939,  vacuum=6.0)
#end = slab.copy()
p = slab.positions

pfcc = (p[16] + p[17] + p[18])/3.0 + [0, 0, 2]
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(pfcc)

fcc = slab + add
constraint = FixAtoms(mask=[atom.tag > 0  for atom in fcc])
fcc.set_constraint(constraint)
#print fcc.get_tags()
#view(fcc)

calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=fcc',
            xc = 'pbe',
            kpts=[9,9,1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=fcc)
calc.get_memory()
calc.calculate()

#+END_SRC

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms, FixScaled
from ase import Atoms, Atom

#VASPRC['queue.mem'] = '8GB'
VASPRC['queue.walltime'] = '24:00:00'

calc = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00')
slab = calc.get_atoms()

#slab = fcc111('Pd', size=(2, 2, 5), a = 3.939,  vacuum=6.0)
#end = slab.copy()
p = slab.positions

pbridge = (p[17] + p[18])/2.0 + [0, 0, 2.4]
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(pbridge)


bridge = slab + add
constraint1 = FixAtoms(mask=[atom.tag > 0  for atom in bridge])
constraint2 = FixScaled(bridge.get_cell(), 20, [True, True, False])
bridge.set_constraint([constraint1, constraint2])
#print fcc.get_tags()
#view(bridge)

calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=bridge',
            xc = 'pbe',
            kpts=[9,9,1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=bridge)
calc.get_memory()
calc.calculate()

#+END_SRC

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms
from ase import Atoms, Atom

#VASPRC['queue.mem'] = '8GB'
VASPRC['queue.walltime'] = '24:00:00'

calc = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00')
slab = calc.get_atoms()

#slab = fcc111('Pd', size=(2, 2, 5), a = 3.939,  vacuum=6.0)
#end = slab.copy()
p = slab.positions

ptop = (p[17]  + [0, 0, 2.4])
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(ptop)

top = slab + add
constraint = FixAtoms(mask=[atom.tag > 0  for atom in top])
top.set_constraint(constraint)
#print fcc.get_tags()
#view(top)

calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=top',
            xc = 'pbe',
            kpts=[9,9,1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=top)
calc.get_memory()
calc.calculate()

#+END_SRC


#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms
from ase import Atoms, Atom

#VASPRC['queue.mem'] = '8GB'
VASPRC['queue.walltime'] = '24:00:00'

calc = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00')
slab = calc.get_atoms()

#slab = fcc111('Pd', size=(2, 2, 5), a = 3.939,  vacuum=6.0)
#end = slab.copy()
p = slab.positions

phcp = ((p[17]+p[18]+p[19])/3  + [0, 0, 2])
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(phcp)

hcp = slab + add
constraint = FixAtoms(mask=[atom.tag > 0  for atom in hcp])
hcp.set_constraint(constraint)
#print fcc.get_tags()
#view(hcp)

calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=hcp',
            xc = 'pbe',
            kpts=[9,9,1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=hcp)
calc.get_memory()
calc.calculate()

#+END_SRC

**** top-fcc
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms
from ase import Atoms, Atom

#VASPRC['queue.mem'] = '8GB'
#VASPRC['queue.walltime'] = '24:00:00'


fin = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=fcc').get_atoms()
ini = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=top').get_atoms()
images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/class=top_fcc/neb',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()
calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/top-fcc-fixed.png')

'''
for i in range(9):
    calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/class=top_fcc/image={0}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.calculate()
'''
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: 0.000001
:          Iterations: 32
:          Function evaluations: 64

[[./figures/top-fcc-fixed.png]]

**** fcc-hcp

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms
from ase import Atoms, Atom

#VASPRC['queue.mem'] = '8GB'
#VASPRC['queue.walltime'] = '24:00:00'


ini = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=fcc').get_atoms()
fin = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=hcp').get_atoms()
images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/class=fcc_hcp/neb',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/fcc-hcp-fixed.png')

'''
for i in range(9):
    calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/class=fcc_hcp/image={0}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.calculate()

'''
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.167086
:          Iterations: 15
:          Function evaluations: 30

[[./figures/fcc-hcp-fixed.png]]
**** hcp-top
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms
from ase import Atoms, Atom

#VASPRC['queue.mem'] = '8GB'
VASPRC['queue.walltime'] = '24:00:00'


ini= Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=hcp').get_atoms()
fin = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=top').get_atoms()
images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/class=hcp_top/neb',
            xc='pbe',
            kpts=[9, 9, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/hcp-top-fixed.png')
'''
for i in range(9):
    calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/class=hcp_top/image={0}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.calculate()
'''
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.826486
:          Iterations: 24
:          Function evaluations: 48

[[./figures/hcp-top-fixed.png]]

**** all
#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d
from amp import Amp
calc0 = Amp(load = './networks/db7/24-24/checkpoint-parameters.json')

En = []
E1 = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=top').potential_energy
E2 = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=fcc').potential_energy
E3 = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=hcp').potential_energy
calc1 = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/class=top_fcc/neb')
images, energies1 = calc1.get_neb()
nrg1 = E1 + energies1

for atoms in images:
    atoms.set_calculator(calc0)
    En += [atoms.get_potential_energy()]
calc2 = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/class=fcc_hcp/neb')
images, energies2 = calc2.get_neb()
nrg2 = E2 + energies2

for atoms in images:
    atoms.set_calculator(calc0)
    En += [atoms.get_potential_energy()]

calc3 = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/class=hcp_top/neb')
images, energies3 = calc3.get_neb()
nrg3 = E3 + energies3

for atoms in images:
    atoms.set_calculator(calc0)
    En += [atoms.get_potential_energy()]
nrg = []
nrg.append(nrg1[::-1])
nrg.append(nrg2[::-1])
nrg.append(nrg3[::-1])

print nrg
print En[::-1]
'''
#x = range(len(nrg))
#xarray = np.linspace(0, len(nrg))
#f1 = interp1d(x, nrg, kind='cubic', bounds_error=False)
#f2 = interp1d(x, E, kind='cubic', bounds_error=False)
#plt.plot(range(len(nrg)), nrg, 'bo', label = 'NEB')
#plt.plot(x, E, 'ro', label = 'NN')
#plt.plot(xarray, f1(xarray), 'b-')
#plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
plt.show()
'''
#+END_SRC

#+RESULTS:
: [array([-104.02334307, -103.98241757, -103.84634143, -103.66603531,
:        -103.48398825, -103.32938334, -103.22147716, -103.17362203,
:        -103.16314489]), array([-103.98963043, -103.96879078, -103.91413569, -103.86981663,
:        -103.85664787, -103.88095009, -103.93616107, -103.99930865,
:        -104.02334307]), array([-103.16314489, -103.17862415, -103.23595949, -103.34291469,
:        -103.48889736, -103.6590986 , -103.82724601, -103.95344617,
:        -103.98963043])]
: [-103.28510268167803, -103.28538590621191, -103.32522055450696, -103.39852397045277, -103.5035795135661, -103.63492426346689, -103.77655989480178, -103.89600411646913, -103.94661417323304, -103.94661417323304, -103.92070023042334, -103.87607775748047, -103.8412595208607, -103.8286101259781, -103.84238734836968, -103.87950410924992, -103.92465050803614, -103.94985513076412, -103.94985513076412, -103.89857730832301, -103.77771557589172, -103.6318323233937, -103.49589695331147, -103.3875652224247, -103.31514854654274, -103.28175167380081, -103.28510268167803]


#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
nrg =  np.array([-103.16314489, -103.17362203, -103.22147716, -103.32938334, -103.48398825, -103.66603531, -103.84634143, -103.98241757, -104.02334307, -103.99930865, -103.93616107, -103.88095009, -103.85664787, -103.86981663, -103.91413569, -103.96879078, -103.98963043, -103.95344617, -103.82724601, -103.6590986 , -103.48889736, -103.34291469, -103.23595949, -103.17862415, -103.16314489])

En = np.array([-103.28791408117687, -103.28210559551798, -103.31415598466465, -103.38233098208265, -103.48706752953666, -103.62298896847966, -103.77426775888706, -103.90140493445897, -103.95419139204513, -103.92986688779577, -103.88647148399599, -103.85058670163461, -103.83714940276464, -103.8489838586693, -103.88193490742502, -103.92461925347857, -103.9497983307213, -103.89741984451148, -103.77199794524479, -103.6258998874668, -103.49478956597667, -103.39306005807885, -103.32366362321665, -103.28567174974906, -103.28791408117687])

#nrg = nrg - nrg[0]
#En = En- En[0]

nrg = nrg/21
En = En/21

nrg = nrg - nrg[0]
En = En - En[0]
x = range(len(nrg))
xarray = np.linspace(0, len(nrg))
f1 = interp1d(x, nrg, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(range(len(nrg)), nrg, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
#plt.show()
plt.savefig('./figures/surf-adatom-NEB.png')
#+END_SRC

#+RESULTS:

[[./figures/surf-adatom-NEB.png]]

* DB
#+BEGIN_SRC python
from vasp import Vasp
A = [0, 2, 4, 5, 6, 7, 10, 11, 12, 13, 16, 17, 18, 19, 21, 24, 25, 26, 27, 28, 29, 30, 32, 33, 37, 38, 40, 41, 43, 44, 45, 46, 50, 52, 54, 55, 60, 61, 63, 64, 65, 66, 73, 74, 75, 76, 82, 87, 92, 93, 102, 103, 104, 107, 108, 113, 114, 119, 121, 123, 124, 128, 129, 133, 138, 139, 142, 145, 146, 147, 148, 149, 150, 154, 155, 158, 159, 160, 167, 170, 179, 180, 184, 189, 191, 193, 194, 195, 197, 198]
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md1/v_a=0_20/MD={}'.format(i))
    calc.write_db('./database/db4/data.db', parser='=', overwrite=False, keys={'dbkey':4}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calc = Vasp('NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=22')
calc.write_db('./database/db4/data.db', parser='=', overwrite=False, keys={'dbkey':4}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp

pos = ['fcc', 'hcp', 'bridge', 'top']
for cong in pos:
    calc = Vasp('NDFT/surface=fcc111/type=adatom/supercell=22/site={}'.format(cong))
    calc.write_db('./database/db4/data.db', parser='=', overwrite=False, keys={'dbkey':4}) 

#+END_SRC

#+RESULTS:

** keywords
#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

from ase.db import connect

db = connect('./database/db4/data.db')
data = db.select(['train_set=False'])

keys, cnt = {}, 0
for entry in data:
    cnt += 1
    for k, v in entry.key_value_pairs.iteritems():
        
        if k in keys:
            keys[k] += [v]
        else:
            keys[k] = [v]

print ('{0:15s} {1:15s} {2} calculations total'.format('keyword', 'value',cnt))

print('------------------------------------------------------')

for k, v in keys.iteritems():
    vals = list(set(v))
    if len(vals) <= 5:
        val = ", ".join(str(e) for e in vals)
        print('{0:15}: {1}'.format(k, val))

    else:
        val = ", ".join(str(e)[:5] for e in vals[:5])
        print('{0:15s}:{1}, etc...'.format(k, val))
#+END_SRC
#+RESULTS:
#+begin_example
keyword         value           183 calculations total
------------------------------------------------------
dirs           : 11, 44
MD             :1, 2, 3, 4, 5, etc...
train_set      : False
NN24           :-5.14, -234., -1.51, -243., -40.9, etc...
NN25           :-40.1, -84.0, -34.6, -4.50, -34.1, etc...
dbkey          : 0, 1, 2, 3, 4
image          :1, 2, 3, 5, 7, etc...
bulk           : sc, hcp, fcc, diam, bcc
lattice        : primitive
supercell      : 344, 233, 333, 223
v_a            :1_26, 1_47, 1_63, 0_20, 1_11, etc...
vrelax         : False
factor         :1.3, 1.0, 2.0, 1.45, 0.94, etc...
type           : vacancy, md, neb, eos, elastic
order          : md2, md0, md1
surface        : fcc111
#+end_example

* Training
** Training Set
#+BEGIN_SRC python
from ase.db import connect
import os
import random
import numpy as np

db = connect('./database/db4/data.db')

n = db.count()
n_train = int(round(n * 0.9))

n_ids =  np.array(range(n)) + 1

# This will sudo-randomly select 10% of the calculations
# Which is useful for reproducing our results.
random.seed(256)
train_samples = random.sample(n_ids, n_train)
valid_samples = set(n_ids) - set(train_samples)

db.update(list(train_samples), train_set=True)
db.update(list(valid_samples), train_set=False)

#+END_SRC

#+RESULTS:

** Training
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

for n in [10, 15, 18, 20, 24]:

    wd = 'networks/db4/{0}-{0}/'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)
    os.chdir(wd)

    run_amp = """#!/usr/bin/env python
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing

db = connect('../../../database/db4/data.db')

images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=4,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
""".format(n)

    cmd = '''#!/bin/bash
#PBS -N {}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=24:00:00
#PBS -l mem=16GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

    with open('submit.py', 'w') as f:
        f.write(run_amp)
    os.chmod('submit.py', 0777)

    with open('submit.sh', 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', 'submit.sh'])
    time.sleep(2)
    os.unlink('submit.sh')
    os.chdir(home)
#+END_SRC

load
load=os.path.join(wd, 'checkoutpoint-parameters-0.json'),
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

for n in [15, 18, 20, 24]:

    wd = 'networks/db4/{0}-{0}/'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)
    os.chdir(wd)

    run_amp = """#!/usr/bin/env python
import os
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing

db = connect('../../../database/db4/data.db')
wd = os.getcwd()
images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(load='checkpoint-parameters.json',
           label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=4,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
""".format(n)

    cmd = '''#!/bin/bash
#PBS -N {}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=24:00:00
#PBS -l mem=16GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

    with open('submit.py', 'w') as f:
        f.write(run_amp)
    os.chmod('submit.py', 0777)

    with open('submit.sh', 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', 'submit.sh'])
    time.sleep(2)
    os.unlink('submit.sh')
    os.chdir(home)
#+END_SRC

#+RESULTS:
: 1459461.gilgamesh.cheme.cmu.edu
: 1459462.gilgamesh.cheme.cmu.edu
: 1459463.gilgamesh.cheme.cmu.edu
: 1459464.gilgamesh.cheme.cmu.edu


#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing
import os

home = os.getcwd()
wd = 'networks/db3/10-10/'
os.chdir(wd)

db = connect('../../../database/db3/data.db')
wd = os.getcwd()
images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(load='parameters.json',
           label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=4,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
#+END_SRC

** Update

#+BEGIN_SRC python
from ase.db import connect
from amp import Amp

db = connect('./database/db4/data.db')
calc1 = Amp(load = './networks/db4/10-10/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db4/15-15/checkpoint-parameters.json')

for d in db.select():
    atoms = db.get_atoms(d.id)
    atoms.set_calculator(calc1)
    nrg1 = atoms.get_potential_energy()

    atoms.set_calculator(calc2)
    nrg2 = atoms.get_potential_energy()
    db.update(d.id, NN10 = nrg1, NN15 = nrg2)
#+END_SRC

#+RESULTS:

** Residual
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from ase.db import connect
from amp import Amp
import os

db = connect('database/db4/data.db')

fig, ax = plt.subplots(1, 2, sharey=True, figsize=(8, 4))

for i, n in enumerate([10, 15]):

    E, nnE, var, ind = [], [], [], []
    for j, d in enumerate(db.select('')):# dbkey=0
	E += [d.energy / d.natoms]
	nnE += [d['NN{}'.format(n)]/ d.natoms]
	var += [j]
	ind += [d.train_set]

    res = np.array(nnE) - np.array(E)
    mask = np.array(ind)
    valid = np.ma.masked_array(res, mask)
    train = np.ma.masked_array(res, ~mask)
    vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
    tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))

    ax[i].text(200, -0.050,
               'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
               color='b', ha='left')
    ax[i].text(200, -0.057,
               'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
               color='r', ha='left')

    ax[i].scatter(var, train, color='b')
    ax[i].scatter(var, valid, color='r')
    ax[i].plot([min(var), max(var)], [0, 0], 'k--')
    ax[i].set_xlim(min(var), max(var))

    ax[i].set_xlabel('Calculation ID')
    ax[i].set_title('8-{0}-{0}-1 framework'.format(n))

ax[0].set_ylim(-0.060, 0.060)
ax[0].set_ylabel('Residual error (eV/atom)')
plt.tight_layout()
plt.savefig('./figures/residual-4.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/residual-4.png]]

Large error configurations
#+BEGIN_SRC python
import numpy as np
from ase.db import connect
ids = []
db = connect('database/db4/data.db')
for i, d in enumerate(db.select('')):
    E = d.energy / d.natoms
    nE = d.NN15/ d.natoms
    if abs(E - nE) > 0.04:
        ids += [i]

print ids
#+END_SRC

#+RESULTS:
: [228, 342, 604]


*** Bulk Residual
#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db4/data.db')

S, Qe, Ne = [], [], []

for d in db.select(['type=eos']):
    S += [d.bulk]
    Qe += [d.energy/d.natoms]
    Ne += [d.NN15/d.natoms]
    
S = np.array(S)
Qe = np.array(Qe)
Ne = np.array(Ne)

cmap, hdl = {}, []

#print Ne
for s, c in zip(set(S), ['b', 'r', 'g', 'c', 'm']):
    cmap[s] = c
    hdl +=[mpatches.Patch(color = c, label = s)]

c = []
for s in S:
    c +=[cmap[s]]

RMSE = np.sqrt(sum((Ne-Qe)** 2) / len(Ne - Qe))

(mu, sigma) = norm.fit(Ne- Qe)

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
ax0.plot([min(Qe), 0], [0,0], 'k--', lw =2)
ax0.scatter(Qe, Ne-Qe, marker = 'o', color = c)
ax0.text(min(Qe) + 0.1, 0.14,
         'RMSE: {0:1.3f}'.format(RMSE),
         fontsize = 12, va = 'top', ha = 'left')
ax0.set_xlim(min(Qe), 0)
ax0.set_ylim(-0.05, 0.05)
ax0.set_xlabel('DFT potential energy (eV/atom)')
ax0.set_ylabel('Rsidual error (eV/atom)')
ax0.legend(loc = 'best', handles =hdl, fontsize = 8, frameon = False)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(Ne-Qe, 50,
                            range = (-0.05, 0.05),
                            weights = np.ones_like(Ne-Qe)/ len(Ne),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.05, 0.142, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.05, 0.122, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.05, 0.05)
ax1.set_xlim(0, 0.3)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
plt.tight_layout(w_pad = -0.5)

plt.savefig('./figures/eos-residual-4.png')
#plt.show()

#+END_SRC

#+RESULTS:

eos-residual

[[./figures/eos-residual-4.png]]



*** total residual
#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db4/data.db')

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
E, nE, var, ind = [], [], [], []
for j, d in enumerate(db.select('surface=fcc111')):# dbkey=0
    E += [d.energy / d.natoms]
    nE += [d.NN10/ d.natoms]
    var += [j]
    ind += [d.train_set]

E = np.array(E)
nE = np.array(nE)
res = np.array(nE) - np.array(E)
mask = np.array(ind)
valid = np.ma.masked_array(res, mask)
train = np.ma.masked_array(res, ~mask)
vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))

ax0.text(380, -0.048,
           'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
           color='b', ha='left')
ax0.text(270, -0.055,
           'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
           color='r', ha='left')

ax0.scatter(var, train, color='b')
ax0.scatter(var, valid, color='r')
ax0.plot([min(var), max(var)], [0, 0], 'k--')
ax0.set_xlim(min(var), max(var))

ax0.set_xlabel('Calculation ID')
ax0.set_title('8-10-10-1 framework')


(mu, sigma) = norm.fit(nE - E)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(nE-E, 50,
                            range = (-0.05, 0.05),
                            weights = np.ones_like(nE-E)/ len(nE),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.01, 0.04, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.01, 0.03, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.05, 0.05)
ax1.set_xlim(0, 0.20)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
ax1.set_title('Error Distribution')
plt.tight_layout(w_pad = -0.5)
plt.savefig('./figures/error-distribution-4.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/error-distribution-4.png]]
* Application
** MD
*** Trajectory
**** perfect
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db4')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(2, 2, 5), a=3.939, vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(Amp(load="./../../networks/db4/15-15/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD-fixed.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

**** vacancy
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db4')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(2, 2, 5), a=3.939, vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
del atoms[-1]
atoms.set_calculator(Amp(load="./../../networks/db4/15-15/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD1-19.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1460223.gilgamesh.cheme.cmu.edu

*** NN Prediction
**** perfect
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp

calc1 = Amp(load = './networks/db4/10-10/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db4/15-15/checkpoint-parameters.json')
traj = Trajectory('./database/db4/MD-fixed.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/MD225-5.png')
#+END_SRC

#+RESULTS:

[[./figures/MD225-5.png]]

**** vacancy
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp

calc1 = Amp(load = './networks/db4/10-10/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db4/15-15/checkpoint-parameters.json')
traj = Trajectory('./database/db4/MD1-19.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
plt.show()
#plt.savefig('./figures/MD225-5.png')
#+END_SRC

#+RESULTS:

** Bulk Properties
*** Cohesive energy
Atomic energy
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase import Atoms, Atom
from ase.visualize import view
VASPRC['queue.walltime'] = '24:00:00'

atoms = Atoms([Atom('Pd', [5, 5, 5])],
              cell = (7, 8, 9))

calc = Vasp('NDFT/atomic-Pd',
          xc = 'pbe',
          encut = 350,
          kpts = [1]*3,
          atoms = atoms) 

calc.calculate()

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/atomic-Pd submitted: 1442984.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
from vasp import Vasp
from amp import Amp
calc1 = Amp(load='./networks/db4/15-15/checkpoint-parameters.json')

calc = Vasp ('./NDFT/atomic-Pd') 
Eatom = calc.potential_energy
 
calc = Vasp ('./NDFT/bulk=fcc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEfcc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEfcc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=bcc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEbcc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEbcc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=hcp/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEhcp = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEhcp = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=sc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEsc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEsc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=diam/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEdiam = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEdiam = atoms.get_potential_energy()/len(atoms)
print DEfcc-Eatom, NEfcc-Eatom
print DEbcc-Eatom, NEbcc-Eatom
print DEhcp-Eatom, NEhcp-Eatom
print DEsc-Eatom, NEsc-Eatom
print DEdiam-Eatom, NEdiam-Eatom
#+END_SRC

#+RESULTS:
: -3.75476834 -3.75462069529
: -3.71312559 -3.74156357701
: -3.72459561 -3.75344541272
: -3.2532599 -3.2528306537
: -2.6162620675 -2.62032974052

*** Bulk Modulus
#+BEGIN_SRC python
from ase.db import connect
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState
from ase.units import kJ
import numpy as np
from vasp import Vasp
from amp import Amp

factor = np.arange(0.85, 1.2, 0.01)
calc2 = Amp(load='./networks/db4/15-15/checkpoint-parameters.json')
configs = ['fcc', 'bcc', 'hcp', 'sc', 'diam']

for config in configs:
    nrg, vol = [], []
    nn = []
    for f in factor:
        calc = Vasp('./NDFT/bulk={0}/type=eos/factor={1:.2f}'.format(config,f))
        atoms = calc.get_atoms()
        nrg += [atoms.get_potential_energy()/len(atoms)]
        vol += [atoms.get_volume()/len(atoms)]
        atoms.set_calculator(calc2)
        nn +=[atoms.get_potential_energy()/len(atoms)]
        

    vol = np.array(vol)
    nrg = np.array(nrg)
    nn = np.array(nn)
# Fit the data to SJEOS
    eos = EquationOfState(vol, nrg)
    v0, e0, B0 = eos.fit()
    eos = EquationOfState(vol, nn)
    v1, e1, B1 = eos.fit()
    print '{0}'.format(config)
    print v0, e0, B0
    print v1, e1, B1
#+END_SRC

#+RESULTS:
#+begin_example
fcc
15.2979724806 -5.22438476072 1.09507457295
15.2920941055 -5.21955810425 1.1005260915
bcc
15.4257962561 -5.18249419589 1.06469804063
15.4435903952 -5.18716475228 1.06608307803
hcp
15.3645769219 -5.19379582623 1.08254355793
15.3134956647 -5.21647101448 1.10513375669
sc
17.8024966568 -4.72110919112 0.782438954048
17.7845001473 -4.72145099467 0.782964233772
diam
24.3558101786 -4.08130798908 0.428150007251
24.3349178688 -4.08186369292 0.429893179488
#+end_example

*** Elastic Constant
**** 11, 12
#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.01, 11)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=11/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')
    #calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
#+END_SRC

#+RESULTS:
: [ 2.22936683 -0.34128023]
: [ 2.58330265 -0.34127457]

#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.01, 11)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=11/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')
    #calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')

    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
plt.plot(factor, Ed/Vd[0], 'bo', label = 'DFT')
plt.plot(factor, En/Vd[0], 'ro', label = 'NN')
plt.plot(factor, func(factor, *poptd), 'b-', label = 'DFT fit')
plt.plot(factor, func(factor, *poptn), 'r-', label = 'NN fit')

plt.xlabel('Strain')
plt.ylabel('Energy Density [eV/$\AA^3$]')
plt.legend(loc='best')
#plt.savefig('./figures/elastic-1.png')
plt.show()
#+END_SRC

#+RESULTS:
: [ 2.22936683 -0.34128023]
: [ 2.87528197 -0.34126408]

**** 44
#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.01, 11)

Ed, En, Vd, Vn = [], [], [], []


# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=44/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed.append(atoms.get_potential_energy())
    Vd.append(atoms.get_volume()/len(atoms))

  #  calc2 = Amp(load='./networks/db3/2-25/checkpoint-parameters.json')
    calc2 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')
    #calc2 = Amp(load = './networks/db1/4-40-global/-parameters-checkpoint-0.json')
    atoms.set_calculator(calc2)
    En.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed/Vd[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En/Vd[0])
print poptn
#+END_SRC

#+RESULTS:
: [ 0.73280411 -0.34127966]
: [ 0.71863853 -0.34126554]

subplot

#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.01, 11)

Ed1, En1, Vd1, Vn1 = [], [], [], []
Ed4, En4, Vd4, Vn4 = [], [], [], []

# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=11/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed1.append(atoms.get_potential_energy())
    Vd1.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')

    atoms.set_calculator(calc2)
    En1.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed1/Vd1[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En1/Vd1[0])
print poptn

plt.subplot(1, 2, 1)
plt.plot(factor, Ed1/Vd1[0], 'bo', label = 'DFT')
plt.plot(factor, En1/Vd1[0], 'ro', label = 'NN')
plt.plot(factor, func(factor, *poptd), 'b-', label = 'DFT fit')
plt.plot(factor, func(factor, *poptn), 'r-', label = 'NN fit')
plt.xlabel('Strain')
plt.ylabel('Energy Density [eV/$\AA^3$]')
plt.legend(loc='best')
plt.title('Strain 1')

for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=44/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed4.append(atoms.get_potential_energy())
    Vd4.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')

    atoms.set_calculator(calc2)
    En4.append(atoms.get_potential_energy())

poptd, pcovd = curve_fit(func, factor, Ed4/Vd4[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En4/Vd4[0])
print poptn

#plt.savefig('./figures/elastic-1.png')
plt.subplot(1, 2, 2)
plt.plot(factor, Ed4/Vd4[0], 'bo', label = 'DFT')
plt.plot(factor, En4/Vd4[0], 'ro', label = 'NN')
plt.plot(factor, func(factor, *poptd), 'b-', label = 'DFT fit')
plt.plot(factor, func(factor, *poptn), 'r-', label = 'NN fit')
plt.xlabel('Strain')
plt.ylabel('Energy Density [eV/$\AA^3$]')
plt.legend(loc='best')
plt.title('Strain 2')

plt.tight_layout()
plt.savefig('./figures/els-cons-4.png')
#plt.show()
#+END_SRC

#+RESULTS:
: [ 2.22936683 -0.34128023]
: [ 2.87528197 -0.34126408]
: [ 0.73280411 -0.34127966]
: [ 0.71863853 -0.34126554]

[[./figures/els-cons-4.png]]

**** calculation
#+BEGIN_SRC python
'''
B = 1.09507457295
a = 2.21553499/6
b = 0.66616554
'''

B = 1.0950
a = 3.0178/6
b = 0.8153
C4 = b/2
C2 = (3*B - 2*a)/3
C1 = 2*a + C2

print C1, C2, C4
print C1 * 160.2177
print C2 * 160.2177
print C4 * 160.2177
#+END_SRC

#+RESULTS:
: 1.76562222222 0.759688888889 0.40765
: 282.883931513
: 121.715606493
: 65.312745405

**** reference 
#+BEGIN_SRC python
from vasp import Vasp
calc = Vasp('~/Research/Bulk/DFT/bulk=fcc/type=elastic/elastic')

EM = calc.get_elastic_moduli()

print EM
#+END_SRC

#+RESULTS:
: [[ 206.71093  155.54113  155.54113    0.         0.         0.     ]
:  [ 155.54113  206.71093  155.54113    0.         0.         0.     ]
:  [ 155.54113  155.54113  206.71093    0.         0.         0.     ]
:  [   0.         0.         0.        59.78395    0.         0.     ]
:  [   0.         0.         0.         0.        59.78395    0.     ]
:  [   0.         0.         0.         0.         0.        59.78395]]


* 6th DFT
** Surface MD
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 2
images = Trajectory('./database/db4/MD-fixed.traj', 'r')

for i in range(50):
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md2/v_a=0_20/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC




#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
from vasp import Vasp
from vasp.vasprc import VASPRC



calc1 = Amp(load = './networks/db4/10-10/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db4/15-15/checkpoint-parameters.json')
images = Trajectory('./database/db4/MD-fixed.traj', 'r')
E1, E2 = [], []

for atoms in images:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in images:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)


nrg, res, s = [], [], []
calcs = []
A = range(50)
for i in A:        
        
        calc = Vasp('NDFT/surface=fcc111/type=md/order=md2/v_a=0_20/MD={}'.format(i))

        nrg += [calc.potential_energy/20]


plt.plot(range(len(E1)), E1, 'b-', label='NN1 prediction')
plt.plot(range(len(E2)), E2, 'r--', label='NN2 prediction')
plt.scatter(A, nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(E1)))
plt.ylabel('Potential energy (eV)')

plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/225MD-5.png')

#+END_SRC

#+RESULTS:

[[./figures/225MD-5.png]]

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 2
images = Trajectory('./database/db4/MD1-19.traj', 'r')

for i in range(50):
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md2/v_a=1_19/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC


#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp
from vasp import Vasp
from vasp.vasprc import VASPRC



calc1 = Amp(load = './networks/db4/10-10/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db4/15-15/checkpoint-parameters.json')
images = Trajectory('./database/db4/MD1-19.traj', 'r')
E1, E2 = [], []

for atoms in images:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in images:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)


nrg, res, s = [], [], []
calcs = []
A = range(50)
for i in A:        
        
        calc = Vasp('NDFT/surface=fcc111/type=md/order=md2/v_a=1_19/MD={}'.format(i))

        nrg += [calc.potential_energy/20]


plt.plot(range(len(E1)), E1, 'b-', label='NN1 prediction')
plt.plot(range(len(E2)), E2, 'r--', label='NN2 prediction')
plt.scatter(A, nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(E1)))
plt.ylabel('Potential energy (eV)')

plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
#plt.savefig('./figures/225MD-5.png')
plt.show()
#+END_SRC

#+RESULTS:

* DB
** dbkey 5
#+BEGIN_SRC python
from vasp import Vasp
A = range (50)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md2/v_a=0_20/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':5, 'structure':'surface'})  
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python

from vasp import Vasp
A = range (50)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md2/v_a=1_19/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':5, 'structure':'surface'})  

#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=34'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':4, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=44'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':4, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

*** trajectory

#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=22'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':4}) for A in images]
#+END_SRC

#+RESULTS:

** write
*** DBkey0
#+BEGIN_SRC python
from vasp import Vasp

factor = [0.900, 0.950, 1.000, 1.050]

cells= ['222', '223', '233', '333', '334', '344', '444'] 

calcs = []
for cell in cells:

    for x in factor:
    
        wd = './NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell={0}/factor={1:.3f}'.format(cell,x)
        #wd = './NDFT/bulk=fcc/type=vacancy/lattice=cubic/supercell={0}/factor={1:.3f}'.format(cell,x)
        calc = Vasp(wd)

        calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':0, 'structure':'bulk'}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []
for i in range(200):
    wd = './NDFT/bulk=fcc/type=md/order=md0/v_a=0_8/MD={0}'.format(i)

    calc = Vasp(wd)
    calcs += [calc]
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':0, 'structure':'bulk'}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
import numpy as np

factor = np.append(np.arange(0.85, 1.2, 0.01),
                   np.arange(1.2, 2.125, 0.05))


cells = ['fcc', 'bcc', 'hcp', 'sc', 'diam']
for cell in cells:

    for x in factor:
    
   
        wd = './NDFT/bulk={0}/type=eos/factor={1:.2f}'.format(cell,x)
        calc = Vasp(wd)

        calc.write_db('./database/ddb5/data.db', parser='=', overwrite=False, keys={'dbkey':0, 'structure':'bulk'}) 
#+END_SRC

#+RESULTS:

*** DBkey1
**** 0:8
#+BEGIN_SRC python
from vasp import Vasp

for i in range(200):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=0_8/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':1, 'structure':'bulk'})  
#+END_SRC

#+RESULTS:

**** 1:7
#+BEGIN_SRC python
from vasp import Vasp

for i in range(51):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_7/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':1, 'structure':'bulk'})  
#+END_SRC

#+RESULTS:

**** 1:11
#+BEGIN_SRC python
from vasp import Vasp

for i in range(22):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_11/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':1, 'structure':'bulk'})  
#+END_SRC

#+RESULTS:

**** 1:17
#+BEGIN_SRC python
from vasp import Vasp

for i in range(38):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_17/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':1, 'structure':'bulk'})  
#+END_SRC

#+RESULTS:

**** 1:26
#+BEGIN_SRC python
from vasp import Vasp

for i in range(16):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_26/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':1, 'structure':'bulk'})  
#+END_SRC

#+RESULTS:

**** 1:35
#+BEGIN_SRC python
from vasp import Vasp

for i in range(10):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_35/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':1, 'structure':'bulk'})   
#+END_SRC

#+RESULTS:

**** 1:47
#+BEGIN_SRC python
from vasp import Vasp

for i in range(10):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_47/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':1, 'structure':'bulk'})   
#+END_SRC

#+RESULTS:

**** 1:63
#+BEGIN_SRC python
from vasp import Vasp

for i in range(10):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_63/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':1, 'structure':'bulk'})  
#+END_SRC

#+RESULTS:

*** DBkey2
#+BEGIN_SRC python
from vasp import Vasp
import numpy as np

factor = np.linspace(0, 0.04, 41)

for x in factor:
    wd = './NDFT/bulk=fcc/type=elastic/dirs=11/factor={:.3f}'.format(x)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})   
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
import numpy as np

factor = np.linspace(0, 0.04, 41)

for x in factor:
    wd = './NDFT/bulk=fcc/type=elastic/dirs=44/factor={:.3f}'.format(x)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp

for cell in ['222', '223', '233', '333']:

    for i in range(9):
        wd = './NDFT/bulk=fcc/type=neb/supercell={0}/image={1}'.format(cell, i)
        calc = Vasp(wd)
        calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []
a = [86, 87, 88, 90, 91, 92, 97, 98, 99, 100, 101, 106, 107, 108, 109, 111, 112, 116, 117, 118, 120, 121, 122, 123, 129, 130, 131, 132, 133, 134, 141, 142, 143, 144, 145, 150, 151, 152, 153, 176, 177, 178, 179, 180, 181, 182, 183, 184, 188, 189, 190, 191, 196, 197, 198, 199]
for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/MD={0}'.format(i)  
    calc = Vasp(wd)
    
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []
a = [0, 3, 7, 8, 11, 12, 20, 21, 28, 39, 43, 46, 50, 51, 53, 54, 57, 58, 59, 60, 64, 65, 66, 67, 68, 69, 71, 72, 73, 79, 80, 88, 91, 92, 98, 99, 101, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 118, 119, 120, 121, 122, 123, 124, 125, 127, 128, 129, 131, 132, 133, 134, 135, 136, 137, 138, 142, 143, 144, 145, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 184, 185, 186, 187, 188, 189, 190, 191, 192, 194, 195, 196, 197, 198, 199]
for i in a:  
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_11/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []
a =  [7, 43, 47, 49, 51, 55, 62, 66, 70, 74, 75, 79, 80, 81, 82, 88, 89, 90, 94, 95, 96, 97, 101, 102, 106, 109, 113, 114, 117, 118, 119, 123, 124, 125, 126, 127, 128, 131, 132, 134, 135, 136, 139, 140, 141, 142, 143, 145, 146, 147, 149, 150, 151, 155, 157, 158, 159, 160, 161, 162, 163, 165, 166, 167, 168, 169, 170, 172, 173, 174, 175, 176, 177, 178, 180, 181, 182, 183, 184, 185, 186, 187, 188, 190, 191, 192, 193, 194, 197, 198, 199]
for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_17/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []
a = [0, 2, 3, 4, 7, 8, 11, 12, 15, 16, 19, 20, 23, 24, 27, 28, 32, 36, 40, 41, 45, 46, 49, 52, 53, 56, 57, 60, 65, 67, 69, 75, 77, 79, 86, 87, 90, 91, 97, 108, 114, 116, 117, 118, 120, 124, 125, 128, 129, 130, 135, 136, 137, 138, 140, 142, 143, 144, 149, 150, 154, 155, 156, 160, 161, 164, 165, 167, 168, 169, 170, 171, 174, 179, 180, 181, 182, 183, 186, 187, 188, 190, 192, 193, 194, 197, 199]
for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})
#+END_SRC


#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 20, 21, 23, 24, 25, 28, 29, 30, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 45, 46, 47, 49, 50, 51, 52, 53, 55, 56, 57, 58, 59, 60, 62, 63, 64, 65, 67, 68, 71, 72, 73, 76, 77, 78, 80, 81, 83, 84, 85, 88, 89, 90, 91, 92, 94, 95, 96, 97, 98, 99]

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []
for i in range(100):
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_47/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)
del a[9]
for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_63/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []

#a = range(0, 21)
#a = range (23, 50)
a = range(0, 50)
del a[11]
del a[21]
#print a

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=1/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})


#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=2/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=3/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=4/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})
#+END_SRC

#+RESULTS:

**** Surface
#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':2, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=relaxation/supercell=23/factor=1.00'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':2, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=relaxation/supercell=33/factor=1.00'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':2, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

*** DBkey3
#+BEGIN_SRC python
from vasp import Vasp
for i in range(200):        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md0/v_a=0_20/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':3, 'structure':'surface'}) 
#+END_SRC

#+RESULTS:

*** DBkey4
#+BEGIN_SRC python
from vasp import Vasp
A = [0, 2, 4, 5, 6, 7, 10, 11, 12, 13, 16, 17, 18, 19, 21, 24, 25, 26, 27, 28, 29, 30, 32, 33, 37, 38, 40, 41, 43, 44, 45, 46, 50, 52, 54, 55, 60, 61, 63, 64, 65, 66, 73, 74, 75, 76, 82, 87, 92, 93, 102, 103, 104, 107, 108, 113, 114, 119, 121, 123, 124, 128, 129, 133, 138, 139, 142, 145, 146, 147, 148, 149, 150, 154, 155, 158, 159, 160, 167, 170, 179, 180, 184, 189, 191, 193, 194, 195, 197, 198]
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md1/v_a=0_20/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':4, 'structure':'surface'}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=22'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':4, 'structure':'surface'}) for A in images]
#+END_SRC
#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=23'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':4, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=33'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':4, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read
pos = ['fcc', 'hcp', 'bridge', 'top']
for cong in pos:
    wd = 'NDFT/surface=fcc111/type=adatom/supercell=22/site={}'.format(cong)
    images = read(wd + '/vasprun.xml', ':')
    calc = Vasp(wd)

    [calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':4, 'structure':'surface'}) for A in images] 

#+END_SRC

#+RESULTS:

** keywords
#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

from ase.db import connect

db = connect('./database/db5/data.db')
data = db.select(['train_set=True'])

keys, cnt = {}, 0
for entry in data:
    cnt += 1
    for k, v in entry.key_value_pairs.iteritems():
        
        if k in keys:
            keys[k] += [v]
        else:
            keys[k] = [v]

print ('{0:15s} {1:15s} {2} calculations total'.format('keyword', 'value',cnt))

print('------------------------------------------------------')

for k, v in keys.iteritems():
    vals = list(set(v))
    if len(vals) <= 5:
        val = ", ".join(str(e) for e in vals)
        print('{0:15}: {1}'.format(k, val))

    else:
        val = ", ".join(str(e)[:5] for e in vals[:5])
        print('{0:15s}:{1}, etc...'.format(k, val))
#+END_SRC
#+RESULTS:
#+begin_example
keyword         value           1967 calculations total
------------------------------------------------------
dirs           : 11, 44
MD             :0, 1, 2, 3, 4, etc...
vrelax         : False
train_set      : True
image          :0, 1, 2, 3, 4, etc...
site           : bridge, top, fcc, hcp
dbkey          :0, 1, 2, 3, 4, etc...
bulk           : sc, hcp, fcc, diam, bcc
lattice        : primitive
supercell      :33, 233, 333, 334, 22, etc...
v_a            :1_7, 1_47, 1_63, 0_20, 1_11, etc...
surface        : fcc111
factor         :1.25, 1.0, 2.0, 1.5, 0.036, etc...
type           :md, elast, vacan, neb, adato, etc...
order          : md2, md0, md1
structure      : bulk, surface
#+end_example

* Training
** Training Set
#+BEGIN_SRC python
from ase.db import connect
import os
import random
import numpy as np

db = connect('./database/db5/data.db')

n = db.count()
n_train = int(round(n * 0.9))

n_ids =  np.array(range(n)) + 1

# This will sudo-randomly select 10% of the calculations
# Which is useful for reproducing our results.
random.seed(256)
train_samples = random.sample(n_ids, n_train)
valid_samples = set(n_ids) - set(train_samples)

db.update(list(train_samples), train_set=True)
db.update(list(valid_samples), train_set=False)

#+END_SRC

#+RESULTS:

** Training
#+BEGIN_SRC python
import os
import subprocess
import time
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing

home = os.getcwd()

for n in [2]:

    wd = 'temp/db5/{0}-{0}/'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)
    os.chdir(wd)


from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing

db = connect('../../../database/db5/data.db')

images = []
for d in db.select(''):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, 2)))

calc.train(images=images,
	   data_format='db',
	   cores=4,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)

#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

for n in [15, 18, 20, 24]:

    wd = 'networks/db5/{0}-{0}/'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)
    os.chdir(wd)

    run_amp = """#!/usr/bin/env python
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing

db = connect('../../../database/db5/data.db')

images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=8,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
""".format(n)

    cmd = '''#!/bin/bash
#PBS -N {}
#PBS -l nodes=1:ppn=8
#PBS -l walltime=168:00:00
#PBS -l mem=16GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

    with open('submit.py', 'w') as f:
        f.write(run_amp)
    os.chmod('submit.py', 0777)

    with open('submit.sh', 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', 'submit.sh'])
    time.sleep(2)
    os.unlink('submit.sh')
    os.chdir(home)
#+END_SRC

#+RESULTS:
: 1460463.gilgamesh.cheme.cmu.edu
: 1460464.gilgamesh.cheme.cmu.edu
: 1460465.gilgamesh.cheme.cmu.edu
: 1460466.gilgamesh.cheme.cmu.edu

load
load=os.path.join(wd, 'checkoutpoint-parameters-0.json'),
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

for n in [18]:

    wd = 'networks/db5/{0}-{0}/'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)
    os.chdir(wd)

    run_amp = """#!/usr/bin/env python
import os
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing

db = connect('../../../database/db5/data.db')
wd = os.getcwd()
images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(load='checkpoint-parameters.json',
           label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=4,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
""".format(n)

    cmd = '''#!/bin/bash
#PBS -N {}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=168:00:00
#PBS -l mem=16GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

    with open('submit.py', 'w') as f:
        f.write(run_amp)
    os.chmod('submit.py', 0777)

    with open('submit.sh', 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', 'submit.sh'])
    time.sleep(2)
    os.unlink('submit.sh')
    os.chdir(home)
#+END_SRC

#+RESULTS:
: 1461120.gilgamesh.cheme.cmu.edu


#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing
import os

home = os.getcwd()
wd = 'networks/db3/10-10/'
os.chdir(wd)

db = connect('../../../database/db3/data.db')
wd = os.getcwd()
images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(load='parameters.json',
           label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=4,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
#+END_SRC

** Update

#+BEGIN_SRC python
from ase.db import connect
from amp import Amp

db = connect('./database/db5/data.db')
calc1 = Amp(load = './networks/db4/15-15/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db4/20-20/checkpoint-parameters.json')

for d in db.select():
    atoms = db.get_atoms(d.id)
    atoms.set_calculator(calc1)
    nrg1 = atoms.get_potential_energy()

    atoms.set_calculator(calc2)
    nrg2 = atoms.get_potential_energy()
    db.update(d.id, NN15 = nrg1, NN20 = nrg2)
#+END_SRC

#+RESULTS:

** Residual
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from ase.db import connect
from amp import Amp
import os

db = connect('database/db5/data.db')

fig, ax = plt.subplots(1, 2, sharey=True, figsize=(8, 4))

for i, n in enumerate([15, 20]):

    E, nnE, var, ind = [], [], [], []
    for j, d in enumerate(db.select('')):# dbkey=0
	E += [d.energy / d.natoms]
	nnE += [d['NN{}'.format(n)]/ d.natoms]
	var += [j]
	ind += [d.train_set]

    res = np.array(nnE) - np.array(E)
    mask = np.array(ind)
    valid = np.ma.masked_array(res, mask)
    train = np.ma.masked_array(res, ~mask)
    vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
    tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))

    ax[i].text(200, -0.050,
               'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
               color='b', ha='left')
    ax[i].text(200, -0.057,
               'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
               color='r', ha='left')

    ax[i].scatter(var, train, color='b')
    ax[i].scatter(var, valid, color='r')
    ax[i].plot([min(var), max(var)], [0, 0], 'k--')
    ax[i].set_xlim(min(var), max(var))

    ax[i].set_xlabel('Calculation ID')
    ax[i].set_title('8-{0}-{0}-1 framework'.format(n))

ax[0].set_ylim(-0.060, 0.060)
ax[0].set_ylabel('Residual error (eV/atom)')
plt.tight_layout()
plt.savefig('./figures/residual-5.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/residual-5.png]]

Large error configurations
#+BEGIN_SRC python
import numpy as np
from ase.db import connect
ids = []
db = connect('database/db5/data.db')
for i, d in enumerate(db.select('')):
    E = d.energy / d.natoms
    nE = d.NN15/ d.natoms
    if abs(E - nE) > 0.04:
        ids += [i]

print ids
#+END_SRC

#+RESULTS:
: [228, 770, 2122]

#+BEGIN_SRC python
from ase.db import connect

db = connect('database/db5/data.db')
for i, d in enumerate(db.select('id=2122')):
        for key in d:
            print ('{0:25}:{1}'.format(key, d[key]))
#+END_SRC

#+RESULTS:
#+begin_example
forces                   :[[-0.00609386 -0.00475205 -0.03970749]
 [ 0.00609386 -0.00475205 -0.03970749]
 [ 0.          0.00300473 -0.05314357]
 [ 0.          0.00588724 -0.05557616]
 [-0.00077056  0.00838713  0.07530263]
 [ 0.00077056  0.00838713  0.07530263]
 [ 0.         -0.01222171  0.03860598]
 [ 0.         -0.01163335  0.03387169]
 [ 0.          0.00167858 -0.00083004]
 [ 0.          0.00686816 -0.00656157]
 [ 0.00627474  0.0083125  -0.00454085]
 [-0.00627474  0.0083125  -0.00454085]
 [ 0.00267647 -0.00172957 -0.00718877]
 [-0.00267647 -0.00172957 -0.00718877]
 [ 0.          0.01258181 -0.01189079]
 [ 0.         -0.00682303  0.00846076]
 [ 0.04504862 -0.01578173  0.01304872]
 [-0.04504862 -0.01578173  0.01304872]
 [ 0.         -0.03066894 -0.00811017]
 [ 0.         -0.01806074 -0.01240103]
 [ 0.          0.06051467 -0.00625358]]
calculator               :unknown
site                     :bridge
surface                  :fcc111
supercell                :22
dbkey                    :4
calculator_parameters    :"\"\\\"\\\\\\\"{}\\\\\\\"\\\"\""
mtime                    :16.6834972741
structure                :surface
ctime                    :16.673066159
stress                   :[  1.37760563e-02   1.88254252e-02   3.35674038e-03  -8.69619532e-05
  -0.00000000e+00  -0.00000000e+00]
NN15                     :-104.041524486
train_set                :True
positions                :[[  5.57058719   1.60809      5.99999991]
 [  2.78529358   1.60809      5.99999991]
 [  6.963234     4.02022503   5.99999991]
 [  4.17794039   4.02022503   5.99999991]
 [  0.           0.           8.27418277]
 [  2.78529361   0.           8.27418277]
 [  1.39264681   2.41213502   8.27418277]
 [  4.17794042   2.41213502   8.27418277]
 [  1.39264683   0.80932017  10.54679329]
 [  4.17794044   0.80820605  10.54989662]
 [  2.78425224   3.21639883  10.53906007]
 [  5.57162859   3.21639883  10.53906007]
 [  5.56520943   1.62759206  12.83108296]
 [  2.7906714    1.62759206  12.83108296]
 [  6.96323403   4.00944785  12.80584136]
 [  4.17794044   4.02442147  12.79994334]
 [ -0.06521576  -0.02424263  15.01919264]
 [  2.85050937  -0.02424263  15.01919264]
 [  1.39264681   2.35336471  15.18535112]
 [  4.17794039   2.45061046  15.18967764]
 [  1.39264681   0.          17.09690903]]
user                     :tianyug1
NN20                     :-103.92314303
id                       :2122
cell                     :[[  5.57058722   0.           0.        ]
 [  2.78529361   4.82427005   0.        ]
 [  0.           0.          21.09673084]]
pbc                      :[ True  True  True]
type                     :adatom
energy                   :-103.93990493
unique_id                :89ca0693b301644cce2af0c5d6b5c2fa
numbers                  :[46 46 46 46 46 46 46 46 46 46 46 46 46 46 46 46 46 46 46 46 46]
#+end_example

*** Bulk Residual
#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db4/data.db')

S, Qe, Ne = [], [], []

for d in db.select(['type=eos']):
    S += [d.bulk]
    Qe += [d.energy/d.natoms]
    Ne += [d.NN15/d.natoms]
    
S = np.array(S)
Qe = np.array(Qe)
Ne = np.array(Ne)

cmap, hdl = {}, []

#print Ne
for s, c in zip(set(S), ['b', 'r', 'g', 'c', 'm']):
    cmap[s] = c
    hdl +=[mpatches.Patch(color = c, label = s)]

c = []
for s in S:
    c +=[cmap[s]]

RMSE = np.sqrt(sum((Ne-Qe)** 2) / len(Ne - Qe))

(mu, sigma) = norm.fit(Ne- Qe)

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
ax0.plot([min(Qe), 0], [0,0], 'k--', lw =2)
ax0.scatter(Qe, Ne-Qe, marker = 'o', color = c)
ax0.text(min(Qe) + 0.1, 0.14,
         'RMSE: {0:1.3f}'.format(RMSE),
         fontsize = 12, va = 'top', ha = 'left')
ax0.set_xlim(min(Qe), 0)
ax0.set_ylim(-0.05, 0.05)
ax0.set_xlabel('DFT potential energy (eV/atom)')
ax0.set_ylabel('Rsidual error (eV/atom)')
ax0.legend(loc = 'best', handles =hdl, fontsize = 8, frameon = False)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(Ne-Qe, 50,
                            range = (-0.05, 0.05),
                            weights = np.ones_like(Ne-Qe)/ len(Ne),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.05, 0.142, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.05, 0.122, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.05, 0.05)
ax1.set_xlim(0, 0.3)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
plt.tight_layout(w_pad = -0.5)

plt.savefig('./figures/eos-residual-4.png')
#plt.show()

#+END_SRC

#+RESULTS:

eos-residual

[[./figures/eos-residual-4.png]]



*** surface residual
#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db5/data.db')

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
E, nE, var, ind = [], [], [], []
#for j, d in enumerate(db.select(['order=md2','structure=surface'])):# dbkey=0
#for j, d in enumerate(db.select(['v_a=0_20'])):# dbkey=0
#for j, d in enumerate(db.select(['type=vacancy', 'structure=surface'])):# dbkey=0
for j, d in enumerate(db.select(['type=neb'])):
    E += [d.energy / d.natoms]
    nE += [d.NN15/ d.natoms]
    var += [j]
    ind += [d.train_set]

E = np.array(E)
nE = np.array(nE)
res = np.array(nE) - np.array(E)
mask = np.array(ind)
valid = np.ma.masked_array(res, mask)
train = np.ma.masked_array(res, ~mask)
vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))

ax0.text(380, -0.048,
           'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
           color='b', ha='left')
ax0.text(270, -0.055,
           'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
           color='r', ha='left')

ax0.scatter(var, train, color='b')
ax0.scatter(var, valid, color='r')
ax0.plot([min(var), max(var)], [0, 0], 'k--')
ax0.set_xlim(min(var), max(var))
ax0.set_ylim(-0.015, 0.015)

ax0.set_xlabel('Calculation ID')
ax0.set_title('8-15-15-1 framework')


(mu, sigma) = norm.fit(nE - E)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(nE-E, 50,
                            range = (-0.05, 0.05),
                            weights = np.ones_like(nE-E)/ len(nE),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.01, 0.04, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.01, 0.03, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.05, 0.05)
ax1.set_xlim(0, 0.20)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
ax1.set_title('Error Distribution')
plt.tight_layout(w_pad = -0.5)
plt.savefig('./figures/surf-error-distribution-5.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/surf-error-distribution-5.png]]

* Application
** MD
*** Trajectory
**** perfect
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db5/perfect')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(2, 2, 5), a=3.939, vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(Amp(load="./../../../networks/db5/20-20/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(4000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1460496.gilgamesh.cheme.cmu.edu

**** vacancy
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db5/vacancy')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(2, 2, 5), a=3.939, vacuum=6.0)
del atoms[-1]
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(Amp(load="./../../../networks/db5/20-20/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db5/vacancy-33')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(3, 3, 5), a=3.939, vacuum=6.0)
del atoms[-1]
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(Amp(load="./../../../networks/db5/20-20/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1460499.gilgamesh.cheme.cmu.edu

**** adatom
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db5/fcc')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111, add_adsorbate
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(2, 2, 5), a = 3.939, vacuum = 6.0)
add_adsorbate(atoms, "Pd", height=2.0, position="fcc")
constraint = FixAtoms(mask=[atom.tag >3  for atom in atoms])
atoms.set_constraint(constraint)

atoms.set_calculator(Amp(load="./../../../networks/db5/20-20/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(1000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1460501.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db5/hcp')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111, add_adsorbate
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(2, 2, 5), a = 3.939, vacuum = 6.0)
add_adsorbate(atoms, "Pd", height=2.0, position="hcp")
constraint = FixAtoms(mask=[atom.tag >3  for atom in atoms])
atoms.set_constraint(constraint)

atoms.set_calculator(Amp(load="./../../../networks/db5/20-20/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(1000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1461386.gilgamesh.cheme.cmu.edu
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db5/ontop')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111, add_adsorbate
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(2, 2, 5), a = 3.939, vacuum = 6.0)
add_adsorbate(atoms, "Pd", height=2.0, position="ontop")
constraint = FixAtoms(mask=[atom.tag >3  for atom in atoms])
atoms.set_constraint(constraint)

atoms.set_calculator(Amp(load="./../../../networks/db5/20-20/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(1000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=48:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1461469.gilgamesh.cheme.cmu.edu

*** NN Prediction
**** perfect
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp

calc1 = Amp(load = './networks/db4/10-10/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db4/15-15/checkpoint-parameters.json')
traj = Trajectory('./database/db4/MD-fixed.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/MD225-5.png')
#+END_SRC

#+RESULTS:

[[./figures/MD225-5.png]]

**** vacancy
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp

calc1 = Amp(load = './networks/db5/18-18/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db5/20-20/checkpoint-parameters.json')
traj = Trajectory('./database/db5/vacancy/MD.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
#plt.show()
plt.savefig('./figures/MD-vac-6.png')
#+END_SRC

#+RESULTS:

[[./figures/MD-vac-6.png]]

** Elastic
#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.01, 11)

Ed1, En1, Vd1, Vn1 = [], [], [], []
Ed4, En4, Vd4, Vn4 = [], [], [], []

# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=11/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed1.append(atoms.get_potential_energy())
    Vd1.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')

    atoms.set_calculator(calc2)
    En1.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c


poptd, pcovd = curve_fit(func, factor, Ed1/Vd1[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En1/Vd1[0])
print poptn

plt.subplot(1, 2, 1)
plt.plot(factor, Ed1/Vd1[0], 'bo', label = 'DFT')
plt.plot(factor, En1/Vd1[0], 'ro', label = 'NN')
plt.plot(factor, func(factor, *poptd), 'b-', label = 'DFT fit')
plt.plot(factor, func(factor, *poptn), 'r-', label = 'NN fit')
plt.xlabel('Strain')
plt.ylabel('Energy Density [eV/$\AA^3$]')
plt.legend(loc='best')
plt.title('Strain 1')

for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=44/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed4.append(atoms.get_potential_energy())
    Vd4.append(atoms.get_volume()/len(atoms))

    calc2 = Amp(load = './networks/db5/20-20/checkpoint-parameters.json')

    atoms.set_calculator(calc2)
    En4.append(atoms.get_potential_energy())

poptd, pcovd = curve_fit(func, factor, Ed4/Vd4[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En4/Vd4[0])
print poptn

#plt.savefig('./figures/elastic-1.png')
plt.subplot(1, 2, 2)
plt.plot(factor, Ed4/Vd4[0], 'bo', label = 'DFT')
plt.plot(factor, En4/Vd4[0], 'ro', label = 'NN')
plt.plot(factor, func(factor, *poptd), 'b-', label = 'DFT fit')
plt.plot(factor, func(factor, *poptn), 'r-', label = 'NN fit')
plt.xlabel('Strain')
plt.ylabel('Energy Density [eV/$\AA^3$]')
plt.legend(loc='best')
plt.title('Strain 2')

plt.tight_layout()
plt.savefig('./figures/els-cons-5.png')
#+END_SRC

#+RESULTS:
: [ 2.22936683 -0.34128023]
: [ 2.87528197 -0.34126408]
: [ 0.73280411 -0.34127966]
: [ 0.86558393 -0.34136471]

[[./figures/els-cons-5.png]]

**** calculation
#+BEGIN_SRC python
'''
B = 1.09507457295
a = 2.21553499/6
b = 0.66616554
'''

B = 1.0950
a = 2.875/6
b = 0.866
C4 = b/2
C2 = (3*B - 2*a)/3
C1 = 2*a + C2

print C1, C2, C4
print C1 * 160.2177
print C2 * 160.2177
print C4 * 160.2177
#+END_SRC

#+RESULTS:
: 1.73388888889 0.775555555556 0.433
: 277.799689833
: 124.257727333
: 69.3742641

#+BEGIN_SRC python
from ase.db import connect

db = connect('database/db5/data.db')
for i, d in enumerate(db.select('type=elastic')):
        for key in d:
            print ('{0:25}:{1}'.format(key, d[key]))
#+END_SRC

** NEB-NN
#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d

#calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
#images, energies = calc.get_neb()
En, E = [], []
calc2 = Amp(load = './networks/db6/20-20/checkpoint-parameters.json')
for i in range (9):
    calc = Vasp('./NDFT/bulk=fcc/type=neb/supercell=222/image={0}'.format(i))
    E += [calc.potential_energy]
    atoms = calc.get_atoms()
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]
E = np.array(E)
En = np.array(En)
E = E/8
En = En/8

#E = E- E[0]
#En = En-En[0]
x = range(len(E))
xarray = np.linspace(0, len(E))
f1 = interp1d(x, E, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(x, E, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
plt.show()
#plt.savefig('figures/NEB-NN-6.png')
#+END_SRC

#+RESULTS:

[[./figures/NEB-NN-6.png]]

#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import spline

#calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
#images, energies = calc.get_neb()
En, E = [], []
calc2 = Amp(load = './networks/db7/18-18/checkpoint-parameters.json')
for i in range (9):
    calc = Vasp('./NDFT/bulk=fcc/type=neb/supercell=222/image={0}'.format(i))
    E += [calc.potential_energy]
    atoms = calc.get_atoms()
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]
E = np.array(E)
En = np.array(En)
E = E/8
En = En/8

E = E- E[0]
En = En-En[0]
x = range(len(E))
xarray = np.linspace(0, len(E)-1)

S1 = spline(x, E, xarray)
S2 = spline(x, En, xarray)
plt.plot(x, E, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, S1, 'b-')
plt.plot(xarray, S2, 'r-')
plt.xlim([0, 8])
#plt.ylim([-4.5, -4])
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
plt.show()
#+END_SRC


#+BEGIN_SRC python
from vasp import Vasp
import numpy as np
from amp import Amp
import numpy as np
calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
images, energies = calc.get_neb()

calc0 = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb-initial')
E0 = calc0.potential_energy

energies = np.array(energies)
energies += E0

print energies


En, E = [], []
calc2 = Amp(load = './networks/db5/24-24/checkpoint-parameters.json')

for atoms in images:
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

print En
En= np.array(En)
print (energies-energies[0])
print (En-En[0])
#+END_SRC

#+RESULTS:
: [-35.43371164 -35.42570645 -35.19608912 -34.88827938 -34.75807484
:  -34.88827927 -35.19608898 -35.42570641 -35.43371169]
: [-35.34002531245651, -35.33561098673327, -35.17596221409323, -34.849877392239904, -34.67648061835955, -34.8498772503447, -35.17596207866689, -35.33561095532693, -35.34002531245646]
: [  0.00000000e+00   8.00519000e-03   2.37622520e-01   5.45432260e-01
:    6.75636800e-01   5.45432370e-01   2.37622660e-01   8.00523000e-03
:   -5.00000041e-08]
: [  0.00000000e+00   4.41432572e-03   1.64063098e-01   4.90147920e-01
:    6.63544694e-01   4.90148062e-01   1.64063234e-01   4.41435713e-03
:    4.97379915e-14]


* 7th DFT
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 2
images = Trajectory('./database/db5/vacancy/MD.traj', 'r')

for i in range(100):
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md3/v_a=1_19/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 2
images = Trajectory('./database/db5/vacancy-23/MD.traj', 'r')

for i in range(50):
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md3/v_a=1_29/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 5, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

#VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 2
images = Trajectory('./database/db5/vacancy-33/MD.traj', 'r')

for i in range(20):
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md3/v_a=1_44/MD={}'.format(i),
                xc='pbe',
                kpts=[5, 5, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 2
images = Trajectory('./database/db5/fcc/MD.traj', 'r')

for i in range(50):
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md3/adatom=fcc/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 2
images = Trajectory('./database/db5/hcp/MD.traj', 'r')

for i in range(50):
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md3/adatom=hcp/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from vasp import Vasp
from vasp.vasprc import VASPRC



calc1 = Amp(load = './networks/db5/20-20/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db5/24-24/checkpoint-parameters.json')
images = Trajectory('./database/db5/hcp/MD.traj', 'r')
E1, E2 = [], []

for atoms in images:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in images:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)


nrg, res, s = [], [], []
calcs = []
A = range(50)
for i in A:        
        
        calc = Vasp('NDFT/surface=fcc111/type=md/order=md3/adatom=hcp/MD={}'.format(i))

        nrg += [calc.potential_energy/20]


plt.plot(range(len(E1)), E1, 'b-', label='NN1 prediction')
plt.plot(range(len(E2)), E2, 'r--', label='NN2 prediction')
plt.scatter(A, nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(E1)))
plt.ylabel('Potential energy (eV)')

plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
#plt.savefig('./figures/sur-vac-5.png')
plt.show()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from vasp import Vasp
from vasp.vasprc import VASPRC



calc1 = Amp(load = './networks/db5/20-20/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db5/24-24/checkpoint-parameters.json')
images = Trajectory('./database/db5/vacancy/MD.traj', 'r')
E1, E2 = [], []

for atoms in images:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in images:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)


nrg, res, s = [], [], []
calcs = []
A = range(100)
for i in A:        
        
        calc = Vasp('NDFT/surface=fcc111/type=md/order=md3/v_a=1_19/MD={}'.format(i))

        nrg += [calc.potential_energy/19]


plt.plot(range(len(E1)), E1, 'b-', label='NN1 prediction')
plt.plot(range(len(E2)), E2, 'r--', label='NN2 prediction')
plt.scatter(A, nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(E1)))
plt.ylabel('Potential energy (eV)')

plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/sur-vac-5.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/sur-vac-5.png]]

* DB

#+BEGIN_SRC python
from vasp import Vasp
A = range (100)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md3/v_a=1_19/MD={}'.format(i))
    calc.write_db('./database/db6/data.db', parser='=', overwrite=False, keys={'dbkey':6, 'structure':'surface'})  
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
A = range (50)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md3/v_a=1_29/MD={}'.format(i))
    calc.write_db('./database/db6/data.db', parser='=', overwrite=False, keys={'dbkey':6, 'structure':'surface'})  
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
A = range (20)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md3/v_a=1_44/MD={}'.format(i))
    calc.write_db('./database/db6/data.db', parser='=', overwrite=False, keys={'dbkey':6, 'structure':'surface'})  
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
A = range (50)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md3/adatom=fcc/MD={}'.format(i))
    calc.write_db('./database/db6/data.db', parser='=', overwrite=False, keys={'dbkey':6, 'structure':'surface'})  
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
A = range (50)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md3/adatom=hcp/MD={}'.format(i))
    calc.write_db('./database/db6/data.db', parser='=', overwrite=False, keys={'dbkey':6, 'structure':'surface'})  
#+END_SRC

#+RESULTS:

* Training
** Training Set
#+BEGIN_SRC python
from ase.db import connect
import os
import random
import numpy as np

db = connect('./database/db6/data.db')

n = db.count()
n_train = int(round(n * 0.9))

n_ids =  np.array(range(n)) + 1

# This will sudo-randomly select 10% of the calculations
# Which is useful for reproducing our results.
random.seed(256)
train_samples = random.sample(n_ids, n_train)
valid_samples = set(n_ids) - set(train_samples)

db.update(list(train_samples), train_set=True)
db.update(list(valid_samples), train_set=False)

#+END_SRC

#+RESULTS:

** Training

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

for n in [15, 18, 20, 24, 25, 10, 12]:

    wd = 'networks/db6/{0}-{0}/'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)
    os.chdir(wd)

    run_amp = """#!/usr/bin/env python
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing

db = connect('../../../database/db6/data.db')

images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=8,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
""".format(n)

    cmd = '''#!/bin/bash
#PBS -N {}
#PBS -l nodes=1:ppn=8
#PBS -l walltime=168:00:00
#PBS -l mem=16GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

    with open('submit.py', 'w') as f:
        f.write(run_amp)
    os.chmod('submit.py', 0777)

    with open('submit.sh', 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', 'submit.sh'])
    time.sleep(2)
    os.unlink('submit.sh')
    os.chdir(home)
#+END_SRC

#+RESULTS:
: 1461548.gilgamesh.cheme.cmu.edu
: 1461549.gilgamesh.cheme.cmu.edu
: 1461550.gilgamesh.cheme.cmu.edu
: 1461551.gilgamesh.cheme.cmu.edu
: 1461552.gilgamesh.cheme.cmu.edu
: 1461553.gilgamesh.cheme.cmu.edu
: 1461554.gilgamesh.cheme.cmu.edu

load
load=os.path.join(wd, 'checkoutpoint-parameters-0.json'),
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

for n in [18]:

    wd = 'networks/db5/{0}-{0}/'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)
    os.chdir(wd)

    run_amp = """#!/usr/bin/env python
import os
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing

db = connect('../../../database/db5/data.db')
wd = os.getcwd()
images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(load='checkpoint-parameters.json',
           label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=4,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
""".format(n)

    cmd = '''#!/bin/bash
#PBS -N {}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=168:00:00
#PBS -l mem=16GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

    with open('submit.py', 'w') as f:
        f.write(run_amp)
    os.chmod('submit.py', 0777)

    with open('submit.sh', 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', 'submit.sh'])
    time.sleep(2)
    os.unlink('submit.sh')
    os.chdir(home)
#+END_SRC

#+RESULTS:
: 1461120.gilgamesh.cheme.cmu.edu


#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing
import os

home = os.getcwd()
wd = 'networks/db3/10-10/'
os.chdir(wd)

db = connect('../../../database/db3/data.db')
wd = os.getcwd()
images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(load='parameters.json',
           label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=4,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
#+END_SRC

** Update

#+BEGIN_SRC python
from ase.db import connect
from amp import Amp

db = connect('./database/db6/data.db')
calc1 = Amp(load = './networks/db6/18-18/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db6/24-24/checkpoint-parameters.json')

for d in db.select():
    atoms = db.get_atoms(d.id)d
    atoms.set_calculator(calc1)
    nrg1 = atoms.get_potential_energy()

    atoms.set_calculator(calc2)
    nrg2 = atoms.get_potential_energy()
    db.update(d.id, NN18 = nrg1, NN24 = nrg2)
#+END_SRC

#+RESULTS:

** Residual
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from ase.db import connect
from amp import Amp
import os

db = connect('database/db6/data.db')

fig, ax = plt.subplots(1, 2, sharey=True, figsize=(8, 4))

for i, n in enumerate([18, 24]):

    E, nnE, var, ind = [], [], [], []
    for j, d in enumerate(db.select('')):# dbkey=0
	E += [d.energy / d.natoms]
	nnE += [d['NN{}'.format(n)]/ d.natoms]
	var += [j]
	ind += [d.train_set]

    res = np.array(nnE) - np.array(E)
    mask = np.array(ind)
    valid = np.ma.masked_array(res, mask)
    train = np.ma.masked_array(res, ~mask)
    vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
    tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))

    ax[i].text(200, -0.050,
               'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
               color='b', ha='left')
    ax[i].text(200, -0.057,
               'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
               color='r', ha='left')

    ax[i].scatter(var, train, color='b')
    ax[i].scatter(var, valid, color='r')
    ax[i].plot([min(var), max(var)], [0, 0], 'k--')
    ax[i].set_xlim(min(var), max(var))

    ax[i].set_xlabel('Calculation ID')
    ax[i].set_title('8-{0}-{0}-1 framework'.format(n))

ax[0].set_ylim(-0.060, 0.060)
ax[0].set_ylabel('Residual error (eV/atom)')
plt.tight_layout()
plt.savefig('./figures/residual-6.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/residual-6.png]]

Large error configurations
#+BEGIN_SRC python
import numpy as np
from ase.db import connect
ids = []
db = connect('database/db6/data.db')
for i, d in enumerate(db.select('')):
    E = d.energy / d.natoms
    nE = d.NN18/ d.natoms
    if abs(E - nE) > 0.03:
        ids += [i]

print ids
#+END_SRC

#+RESULTS:
: [229, 234, 235, 240, 296, 297, 298, 336, 341, 351, 352, 770]

#+BEGIN_SRC python
from ase.db import connect

db = connect('database/db6/data.db')
for i, d in enumerate(db.select('structure=surface', 'type=vacancy', 'supercell=22')):
        for key in d:
            print ('{0:25}:{1}'.format(key, d[key]))
#+END_SRC

#+RESULTS:

*** Bulk Residual
#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db6/data.db')

S, Qe, Ne = [], [], []

for d in db.select(['type=eos']):
    S += [d.bulk]
    Qe += [d.energy/d.natoms]
    Ne += [d.NN18/d.natoms]
    
S = np.array(S)
Qe = np.array(Qe)
Ne = np.array(Ne)

cmap, hdl = {}, []

#print Ne
for s, c in zip(set(S), ['b', 'r', 'g', 'c', 'm']):
    cmap[s] = c
    hdl +=[mpatches.Patch(color = c, label = s)]

c = []
for s in S:
    c +=[cmap[s]]

RMSE = np.sqrt(sum((Ne-Qe)** 2) / len(Ne - Qe))

(mu, sigma) = norm.fit(Ne- Qe)

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
ax0.plot([min(Qe), 0], [0,0], 'k--', lw =2)
ax0.scatter(Qe, Ne-Qe, marker = 'o', color = c)
ax0.text(min(Qe) + 0.1, 0.14,
         'RMSE: {0:1.3f}'.format(RMSE),
         fontsize = 12, va = 'top', ha = 'left')
ax0.set_xlim(min(Qe), 0)
ax0.set_ylim(-0.05, 0.05)
ax0.set_xlabel('DFT potential energy (eV/atom)')
ax0.set_ylabel('Rsidual error (eV/atom)')
ax0.legend(loc = 'best', handles =hdl, fontsize = 8, frameon = False)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(Ne-Qe, 50,
                            range = (-0.05, 0.05),
                            weights = np.ones_like(Ne-Qe)/ len(Ne),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.05, 0.142, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.05, 0.122, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.05, 0.05)
ax1.set_xlim(0, 0.3)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
plt.tight_layout(w_pad = -0.5)

plt.savefig('./figures/eos-residual-6.png')
#plt.show()

#+END_SRC

#+RESULTS:

eos-residual

[[./figures/eos-residual-6.png]]


#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db6/data.db')

S, Qe, Ne = [], [], []

for d in db.select([]):
    S += [d.structure]
    Qe += [d.energy/d.natoms]
    Ne += [d.NN18/d.natoms]
    
S = np.array(S)
Qe = np.array(Qe)
Ne = np.array(Ne)

cmap, hdl = {}, []

#print Ne
for s, c in zip(set(S), ['b', 'r']):
    cmap[s] = c
    hdl +=[mpatches.Patch(color = c, label = s)]

c = []
for s in S:
    c +=[cmap[s]]

RMSE = np.sqrt(sum((Ne-Qe)** 2) / len(Ne - Qe))

(mu, sigma) = norm.fit(Ne- Qe)

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
ax0.plot([min(Qe), 0], [0,0], 'k--', lw =2)
ax0.scatter(Qe, Ne-Qe, marker = 'o', color = c)
ax0.text(min(Qe) + 0.1, 0.14,
         'RMSE: {0:1.3f}'.format(RMSE),
         fontsize = 12, va = 'top', ha = 'left')
ax0.set_xlim(min(Qe), 0)
ax0.set_ylim(-0.05, 0.05)
ax0.set_xlabel('DFT potential energy (eV/atom)')
ax0.set_ylabel('Rsidual error (eV/atom)')
ax0.legend(loc = 'best', handles =hdl, fontsize = 8, frameon = False)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(Ne-Qe, 50,
                            range = (-0.05, 0.05),
                            weights = np.ones_like(Ne-Qe)/ len(Ne),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.05, 0.142, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.05, 0.122, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.05, 0.05)
ax1.set_xlim(0, 0.3)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
plt.tight_layout(w_pad = -0.5)

#plt.savefig('./figures/eos-residual-6.png')
plt.show()

#+END_SRC

#+RESULTS:

*** surface residual
#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db6/data.db')

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
E, nE, var, ind = [], [], [], []
#for j, d in enumerate(db.select(['order=md2','structure=surface'])):# dbkey=0
#for j, d in enumerate(db.select(['v_a=0_20'])):# dbkey=0
#for j, d in enumerate(db.select(['type=vacancy', 'structure=surface'])):# dbkey=0
for j, d in enumerate(db.select(['structure=surface', 'type=vacancy', 'supercell=22'])):
    E += [d.energy / d.natoms]
    nE += [d.NN18/ d.natoms]
    var += [j]
    ind += [d.train_set]

E = np.array(E)
nE = np.array(nE)
res = np.array(nE) - np.array(E)
mask = np.array(ind)
valid = np.ma.masked_array(res, mask)
train = np.ma.masked_array(res, ~mask)
vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))

ax0.text(380, -0.048,
           'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
           color='b', ha='left')
ax0.text(270, -0.055,
           'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
           color='r', ha='left')

ax0.scatter(var, train, color='b')
ax0.scatter(var, valid, color='r')
ax0.plot([min(var), max(var)], [0, 0], 'k--')
ax0.set_xlim(min(var), max(var))
ax0.set_ylim(-0.015, 0.015)

ax0.set_xlabel('Calculation ID')
ax0.set_title('8-15-15-1 framework')


(mu, sigma) = norm.fit(nE - E)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(nE-E, 50,
                            range = (-0.05, 0.05),
                            weights = np.ones_like(nE-E)/ len(nE),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.01, 0.04, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.01, 0.03, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.05, 0.05)
ax1.set_xlim(0, 0.20)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
ax1.set_title('Error Distribution')
plt.tight_layout(w_pad = -0.5)
#plt.savefig('./figures/surf-error-distribution-6.png')
plt.show()
#+END_SRC

#+RESULTS:

[[./figures/surf-error-distribution-6.png]]

#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

from ase.db import connect

db = connect('./database/db6/data.db')
data = db.select(['structure=surface', 'type=vacancy', 'supercell=22'])
for i in data:
    print i.energy, (i.energy-i.NN18)

'''
keys, cnt = {}, 0
for entry in data:
    cnt += 1
    for k, v in entry.key_value_pairs.iteritems():
        
        if k in keys:
            keys[k] += [v]
        else:
            keys[k] = [v]

print ('{0:15s} {1:15s} {2} calculations total'.format('keyword', 'value',cnt))

print('------------------------------------------------------')

for k, v in keys.iteritems():
    vals = list(set(v))
    if len(vals) <= 5:
        val = ", ".join(str(e) for e in vals)
        print('{0:15}: {1}'.format(k, val))

    else:
        val = ", ".join(str(e)[:5] for e in vals[:5])
        print('{0:15s}:{1}, etc...'.format(k, val))
'''
#+END_SRC
#+RESULTS:
#+begin_example
-93.70842946 -0.00365614977676
-93.74332304 -0.00503410764865
-93.75861948 -0.0066648115842
-93.76473653 -0.00896813813645
-93.76797866 -0.0136691968526
-93.77003598 -0.0128265905814
-93.7703986 -0.0121485940649
-93.77205094 -0.0120452096251
-93.77319588 -0.0120497897817
-93.77419085 -0.0125990848719
-93.77457472 -0.0133356778424
-93.77487465 -0.0143918145677
-93.77503405 -0.0156345666371
#+end_example

* Application
** MD
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db6/perfect')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(2, 2, 5), a=3.939, vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(Amp(load="./../../../networks/db6/20-20/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(4000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1462284.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db6/vacancy')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(2, 2, 5), a=3.939, vacuum=6.0)
del atoms[-1]
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(Amp(load="./../../../networks/db6/20-20/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1462285.gilgamesh.cheme.cmu.edu


#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db6/hcp')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111, add_adsorbate
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(2, 2, 5), a = 3.939, vacuum = 6.0)
add_adsorbate(atoms, "Pd", height=2.0, position="hcp")
constraint = FixAtoms(mask=[atom.tag >3  for atom in atoms])
atoms.set_constraint(constraint)

atoms.set_calculator(Amp(load="./../../../networks/db6/20-20/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(2000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1462283.gilgamesh.cheme.cmu.edu


#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db6/ontop')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111, add_adsorbate
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(2, 2, 5), a = 3.939, vacuum = 6.0)
add_adsorbate(atoms, "Pd", height=2.0, position="ontop")
constraint = FixAtoms(mask=[atom.tag >3  for atom in atoms])
atoms.set_constraint(constraint)

atoms.set_calculator(Amp(load="./../../../networks/db6/20-20/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(1000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1461822.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db6/bridge')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from ase.lattice.surface import fcc111, add_adsorbate
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms

atoms = fcc111("Pd", size=(2, 2, 5), a = 3.939, vacuum = 6.0)
add_adsorbate(atoms, "Pd", height=2.0, position="bridge")
constraint = FixAtoms(mask=[atom.tag >3  for atom in atoms])
atoms.set_constraint(constraint)

atoms.set_calculator(Amp(load="./../../../networks/db6/20-20/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(1000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1462357.gilgamesh.cheme.cmu.edu

**** perfect
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp

calc1 = Amp(load = './networks/db6/20-20/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db6/24-24/checkpoint-parameters.json')
traj = Trajectory('./database/db6/vacancy/MD.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
plt.show()
#plt.savefig('./figures/MD225-5.png')
#+END_SRC

#+RESULTS:

** NN predict

#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d
energies = []
En, E = [], []
calc2 = Amp(load = './networks/db8/24-24/checkpoint-parameters.json')
#calc = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/neb')
#images, energies = calc.get_neb()
for i in range(9):
    calc = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/image={}'.format(i))
    energies += [calc.potential_energy/19]
    atoms = calc.get_atoms()

    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()/19]

En = np.array(En)
E = En
#E = En-En[0]
x = range(len(En))
xarray = np.linspace(0, len(En))
f1 = interp1d(x, energies, kind='cubic', bounds_error=False)
f2 = interp1d(x, E, kind='cubic', bounds_error=False)
plt.plot(x, energies, 'bo', label = 'NEB')
plt.plot(x, E, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
#plt.show()
plt.savefig('./figures/sur-vac-NEB-7.png')
#+END_SRC

#+RESULTS:

[[./figures/sur-vac-NEB-7.png]]


#+BEGIN_SRC python
from ase.db import connect

db = connect('database/db7/data.db')
for i, d in enumerate(db.select('id=2552')):
        for key in d:
            print ('{0:25}:{1}'.format(key, d[key]))
#+END_SRC

#+RESULTS:
#+begin_example
forces                   :[[  0.00000000e+00   0.00000000e+00   0.00000000e+00]
 [  0.00000000e+00   0.00000000e+00   0.00000000e+00]
 [  0.00000000e+00   0.00000000e+00   0.00000000e+00]
 [  0.00000000e+00   0.00000000e+00   0.00000000e+00]
 [  0.00000000e+00   0.00000000e+00   0.00000000e+00]
 [  0.00000000e+00   0.00000000e+00   0.00000000e+00]
 [  0.00000000e+00   0.00000000e+00   0.00000000e+00]
 [  0.00000000e+00   0.00000000e+00   0.00000000e+00]
 [  1.93860000e-04   6.97884000e-03   5.05930000e-04]
 [ -1.71020000e-04   6.99914000e-03   3.71420000e-04]
 [  8.12000000e-05   7.99027000e-03  -3.04686000e-03]
 [ -2.69000000e-05   7.12895000e-03  -2.74507000e-03]
 [ -8.03500000e-05   1.71389500e-02  -1.34085000e-03]
 [  2.06600000e-05   1.86801500e-02  -6.33837000e-03]
 [  2.55725000e-03   1.56543800e-02  -3.37928000e-03]
 [ -2.48246000e-03   1.56498300e-02  -3.25731000e-03]
 [ -1.88700000e-05   2.81582800e-02  -3.39463000e-03]
 [ -7.37200000e-05   2.61114100e-02  -1.12407000e-03]
 [  6.33600000e-05   3.01388700e-02  -2.41149000e-03]]
magmoms                  :[ 0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.  0.
  0.]
tags                     :[0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0]
image                    :4
dbkey                    :7
surface                  :fcc111
calculator_parameters    :"{\"xc\": \"pbe\", \"kpts\": [9, 9, 1], \"encut\": 350, \"nsw\": 0}"
mtime                    :16.7000196216
id                       :2552
class                    :vacancy
structure                :surface
magmom                   :0.0
stress                   :[  2.09510593e-02   1.63580150e-02   2.72858853e-03  -1.56784646e-03
  -4.48577062e-08  -1.68669220e-06]
ctime                    :16.7000138001
train_set                :True
charges                  :[  2.37170888e-310   2.37170888e-310   2.37170888e-310   2.37170888e-310
   2.37170888e-310   2.37170888e-310   2.37170888e-310   2.37170888e-310
   2.37170888e-310   2.37170888e-310   2.37170888e-310   2.37170888e-310
   2.37170888e-310   2.37170888e-310   2.37170888e-310   2.37170888e-310
   2.37170888e-310   2.37170888e-310   2.37170888e-310]
positions                :[[  5.57058719e+00   1.60809000e+00   5.99999991e+00]
 [  2.78529358e+00   1.60809000e+00   5.99999991e+00]
 [  6.96323400e+00   4.02022503e+00   5.99999991e+00]
 [  4.17794039e+00   4.02022503e+00   5.99999991e+00]
 [  0.00000000e+00   0.00000000e+00   8.27418277e+00]
 [  2.78529361e+00   0.00000000e+00   8.27418277e+00]
 [  1.39264681e+00   2.41213502e+00   8.27418277e+00]
 [  4.17794042e+00   2.41213502e+00   8.27418277e+00]
 [  1.38888432e+00   7.40893255e-01   1.05254902e+01]
 [  4.18170201e+00   7.40886115e-01   1.05255244e+01]
 [  2.78528645e+00   3.17286360e+00   1.05591591e+01]
 [  5.57059326e+00   3.17435778e+00   1.05669951e+01]
 [  5.57058783e+00   1.59997389e+00   1.27748226e+01]
 [  2.78528264e+00   1.50890142e+00   1.27271729e+01]
 [  6.98628060e+00   3.94393638e+00   1.28971366e+01]
 [  4.15488637e+00   3.94394343e+00   1.28970841e+01]
 [  5.57057803e+00   4.83128936e-01   1.50795759e+01]
 [  2.78527821e+00   1.26030678e-02   1.50236616e+01]
 [  2.78533904e+00   2.68426259e+00   1.50403316e+01]]
user                     :tianyug1
cell                     :[[  5.57058722   0.           0.        ]
 [  2.78529361   4.82427005   0.        ]
 [  0.           0.          21.09673084]]
energy                   :-93.265124
pbc                      :[ True  True  True]
type                     :neb
calculator               :vasp
unique_id                :7f7dcf0735f81f490b9b807559404fae
numbers                  :[46 46 46 46 46 46 46 46 46 46 46 46 46 46 46 46 46 46 46]
#+end_example

#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d
energies = []
En, E = [], []
calc2 = Amp(load = './networks/db7/24-24/checkpoint-parameters.json')
#calc = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/neb')
#images, energies = calc.get_neb()
for i in range(9):
    calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/class=top_fcc/image={}'.format(i))
    energies += [calc.potential_energy/21]
    atoms = calc.get_atoms()

    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()/21]

En = np.array(En)
energies = np.array(energies)
#E = En
#energies = energies - energies[0]
#E = En-En[0]

energies = energies 
E = En
print (energies-En)
x = range(len(En))
xarray = np.linspace(0, len(En))
f1 = interp1d(x, energies, kind='cubic', bounds_error=False)
f2 = interp1d(x, E, kind='cubic', bounds_error=False)
plt.plot(x, energies, 'bo', label = 'NEB')
plt.plot(x, E, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
plt.show()
#+END_SRC

#+RESULTS:
: [ 0.00518269  0.00487812  0.00413093  0.00224011 -0.0001605  -0.00235227
:  -0.00354311 -0.00366984 -0.00330256]

** Surface energy
*** 22
#+BEGIN_SRC python
from vasp import Vasp

calc1 = Vasp('NDFT/bulk=fcc/type=eos/factor=1.00')
Eb = calc1.potential_energy

calc2 = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00')
Es = calc2.potential_energy

#print Eb, Es
#print Es - Eb * 20
print Es
#+END_SRC

#+RESULTS:
: -99.84304382

#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
calc1 = Vasp('NDFT/bulk=fcc/type=eos/factor=1.00')
print calc1.potential_energy
atoms = calc1.get_atoms()

calc = Amp(load='./networks/db8/25-25/checkpoint-parameters.json')
atoms.set_calculator(calc)
nrg = atoms.get_potential_energy()
print nrg
#+END_SRC

#+RESULTS:
: -5.21446998
: -5.21500407235

#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc111
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc1 = Vasp('NDFT/bulk=fcc/type=eos/factor=1.00')
Eb = calc1.potential_energy

calc2 = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00')
Es = calc2.potential_energy

calc = Amp(load='./networks/db8/25-25/checkpoint-parameters.json')

atoms = fcc111('Pd', size=(2, 2, 5), a = 3.939,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrg = atoms.get_potential_energy()

Ed =  Es - Eb * 20
En =  nrg - (-5.21529201133) * 20

A = 2 * 2* 3.939 * 2 * 3.939

Ed = Ed /A
En = En /A

print Ed
print En
#+END_SRC

#+RESULTS:
: BFGS:   0  20:09:29      -99.782870       0.1898
: BFGS:   1  20:09:42      -99.784183       0.1747
: BFGS:   2  20:09:54      -99.785596       0.0798
: BFGS:   3  20:10:06      -99.785529       0.0669
: BFGS:   4  20:10:19      -99.784453       0.0164
: 0.035821375784
: 0.0364258514728

#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc111
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc = Amp(load='./networks/db8/25-25/checkpoint-parameters.json')

atoms = fcc111('Pd', size=(2, 2, 5), a = 3.939,  vacuum=6.0)
#print atoms[16].z- atoms[12].z

constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)
#view(atoms)
#print atoms[16].z - atoms[12].z

#calc2 = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00')
#atoms = calc2.get_atoms()

print atoms[17].z - atoms[13].z
print atoms[13].z - atoms[9].z
print atoms[9].z - atoms[5].z
print atoms[5].z - atoms[1].z
#+END_SRC

#+RESULTS:
: BFGS:   0  10:41:17      -99.762347       0.2258
: BFGS:   1  10:41:30      -99.762994       0.2041
: BFGS:   2  10:41:42      -99.762450       0.0627
: BFGS:   3  10:41:54      -99.762184       0.0574
: BFGS:   4  10:42:07      -99.761157       0.0337
: 2.26101834601
: 2.27877861726
: 2.28144857968
: 2.27418271034

#+BEGIN_SRC python
from vasp import Vasp

calc2 = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00')
atoms = calc2.get_atoms()
#view(atoms)
print atoms[17].z - atoms[13].z
print atoms[13].z - atoms[9].z
print atoms[9].z - atoms[5].z
print atoms[5].z - atoms[1].z

#+END_SRC

#+RESULTS:
: 2.28093001594
: 2.26970592223
: 2.27417399886
: 2.27418285948

#+BEGIN_SRC python
Ed = 4.44635578
En = 4.50494616251

A = 2 * 2* 3.939 * 2 * 3.939

Ed = Ed /A
En = En /A
print Ed
print En
#+END_SRC

#+RESULTS:
: 0.035821375784
: 0.0362934001142

#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc111
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc1 = Vasp('NDFT/bulk=fcc/type=eos/factor=1.00')
Eb = calc1.potential_energy

calc2 = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00')
Es = calc2.potential_energy

#calc = Amp(load='./networks/db8/25-25/checkpoint-parameters.json')
calc = Amp(load='./networks/db6/24-24/checkpoint-parameters.json')

atoms = fcc111('Pd', size=(2, 2, 5), a = 3.939,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)


nrg = atoms.get_potential_energy()


Ed =  Es - Eb * 20
En =  nrg - (-5.21529201133) * 20

A = 2 * 2* 3.939 * 2 * 3.939

Ed = Ed /A
En = En /A

print Ed
print En
#+END_SRC

#+RESULTS:
: BFGS:   0  11:12:55      -99.762347       0.2258
: BFGS:   1  11:13:07      -99.762994       0.2041
: BFGS:   2  11:13:20      -99.762450       0.0627
: BFGS:   3  11:13:32      -99.762184       0.0574
: BFGS:   4  11:13:44      -99.761157       0.0337
: 0.035821375784
: 0.0366135359903

*** 23
#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc111
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc1 = Vasp('NDFT/bulk=fcc/type=eos/factor=1.00')
Eb = calc1.potential_energy

calc2 = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=23/factor=1.00')
Es = calc2.potential_energy

#calc = Amp(load='./networks/db8/25-25/checkpoint-parameters.json')
calc = Amp(load='./networks/db6/24-24/checkpoint-parameters.json')

atoms = fcc111('Pd', size=(2, 3, 5), a = 3.939,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)


nrg = atoms.get_potential_energy()


Ed =  Es - Eb * 30
En =  nrg - (-5.21529201133) * 30

A = 2 * 2* 3.939 * 3 * 3.939

Ed = Ed /A
En = En /A

print Ed
print En
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  11:15:54     -149.643520       0.2850
BFGS:   1  11:16:19     -149.644535       0.2650
BFGS:   2  11:16:43     -149.633656       0.1412
BFGS:   3  11:17:08     -149.627621       0.1408
BFGS:   4  11:17:33     -149.617254       0.1322
BFGS:   5  11:17:57     -149.611222       0.1120
BFGS:   6  11:18:22     -149.611381       0.0959
BFGS:   7  11:18:47     -149.614518       0.0833
BFGS:   8  11:19:11     -149.618564       0.0940
BFGS:   9  11:19:36     -149.620653       0.0845
BFGS:  10  11:20:01     -149.619135       0.0639
BFGS:  11  11:20:25     -149.616034       0.0635
BFGS:  12  11:20:50     -149.613299       0.0623
BFGS:  13  11:21:15     -149.611461       0.0623
BFGS:  14  11:21:40     -149.611912       0.0589
BFGS:  15  11:22:05     -149.614139       0.0489
0.0359042044625
0.0367617520191
#+end_example

#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc111
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc1 = Vasp('NDFT/bulk=fcc/type=eos/factor=1.00')
Eb = calc1.potential_energy

calc2 = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=23/factor=1.00')
Es = calc2.potential_energy
atoms = calc2.get_atoms()

calc = Amp(load='./networks/db8/25-25/checkpoint-parameters.json')
#calc = Amp(load='./networks/db6/24-24/checkpoint-parameters.json')

atoms.set_calculator(calc)
nrg = atoms.get_potential_energy()

#print Es
#print nrg
#print (Es-nrg)/30


Ed =  Es - Eb * 30
En =  nrg - (-5.21529201133) * 30

A = 2 * 2* 3.939 * 3 * 3.939

Ed = Ed /A
En = En /A


print Ed
print En


#+END_SRC

#+RESULTS:
: 0.0359042044625
: 0.0366262407824

#+BEGIN_SRC python
Ed = 6.68495543
En = 6.79359467759

A = 2 * 2* 3.939 * 3 * 3.939

Ed = Ed /A
En = En /A
print Ed
print En
#+END_SRC

#+RESULTS:
: 0.0359042044625
: 0.0364876946292

*** 33
#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc111
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc1 = Vasp('NDFT/bulk=fcc/type=eos/factor=1.00')
Eb = calc1.potential_energy

calc2 = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=33/factor=1.00')
Es = calc2.potential_energy

#calc = Amp(load='./networks/db6/24-24/checkpoint-parameters.json')
calc = Amp(load='./networks/db8/25-25/checkpoint-parameters.json')
atoms = fcc111('Pd', size=(3, 3, 5), a = 3.939,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)


nrg = atoms.get_potential_energy()

Ed =  Es - Eb * 45
En =  nrg - (-5.21529201133) * 45

A = 2 * 3* 3.939 * 3 * 3.939

Ed = Ed /A
En = En /A

print Ed
print En
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  12:16:30     -224.465280       0.2282
BFGS:   1  12:17:20     -224.466759       0.2157
BFGS:   2  12:18:09     -224.445594       0.1360
BFGS:   3  12:18:58     -224.442770       0.1321
BFGS:   4  12:19:48     -224.417188       0.0956
BFGS:   5  12:20:37     -224.416332       0.0872
BFGS:   6  12:21:27     -224.416551       0.0822
BFGS:   7  12:22:16     -224.415961       0.0784
BFGS:   8  12:23:06     -224.413745       0.0711
BFGS:   9  12:23:55     -224.411380       0.0715
BFGS:  10  12:24:45     -224.408925       0.0683
BFGS:  11  12:25:34     -224.406315       0.0612
BFGS:  12  12:26:24     -224.404439       0.0604
BFGS:  13  12:27:14     -224.404181       0.0596
BFGS:  14  12:28:03     -224.404905       0.0603
BFGS:  15  12:28:53     -224.406078       0.0830
BFGS:  16  12:29:42     -224.407026       0.0920
BFGS:  17  12:30:32     -224.406491       0.0785
BFGS:  18  12:31:22     -224.404374       0.0752
BFGS:  19  12:32:12     -224.401948       0.0703
BFGS:  20  12:33:01     -224.399492       0.0705
BFGS:  21  12:33:51     -224.396745       0.0801
BFGS:  22  12:34:41     -224.394280       0.0694
BFGS:  23  12:35:31     -224.392837       0.0755
BFGS:  24  12:36:20     -224.392066       0.0685
BFGS:  25  12:37:10     -224.390927       0.0683
BFGS:  26  12:37:59     -224.388598       0.0667
BFGS:  27  12:38:49     -224.385366       0.0638
BFGS:  28  12:39:38     -224.382607       0.0727
BFGS:  29  12:40:28     -224.380736       0.0719
BFGS:  30  12:41:17     -224.379157       0.0605
BFGS:  31  12:42:06     -224.377512       0.0597
BFGS:  32  12:42:56     -224.376250       0.0390
0.035800487812
0.0369227315512
#+end_example


#+BEGIN_SRC python
Ed = 9.99846685
En = 10.2504830443

A = 2 * 3* 3.939 * 3 * 3.939

Ed = Ed /A
En = En /A
print Ed
print En
#+END_SRC

#+RESULTS:
: 0.035800487812
: 0.0367028564279

*** 34
#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc111
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc1 = Vasp('NDFT/bulk=fcc/type=eos/factor=1.00')
Eb = calc1.potential_energy

calc2 = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=34/factor=1.00')
Es = calc2.potential_energy

calc = Amp(load='./networks/db8/25-25/checkpoint-parameters.json')

atoms = fcc111('Pd', size=(3, 4, 5), a = 3.939,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)


nrg =jst atoms.get_potential_energy()

Ed =  Es - Eb * 60
En =  nrg - (-5.21529201133) * 60

A = 2 * 3* 3.939 * 4 * 3.939

Ed = Ed /A
En = En /A

print Ed
print En
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  13:26:32     -299.287040       0.2639
BFGS:   1  13:27:47     -299.288529       0.2248
BFGS:   2  13:29:02     -299.245092       0.1193
BFGS:   3  13:30:16     -299.238278       0.1155
BFGS:   4  13:31:31     -299.203770       0.0998
BFGS:   5  13:32:46     -299.201705       0.1055
BFGS:   6  13:34:01     -299.203389       0.1180
BFGS:   7  13:35:17     -299.203803       0.1312
BFGS:   8  13:36:31     -299.198393       0.1303
BFGS:   9  13:37:46     -299.187764       0.1417
BFGS:  10  13:39:00     -299.176429       0.1922
BFGS:  11  13:40:15     -299.166876       0.2174
BFGS:  12  13:41:30     -299.158530       0.1901
BFGS:  13  13:42:45     -299.152910       0.1325
BFGS:  14  13:44:00     -299.150498       0.1492
BFGS:  15  13:45:15     -299.149285       0.1939
BFGS:  16  13:46:30     -299.146377       0.1971
BFGS:  17  13:47:45     -299.139240       0.1632
BFGS:  18  13:49:00     -299.129233       0.1496
BFGS:  19  13:50:14     -299.120825       0.1229
BFGS:  20  13:51:29     -299.113643       0.1096
BFGS:  21  13:52:44     -299.104350       0.1162
BFGS:  22  13:53:58     -299.094138       0.1211
BFGS:  23  13:55:13     -299.087959       0.1004
BFGS:  24  13:56:28     -299.086046       0.0749
BFGS:  25  13:57:43     -299.084702       0.0717
BFGS:  26  13:58:57     -299.081778       0.0498
0.0359432886651
0.0371551709034
#+end_example

*** 44
#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc111
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc1 = Vasp('NDFT/bulk=fcc/type=eos/factor=1.00')
Eb = calc1.potential_energy

calc2 = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=44/factor=1.00')
Es = calc2.potential_energy

calc = Amp(load='./networks/db8/25-25/checkpoint-parameters.json')

atoms = fcc111('Pd', size=(4, 4, 5), a = 3.939,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)


nrg = atoms.get_potential_energy()

Ed =  Es - Eb * 80
En =  nrg - (-5.21529201133) * 80

A = 2 * 4* 3.939 * 4 * 3.939

Ed = Ed /A
En = En /A

print Ed
print En
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  14:29:15     -399.049387       0.2469
BFGS:   1  14:31:09     -399.051153       0.2101
BFGS:   2  14:33:01     -399.011744       0.1136
BFGS:   3  14:34:54     -399.006218       0.1135
BFGS:   4  14:36:47     -398.978763       0.0863
BFGS:   5  14:38:39     -398.978333       0.0696
BFGS:   6  14:40:33     -398.979894       0.0808
BFGS:   7  14:42:25     -398.979887       0.0884
BFGS:   8  14:44:18     -398.976518       0.0873
BFGS:   9  14:46:11     -398.971862       0.0858
BFGS:  10  14:48:04     -398.967481       0.1011
BFGS:  11  14:49:57     -398.963610       0.1079
BFGS:  12  14:51:50     -398.960402       0.0856
BFGS:  13  14:53:43     -398.958668       0.0733
BFGS:  14  14:55:36     -398.958129       0.0918
BFGS:  15  14:57:29     -398.957644       0.0978
BFGS:  16  14:59:22     -398.955919       0.0817
BFGS:  17  15:01:15     -398.952281       0.0692
BFGS:  18  15:03:08     -398.948003       0.0796
BFGS:  19  15:05:01     -398.944348       0.0827
BFGS:  20  15:06:54     -398.940644       0.0909
BFGS:  21  15:08:47     -398.936521       0.1038
BFGS:  22  15:10:40     -398.932959       0.1033
BFGS:  23  15:12:32     -398.930821       0.0813
BFGS:  24  15:14:25     -398.929183       0.0832
BFGS:  25  15:16:18     -398.926517       0.0698
BFGS:  26  15:18:11     -398.922435       0.0592
BFGS:  27  15:20:04     -398.918640       0.0577
BFGS:  28  15:21:57     -398.916478       0.0770
BFGS:  29  15:23:49     -398.915659       0.0726
BFGS:  30  15:25:42     -398.916071       0.0447
0.0360566448419
0.0368724595758
#+end_example

** Surface vacancy formation
#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc111
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc1 = Vasp('NDFT/atomic-Pd')
Eatomic = calc1.potential_energy

calc2 = Vasp('NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=22')
Ev = calc2.potential_energy

calc3 = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00')
Es = calc3.potential_energy

calc = Amp(load='./networks/db6/24-24/checkpoint-parameters.json')

atoms = fcc111('Pd', size=(2, 2, 5), a = 3.939,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgs = atoms.get_potential_energy()


atoms = fcc111('Pd', size=(2, 2, 5), a = 3.939,  vacuum=6.0)
del atoms[-1]
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgv = atoms.get_potential_energy()
print Ev, nrgv
print Es, nrgs
print Ev - Es + Eatomic
print nrgv - nrgs + Eatomic
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  23:44:48      -99.782870       0.1898
BFGS:   1  23:45:00      -99.784183       0.1747
BFGS:   2  23:45:13      -99.785596       0.0798
BFGS:   3  23:45:25      -99.785529       0.0669
BFGS:   4  23:45:37      -99.784453       0.0164
BFGS:   0  23:45:48      -93.724096       0.4218
BFGS:   1  23:45:59      -93.735150       0.3728
BFGS:   2  23:46:10      -93.767473       0.3636
BFGS:   3  23:46:21      -93.769595       0.3078
BFGS:   4  23:46:32      -93.773361       0.1043
BFGS:   5  23:46:43      -93.773968       0.0918
BFGS:   6  23:46:54      -93.776099       0.0572
BFGS:   7  23:47:05      -93.776524       0.0364
-93.77503405 -93.7765242642
-99.84304382 -99.7844534375
4.60830813
4.54822753333
#+end_example

*** 23
#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc111
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc1 = Vasp('NDFT/atomic-Pd')
Eatomic = calc1.potential_energy

calc2 = Vasp('NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=23')
Ev = calc2.potential_energy

calc3 = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=23/factor=1.00')
Es = calc3.potential_energy

calc = Amp(load='./networks/db6/24-24/checkpoint-parameters.json')

atoms = fcc111('Pd', size=(2, 3, 5), a = 3.939,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgs = atoms.get_potential_energy()


atoms = fcc111('Pd', size=(2, 3, 5), a = 3.939,  vacuum=6.0)
del atoms[-1]
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgv = atoms.get_potential_energy()
print Ev, nrgv
print Es, nrgs
print Ev - Es + Eatomic
print nrgv - nrgs + Eatomic
#+END_SRC


#+begin_example
BFGS:   0  23:51:29     -149.674305       0.3253
BFGS:   1  23:51:54     -149.675944       0.2984
BFGS:   2  23:52:19     -149.663610       0.1234
BFGS:   3  23:52:43     -149.660864       0.1171
BFGS:   4  23:53:08     -149.644694       0.0873
BFGS:   5  23:53:33     -149.643886       0.0760
BFGS:   6  23:53:57     -149.644355       0.0800
BFGS:   7  23:54:22     -149.644463       0.0802
BFGS:   8  23:54:47     -149.643303       0.0782
BFGS:   9  23:55:11     -149.641732       0.0613
BFGS:  10  23:55:36     -149.640505       0.0454
BFGS:   0  23:55:59     -143.617081       0.3784
BFGS:   1  23:56:21     -143.630257       0.3419
BFGS:   2  23:56:45     -143.671132       0.4374
BFGS:   3  23:57:08     -143.673682       0.4007
BFGS:   4  23:57:31     -143.672515       0.1314
BFGS:   5  23:57:54     -143.674486       0.1296
BFGS:   6  23:58:17     -143.674694       0.1201
BFGS:   7  23:58:39     -143.671907       0.1054
BFGS:   8  23:59:03     -143.668094       0.0802
BFGS:   9  23:59:26     -143.666416       0.0696
BFGS:  10  23:59:49     -143.666113       0.0622
BFGS:  11  00:00:12     -143.666614       0.0622
BFGS:  12  00:00:35     -143.666809       0.0473
-143.63339034 -143.666808658
-149.74914397 -149.640504722
4.65605199
4.51399442483
#+end_example

*** 33
#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc111
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc1 = Vasp('NDFT/atomic-Pd')
Eatomic = calc1.potential_energy

calc2 = Vasp('NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=33')
Ev = calc2.potential_energy

calc3 = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=33/factor=1.00')
Es = calc3.potential_energy

calc = Amp(load='./networks/db6/24-24/checkpoint-parameters.json')

atoms = fcc111('Pd', size=(3, 3, 5), a = 3.939,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgs = atoms.get_potential_energy()


atoms = fcc111('Pd', size=(3, 3, 5), a = 3.939,  vacuum=6.0)
del atoms[-1]
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgv = atoms.get_potential_energy()
print Ev, nrgv
print Es, nrgs
print Ev - Es + Eatomic
print nrgv - nrgs + Eatomic
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  09:52:47     -224.511458       0.2809
BFGS:   1  09:53:37     -224.514327       0.2438
BFGS:   2  09:54:26     -224.483552       0.1485
BFGS:   3  09:55:16     -224.484454       0.1327
BFGS:   4  09:56:05     -224.462810       0.1031
BFGS:   5  09:56:54     -224.459176       0.0981
BFGS:   6  09:57:43     -224.445770       0.0611
BFGS:   7  09:58:33     -224.446781       0.0598
BFGS:   8  09:59:22     -224.450910       0.0674
BFGS:   9  10:00:11     -224.453463       0.0687
BFGS:  10  10:01:01     -224.452810       0.0517
BFGS:  11  10:01:50     -224.447902       0.0531
BFGS:  12  10:02:39     -224.442261       0.0510
BFGS:  13  10:03:28     -224.437070       0.0544
BFGS:  14  10:04:18     -224.431265       0.0645
BFGS:  15  10:05:07     -224.427674       0.0780
BFGS:  16  10:05:56     -224.429411       0.0822
BFGS:  17  10:06:46     -224.435239       0.0793
BFGS:  18  10:07:36     -224.441558       0.0714
BFGS:  19  10:08:25     -224.446174       0.0892
BFGS:  20  10:09:14     -224.445332       0.0884
BFGS:  21  10:10:04     -224.436592       0.0711
BFGS:  22  10:10:54     -224.424859       0.0670
BFGS:  23  10:11:43     -224.415217       0.0722
BFGS:  24  10:12:32     -224.407886       0.0671
BFGS:  25  10:13:22     -224.405965       0.0692
BFGS:  26  10:14:11     -224.410317       0.0662
BFGS:  27  10:15:00     -224.416293       0.0741
BFGS:  28  10:15:50     -224.421027       0.0620
BFGS:  29  10:16:39     -224.422387       0.0507
BFGS:  30  10:17:28     -224.416931       0.0600
BFGS:  31  10:18:18     -224.407643       0.0512
BFGS:  32  10:19:08     -224.400666       0.0419
BFGS:   0  10:19:54     -218.414905       0.3556
BFGS:   1  10:20:41     -218.426467       0.3238
BFGS:   2  10:21:28     -218.435775       0.2213
BFGS:   3  10:22:15     -218.432273       0.2013
BFGS:   4  10:23:02     -218.417302       0.1870
BFGS:   5  10:23:49     -218.418243       0.1503
BFGS:   6  10:24:36     -218.419739       0.1493
BFGS:   7  10:25:23     -218.416832       0.1093
BFGS:   8  10:26:10     -218.409955       0.0840
BFGS:   9  10:26:57     -218.403377       0.1134
BFGS:  10  10:27:44     -218.393682       0.1206
BFGS:  11  10:28:31     -218.383819       0.0871
BFGS:  12  10:29:17     -218.377083       0.0717
BFGS:  13  10:30:04     -218.373961       0.0651
BFGS:  14  10:30:51     -218.371880       0.0882
BFGS:  15  10:31:38     -218.369282       0.0826
BFGS:  16  10:32:25     -218.365230       0.0845
BFGS:  17  10:33:12     -218.360143       0.0799
BFGS:  18  10:33:59     -218.354655       0.0980
BFGS:  19  10:34:46     -218.349257       0.0934
BFGS:  20  10:35:33     -218.344666       0.0729
BFGS:  21  10:36:19     -218.340634       0.0839
BFGS:  22  10:37:06     -218.336234       0.0839
BFGS:  23  10:37:53     -218.331330       0.0950
BFGS:  24  10:38:40     -218.326798       0.0948
BFGS:  25  10:39:26     -218.323525       0.1054
BFGS:  26  10:40:13     -218.321561       0.1296
BFGS:  27  10:41:00     -218.320423       0.1428
BFGS:  28  10:41:47     -218.319415       0.1248
BFGS:  29  10:42:34     -218.317977       0.0815
BFGS:  30  10:43:21     -218.316112       0.0772
BFGS:  31  10:44:08     -218.313980       0.0840
BFGS:  32  10:44:54     -218.311511       0.1009
BFGS:  33  10:45:41     -218.308731       0.0905
BFGS:  34  10:46:28     -218.306071       0.0624
BFGS:  35  10:47:15     -218.304254       0.0586
BFGS:  36  10:48:02     -218.303654       0.0863
BFGS:  37  10:48:49     -218.304332       0.1077
BFGS:  38  10:49:36     -218.306203       0.1060
BFGS:  39  10:50:23     -218.308735       0.0856
BFGS:  40  10:51:10     -218.310973       0.0734
BFGS:  41  10:51:57     -218.312247       0.0755
BFGS:  42  10:52:44     -218.312676       0.0698
BFGS:  43  10:53:31     -218.312711       0.0504
BFGS:  44  10:54:18     -218.312876       0.0384
-218.47332036 -218.312876478
-224.65268225 -224.400666056
4.71966025
4.62808793789
#+end_example

*** 34
#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc111
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc1 = Vasp('NDFT/atomic-Pd')
Eatomic = calc1.potential_energy

calc2 = Vasp('NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=34')
Ev = calc2.potential_energy

calc3 = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=34/factor=1.00')
Es = calc3.potential_energy

calc = Amp(load='./networks/db8/24-24/checkpoint-parameters.json')

atoms = fcc111('Pd', size=(3, 4, 5), a = 3.939,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgs = atoms.get_potential_energy()


atoms = fcc111('Pd', size=(3, 4, 5), a = 3.939,  vacuum=6.0)
del atoms[-1]
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgv = atoms.get_potential_energy()
print Ev, nrgv
print Es, nrgs
print Ev - Es + Eatomic
print nrgv - nrgs + Eatomic
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  14:30:40     -299.241975       0.3288
BFGS:   1  14:31:55     -299.242875       0.3078
BFGS:   2  14:33:10     -299.216164       0.1786
BFGS:   3  14:34:25     -299.138946       0.1907
BFGS:   4  14:35:40     -299.127588       0.2018
BFGS:   5  14:36:55     -299.084770       0.1838
BFGS:   6  14:38:10     -299.080597       0.1358
BFGS:   7  14:39:25     -299.093013       0.1420
BFGS:   8  14:40:40     -299.107736       0.1299
BFGS:   9  14:41:55     -299.113758       0.1366
BFGS:  10  14:43:09     -299.100845       0.1561
BFGS:  11  14:44:23     -299.076042       0.1386
BFGS:  12  14:45:38     -299.051745       0.1077
BFGS:  13  14:46:53     -299.032805       0.1138
BFGS:  14  14:48:07     -299.023183       0.1088
BFGS:  15  14:49:22     -299.027664       0.0986
BFGS:  16  14:50:36     -299.039149       0.1079
BFGS:  17  14:51:51     -299.048840       0.1189
BFGS:  18  14:53:06     -299.050759       0.1062
BFGS:  19  14:54:20     -299.038515       0.1163
BFGS:  20  14:55:35     -299.017312       0.1408
BFGS:  21  14:56:50     -298.995229       0.1606
BFGS:  22  14:58:04     -298.971594       0.1543
BFGS:  23  14:59:19     -298.951923       0.1476
BFGS:  24  15:00:34     -298.950082       0.1563
BFGS:  25  15:01:49     -298.968393       0.1820
BFGS:  26  15:03:03     -298.990829       0.1650
BFGS:  27  15:04:17     -299.007913       0.1548
BFGS:  28  15:05:32     -299.011946       0.1237
BFGS:  29  15:06:47     -298.992421       0.1490
BFGS:  30  15:08:01     -298.958781       0.1536
BFGS:  31  15:09:16     -298.925336       0.1613
BFGS:  32  15:10:30     -298.897597       0.1425
BFGS:  33  15:11:44     -298.879410       0.1121
BFGS:  34  15:12:59     -298.878474       0.1141
BFGS:  35  15:14:13     -298.889613       0.1099
BFGS:  36  15:15:28     -298.897746       0.1010
BFGS:  37  15:16:42     -298.897384       0.0925
BFGS:  38  15:17:55     -298.885668       0.1193
BFGS:  39  15:19:09     -298.870178       0.1094
BFGS:  40  15:20:23     -298.860197       0.0706
BFGS:  41  15:21:38     -298.858227       0.0554
BFGS:  42  15:22:52     -298.864578       0.0422
BFGS:   0  15:24:07     -293.205916       0.4960
BFGS:   1  15:25:19     -293.220482       0.4673
BFGS:   2  15:26:30     -293.263706       0.3145
BFGS:   3  15:27:42     -293.253796       0.3002
BFGS:   4  15:28:54     -293.228244       0.3391
BFGS:   5  15:30:06     -293.212939       0.3083
BFGS:   6  15:31:17     -293.193238       0.2311
BFGS:   7  15:32:29     -293.198755       0.1959
BFGS:   8  15:33:41     -293.218461       0.1911
BFGS:   9  15:34:52     -293.230433       0.1594
BFGS:  10  15:36:04     -293.234719       0.1377
BFGS:  11  15:37:16     -293.225291       0.1275
BFGS:  12  15:38:28     -293.212182       0.1355
BFGS:  13  15:39:40     -293.200799       0.1441
BFGS:  14  15:40:51     -293.189288       0.1331
BFGS:  15  15:42:03     -293.183720       0.1226
BFGS:  16  15:43:14     -293.186286       0.1422
BFGS:  17  15:44:26     -293.191615       0.1360
BFGS:  18  15:45:37     -293.194180       0.1009
BFGS:  19  15:46:49     -293.189238       0.0850
BFGS:  20  15:48:01     -293.176266       0.1100
BFGS:  21  15:49:13     -293.161807       0.1350
BFGS:  22  15:50:24     -293.145084       0.1395
BFGS:  23  15:51:36     -293.125596       0.1064
BFGS:  24  15:52:47     -293.110178       0.1204
BFGS:  25  15:53:59     -293.107504       0.1496
BFGS:  26  15:55:10     -293.117658       0.1615
BFGS:  27  15:56:22     -293.130454       0.1581
BFGS:  28  15:57:34     -293.136595       0.1331
BFGS:  29  15:58:45     -293.127824       0.1530
BFGS:  30  15:59:57     -293.105146       0.1464
BFGS:  31  16:01:09     -293.075598       0.1827
BFGS:  32  16:02:21     -293.040745       0.1900
BFGS:  33  16:03:32     -293.012947       0.1440
BFGS:  34  16:04:44     -293.007314       0.1394
BFGS:  35  16:05:56     -293.021230       0.1359
BFGS:  36  16:07:08     -293.036058       0.1236
BFGS:  37  16:08:19     -293.044119       0.1052
BFGS:  38  16:09:31     -293.037892       0.0898
BFGS:  39  16:10:43     -293.023352       0.0958
BFGS:  40  16:11:54     -293.010840       0.0787
BFGS:  41  16:13:06     -293.002651       0.0642
BFGS:  42  16:14:18     -293.003738       0.0481
-293.3402044 -293.003738014
-299.48373387 -298.864578414
4.68382783
4.4011387602
#+end_example


* 8th DFT
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 2
images = Trajectory('./database/db6/ontop/MD.traj', 'r')

for i in range(50):
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md4/adatom=ontop/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from vasp import Vasp
from vasp.vasprc import VASPRC



calc1 = Amp(load = './networks/db6/20-20/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db6/24-24/checkpoint-parameters.json')
images = Trajectory('./database/db6/ontop/MD.traj', 'r')
E1, E2 = [], []

for atoms in images:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in images:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)


nrg, res, s = [], [], []
calcs = []
A = range(50)
for i in A:        
        
        calc = Vasp('NDFT/surface=fcc111/type=md/order=md4/adatom=ontop/MD={}'.format(i))

        nrg += [calc.potential_energy/21]


plt.plot(range(len(E1)), E1, 'b-', label='NN1 prediction')
plt.plot(range(len(E2)), E2, 'r--', label='NN2 prediction')
plt.scatter(A, nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(E1)))
plt.ylabel('Potential energy (eV)')

plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/sur-ontop-6.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/sur-ontop-6.png]]

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 2
images = Trajectory('./database/db6/vacancy/MD.traj', 'r')

for i in range(20):
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md4/v_a=1_19/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from vasp import Vasp
from vasp.vasprc import VASPRC



calc1 = Amp(load = './networks/db6/20-20/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db6/24-24/checkpoint-parameters.json')
images = Trajectory('./database/db6/vacancy/MD.traj', 'r')
E1, E2 = [], []

for atoms in images:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in images:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)


nrg, res, s = [], [], []
calcs = []
A = range(20)
for i in A:        
        
        calc = Vasp('NDFT/surface=fcc111/type=md/order=md4/v_a=1_19/MD={}'.format(i))

        nrg += [calc.potential_energy/19]


plt.plot(range(len(E1)), E1, 'b-', label='NN1 prediction')
plt.plot(range(len(E2)), E2, 'r--', label='NN2 prediction')
plt.scatter(A, nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(E1)))
plt.ylabel('Potential energy (eV)')

plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/sur-vac-6.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/sur-vac-6.png]]

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 2
images = Trajectory('./database/db6/fcc/MD.traj', 'r')

for i in range(50):
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md4/adatom=fcc/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from vasp import Vasp
from vasp.vasprc import VASPRC



calc1 = Amp(load = './networks/db6/20-20/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db6/24-24/checkpoint-parameters.json')
images = Trajectory('./database/db6/fcc/MD.traj', 'r')
E1, E2 = [], []

for atoms in images:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in images:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)


nrg, res, s = [], [], []
calcs = []
A = range(50)
for i in A:        
        
        calc = Vasp('NDFT/surface=fcc111/type=md/order=md4/adatom=fcc/MD={}'.format(i))

        nrg += [calc.potential_energy/21]


plt.plot(range(len(E1)), E1, 'b-', label='NN1 prediction')
plt.plot(range(len(E2)), E2, 'r--', label='NN2 prediction')
plt.scatter(A, nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(E1)))
plt.ylabel('Potential energy (eV)')

plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/sur-fcc-6.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/sur-fcc-6.png]]


#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 2
images = Trajectory('./database/db6/hcp/MD.traj', 'r')

for i in range(20):
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md4/adatom=hcp/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 2
images = Trajectory('./database/db6/bridge/MD.traj', 'r')

for i in range(50):
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md4/adatom=bridge/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from vasp import Vasp
from vasp.vasprc import VASPRC



calc1 = Amp(load = './networks/db6/20-20/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db6/24-24/checkpoint-parameters.json')
images = Trajectory('./database/db6/bridge/MD.traj', 'r')
E1, E2 = [], []

for atoms in images:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in images:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)


nrg, res, s = [], [], []
calcs = []
A = range(50)
for i in A:        
        
        calc = Vasp('NDFT/surface=fcc111/type=md/order=md4/adatom=bridge/MD={}'.format(i))

        nrg += [calc.potential_energy/21]


plt.plot(range(len(E1)), E1, 'b-', label='NN1 prediction')
plt.plot(range(len(E2)), E2, 'r--', label='NN2 prediction')
plt.scatter(A, nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(E1)))
plt.ylabel('Potential energy (eV)')

plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/sur-bridge-6.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/sur-bridge-6.png]]
* DB
#+BEGIN_SRC python
from vasp import Vasp
for i in range(9):
    calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/class=top_fcc/image={}'.format(i))
    calc.write_db('./database/db7/data.db', parser='=', overwrite=False, keys={'dbkey':7, 'structure':'surface'})  

    calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/class=fcc_hcp/image={}'.format(i))
    calc.write_db('./database/db7/data.db', parser='=', overwrite=False, keys={'dbkey':7, 'structure':'surface'})  

    calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/class=hcp_top/image={}'.format(i))
    calc.write_db('./database/db7/data.db', parser='=', overwrite=False, keys={'dbkey':7, 'structure':'surface'})  

    calc = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/image={}'.format(i))
    calc.write_db('./database/db7/data.db', parser='=', overwrite=False, keys={'dbkey':7, 'structure':'surface'})  
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
A = range (50)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md4/adatom=ontop/MD={}'.format(i))
    calc.write_db('./database/db7/data.db', parser='=', overwrite=False, keys={'dbkey':7, 'structure':'surface'})  
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
A = range (20)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md4/v_a=1_19/MD={}'.format(i))
    calc.write_db('./database/db7/data.db', parser='=', overwrite=False, keys={'dbkey':7, 'structure':'surface'})  
#+END_SRC

#+RESULTS:

* Train
** Training Set
#+BEGIN_SRC python
from ase.db import connect
import os
import random
import numpy as np

db = connect('./database/db7/data.db')

n = db.count()
n_train = int(round(n * 0.9))

n_ids =  np.array(range(n)) + 1

# This will sudo-randomly select 10% of the calculations
# Which is useful for reproducing our results.
random.seed(256)
train_samples = random.sample(n_ids, n_train)
valid_samples = set(n_ids) - set(train_samples)

db.update(list(train_samples), train_set=True)
db.update(list(valid_samples), train_set=False)

#+END_SRC

#+RESULTS:

** Training
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()
#20, 24, 25
for n in [20, 24, 25]:

    wd = 'networks/db7/{0}-{0}/'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)
    os.chdir(wd)

    run_amp = """#!/usr/bin/env python
import os
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing

db = connect('../../../database/db7/data.db')
wd = os.getcwd()
images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(load='checkpoint-parameters.json',
           label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=8,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
""".format(n)

    cmd = '''#!/bin/bash
#PBS -N {}
#PBS -l nodes=1:ppn=8
#PBS -l walltime=24:00:00
#PBS -l mem=16GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

    with open('submit.py', 'w') as f:
        f.write(run_amp)
    os.chmod('submit.py', 0777)

    with open('submit.sh', 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', 'submit.sh'])
    time.sleep(2)
    os.unlink('submit.sh')
    os.chdir(home)
#+END_SRC

#+RESULTS:
: 1463112.gilgamesh.cheme.cmu.edu
: 1463113.gilgamesh.cheme.cmu.edu
: 1463114.gilgamesh.cheme.cmu.edu

** Update

#+BEGIN_SRC python
from ase.db import connect
from amp import Amp

db = connect('./database/db7/data.db')
calc1 = Amp(load = './networks/db7/18-18/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db7/24-24/checkpoint-parameters.json')

for d in db.select():
    atoms = db.get_atoms(d.id)
    atoms.set_calculator(calc1)
    nrg1 = atoms.get_potential_energy()

    atoms.set_calculator(calc2)
    nrg2 = atoms.get_potential_energy()
    db.update(d.id, NN18 = nrg1, NN24 = nrg2)
#+END_SRC

#+RESULTS:

** Residual
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from ase.db import connect
from amp import Amp
import os

db = connect('database/db7/data.db')

fig, ax = plt.subplots(1, 2, sharey=True, figsize=(8, 4))

for i, n in enumerate([18, 24]):

    E, nnE, var, ind = [], [], [], []
    for j, d in enumerate(db.select('')):# dbkey=0
	E += [d.energy / d.natoms]
	nnE += [d['NN{}'.format(n)]/ d.natoms]
	var += [j]
	ind += [d.train_set]

    res = np.array(nnE) - np.array(E)
    mask = np.array(ind)
    valid = np.ma.masked_array(res, mask)
    train = np.ma.masked_array(res, ~mask)
    vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
    tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))

    ax[i].text(200, -0.050,
               'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
               color='b', ha='left')
    ax[i].text(200, -0.057,
               'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
               color='r', ha='left')

    ax[i].scatter(var, train, color='b')
    ax[i].scatter(var, valid, color='r')
    ax[i].plot([min(var), max(var)], [0, 0], 'k--')
    ax[i].set_xlim(min(var), max(var))

    ax[i].set_xlabel('Calculation ID')
    ax[i].set_title('8-{0}-{0}-1 framework'.format(n))

ax[0].set_ylim(-0.060, 0.060)
ax[0].set_ylabel('Residual error (eV/atom)')
plt.tight_layout()
plt.savefig('./figures/residual-7.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/residual-7.png]]

Large error configurations
#+BEGIN_SRC python
import numpy as np
from ase.db import connect
ids = []
db = connect('database/db7/data.db')
for i, d in enumerate(db.select('')):
    E = d.energy / d.natoms
    nE = d.NN24/ d.natoms
    if abs(E - nE) > 0.025:
        ids += [i]

print ids
#+END_SRC

#+RESULTS:
: [232, 297, 298, 346, 351, 352, 446, 448, 449, 770]

#+BEGIN_SRC python
from ase.db import connect

db = connect('database/db7/data.db')
for i, d in enumerate(db.select('id=297')):
        for key in d:
            print ('{0:25}:{1}'.format(key, d[key]))
#+END_SRC

#+RESULTS:
#+begin_example
user                     :tianyug1
forces                   :[[ 0.  0.  0.]]
magmoms                  :[ 0.]
tags                     :[0]
calculator               :vasp
dbkey                    :0
bulk                     :bcc
calculator_parameters    :"\"\\\"\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"{\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"xc\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"pbe\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\", \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"kpts\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": [14, 14, 14], \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"encut\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": 350, \\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"nsw\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\": 0}\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"\\\\\\\\\\\\\\\"\\\\\\\"\\\"\""
mtime                    :16.7028049783
structure                :bulk
ctime                    :16.6728820785
magmom                   :0.0
stress                   :[-0.02622885 -0.02622885 -0.02622885 -0.         -0.         -0.        ]
NN15                     :-5.1908967799
train_set                :True
charges                  :[  2.32511576e-310]
positions                :[[ 0.  0.  0.]]
NN24                     :-5.1937311759
NN18                     :-5.20114794408
NN20                     :-5.17900664137
id                       :297
cell                     :[[ 2.68869711  0.          0.        ]
 [-0.89623237  2.53492795  0.        ]
 [-0.89623237 -1.26746397  2.195312  ]]
pbc                      :[ True  True  True]
factor                   :0.99
type                     :eos
energy                   :-5.16486458
unique_id                :71e8ece42a6233b04295be8163da14a2
numbers                  :[46]
#+end_example

*** Bulk Residual
#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db6/data.db')

S, Qe, Ne = [], [], []

for d in db.select(['type=eos']):
    S += [d.bulk]
    Qe += [d.energy/d.natoms]
    Ne += [d.NN18/d.natoms]
    
S = np.array(S)
Qe = np.array(Qe)
Ne = np.array(Ne)

cmap, hdl = {}, []

#print Ne
for s, c in zip(set(S), ['b', 'r', 'g', 'c', 'm']):
    cmap[s] = c
    hdl +=[mpatches.Patch(color = c, label = s)]

c = []
for s in S:
    c +=[cmap[s]]

RMSE = np.sqrt(sum((Ne-Qe)** 2) / len(Ne - Qe))

(mu, sigma) = norm.fit(Ne- Qe)

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
ax0.plot([min(Qe), 0], [0,0], 'k--', lw =2)
ax0.scatter(Qe, Ne-Qe, marker = 'o', color = c)
ax0.text(min(Qe) + 0.1, 0.14,
         'RMSE: {0:1.3f}'.format(RMSE),
         fontsize = 12, va = 'top', ha = 'left')
ax0.set_xlim(min(Qe), 0)
ax0.set_ylim(-0.05, 0.05)
ax0.set_xlabel('DFT potential energy (eV/atom)')
ax0.set_ylabel('Rsidual error (eV/atom)')
ax0.legend(loc = 'best', handles =hdl, fontsize = 8, frameon = False)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(Ne-Qe, 50,
                            range = (-0.05, 0.05),
                            weights = np.ones_like(Ne-Qe)/ len(Ne),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.05, 0.142, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.05, 0.122, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.05, 0.05)
ax1.set_xlim(0, 0.3)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
plt.tight_layout(w_pad = -0.5)

plt.savefig('./figures/eos-residual-6.png')
#plt.show()

#+END_SRC

#+RESULTS:

eos-residual

[[./figures/eos-residual-6.png]]


#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db6/data.db')

S, Qe, Ne = [], [], []

for d in db.select([]):
    S += [d.structure]
    Qe += [d.energy/d.natoms]
    Ne += [d.NN18/d.natoms]
    
S = np.array(S)
Qe = np.array(Qe)
Ne = np.array(Ne)

cmap, hdl = {}, []

#print Ne
for s, c in zip(set(S), ['b', 'r']):
    cmap[s] = c
    hdl +=[mpatches.Patch(color = c, label = s)]

c = []
for s in S:
    c +=[cmap[s]]

RMSE = np.sqrt(sum((Ne-Qe)** 2) / len(Ne - Qe))

(mu, sigma) = norm.fit(Ne- Qe)

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
ax0.plot([min(Qe), 0], [0,0], 'k--', lw =2)
ax0.scatter(Qe, Ne-Qe, marker = 'o', color = c)
ax0.text(min(Qe) + 0.1, 0.14,
         'RMSE: {0:1.3f}'.format(RMSE),
         fontsize = 12, va = 'top', ha = 'left')
ax0.set_xlim(min(Qe), 0)
ax0.set_ylim(-0.05, 0.05)
ax0.set_xlabel('DFT potential energy (eV/atom)')
ax0.set_ylabel('Rsidual error (eV/atom)')
ax0.legend(loc = 'best', handles =hdl, fontsize = 8, frameon = False)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(Ne-Qe, 50,
                            range = (-0.05, 0.05),
                            weights = np.ones_like(Ne-Qe)/ len(Ne),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.05, 0.142, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.05, 0.122, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.05, 0.05)
ax1.set_xlim(0, 0.3)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
plt.tight_layout(w_pad = -0.5)

#plt.savefig('./figures/eos-residual-6.png')
plt.show()

#+END_SRC

#+RESULTS:

*** surface residual

#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db7/data.db')

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
E, nE, var, ind = [], [], [], []
#for j, d in enumerate(db.select(['order=md2','structure=surface'])):# dbkey=0
#for j, d in enumerate(db.select(['v_a=0_20'])):# dbkey=0
#for j, d in enumerate(db.select(['type=vacancy', 'structure=surface'])):# dbkey=0
for j, d in enumerate(db.select(['type=elastic'])):
    E += [d.energy / d.natoms]
    nE += [d.NN24/ d.natoms]
    var += [j]
    ind += [d.train_set]

E = np.array(E)
nE = np.array(nE)
res = np.array(nE) - np.array(E)
mask = np.array(ind)
valid = np.ma.masked_array(res, mask)
train = np.ma.masked_array(res, ~mask)
vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))

ax0.text(380, -0.048,
           'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
           color='b', ha='left')
ax0.text(270, -0.055,
           'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
           color='r', ha='left')

ax0.scatter(var, train, color='b')
ax0.scatter(var, valid, color='r')
ax0.plot([min(var), max(var)], [0, 0], 'k--')
ax0.set_xlim(min(var), max(var))
ax0.set_ylim(-0.015, 0.015)

ax0.set_xlabel('Calculation ID')
ax0.set_title('8-15-15-1 framework')


(mu, sigma) = norm.fit(nE - E)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(nE-E, 50,
                            range = (-0.05, 0.05),
                            weights = np.ones_like(nE-E)/ len(nE),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.01, 0.04, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.01, 0.03, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.05, 0.05)
ax1.set_xlim(0, 0.20)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
ax1.set_title('Error Distribution')
plt.tight_layout(w_pad = -0.5)
#plt.savefig('./figures/surf-error-distribution-6.png')
plt.show()
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

from ase.db import connect

db = connect('./database/db7/data.db')
#data = db.select(['structure=surface', 'type=vacancy', 'supercell=22'])
data = db.select(['type=elastic'])
for i in data:
    print i.factor, i.energy, (i.energy-i.NN18)

'''
keys, cnt = {}, 0
for entry in data:
    cnt += 1
    for k, v in entry.key_value_pairs.iteritems():
        
        if k in keys:
            keys[k] += [v]
        else:
            keys[k] = [v]

print ('{0:15s} {1:15s} {2} calculations total'.format('keyword', 'value',cnt))

print('------------------------------------------------------')

for k, v in keys.iteritems():
    vals = list(set(v))
    if len(vals) <= 5:
        val = ", ".join(str(e) for e in vals)
        print('{0:15}: {1}'.format(k, val))

    else:
        val = ", ".join(str(e)[:5] for e in vals[:5])
        print('{0:15s}:{1}, etc...'.format(k, val))
'''
#+END_SRC
#+RESULTS:
#+begin_example
0.0 -5.21446998 0.00196449419072
0.001 -5.21443415 0.00194796735523
0.002 -5.2143216 0.00190419034612
0.003 -5.21414158 0.00182499340906
0.004 -5.21388803 0.00171747306818
0.005 -5.21360063 0.00154293858689
0.006 -5.21324321 0.00133850541056
0.007 -5.21279459 0.0011262649166
0.008 -5.21225954 0.000902318906272
0.009 -5.21170139 0.000604173164627
0.01 -5.2110564 0.000296377242254
0.011 -5.21034563 -4.13512298527e-05
0.012 -5.20957786 -0.000417036774436
0.013 -5.20871888 -0.000795735257381
0.014 -5.20778587 -0.00119390251207
0.015 -5.20680952 -0.00164152279849
0.016 -5.20572511 -0.00207318383732
0.017 -5.20459753 -0.00255308020595
0.018 -5.20339039 -0.00304412378896
0.019 -5.20213965 -0.00358157488126
0.02 -5.20079415 -0.00411357003515
0.021 -5.19939455 -0.00468004007732
0.022 -5.19789448 -0.00523387467908
0.023 -5.19634709 -0.00582746230253
0.024 -5.19471797 -0.00642559387557
0.025 -5.19304971 -0.00706966824368
0.026 -5.19129271 -0.00770692080919
0.027 -5.18946602 -0.00835507335248
0.028 -5.18761756 -0.00906104158306
0.029 -5.18569292 -0.00976939401548
0.03 -5.18368705 -0.0104739937039
0.031 -5.18165941 -0.0112331644413
0.032 -5.17953386 -0.0119695613701
0.033 -5.17736772 -0.0127392706012
0.034 -5.17514019 -0.0135201757169
0.035 -5.17285624 -0.0143158672777
0.036 -5.17052036 -0.0151293910713
0.037 -5.16813852 -0.0159652255627
0.038 -5.16571347 -0.0168245531539
0.039 -5.16323625 -0.0176967664669
0.04 -5.16068311 -0.0185564147657
0.0 -5.21446998 0.00196449419072
0.001 -5.21444534 0.00197669100811
0.002 -5.21440478 0.00197991906925
0.003 -5.21434699 0.00197547712961
0.004 -5.21425826 0.00197706298254
0.005 -5.21416433 0.00195891410804
0.006 -5.21402955 0.00195665326744
0.007 -5.2138944 0.00192976797312
0.008 -5.21371496 0.00192214149517
0.009 -5.21353901 0.00188594663667
0.01 -5.21335173 0.0018359515949
0.011 -5.2131342 0.00179102455958
0.012 -5.21288805 0.00174946899936
0.013 -5.21262768 0.00169681544701
0.014 -5.21236442 0.00162166422517
0.015 -5.21206913 0.00155307315297
0.016 -5.21174865 0.00148411105845
0.017 -5.21141889 0.00139878539872
0.018 -5.21106792 0.00130892182259
0.019 -5.21068171 0.00122844902919
0.02 -5.21028343 0.00113408858734
0.021 -5.20986873 0.00103007504116
0.022 -5.20942726 0.000926636669414
0.023 -5.20897583 0.000806842089824
0.024 -5.20849676 0.000688232694736
0.025 -5.20799037 0.000570358425212
0.026 -5.20748033 0.000429404585927
0.027 -5.20695004 0.000281821764688
0.028 -5.20639995 0.00012700660872
0.029 -5.20581081 -1.59435644376e-05
0.03 -5.20521594 -0.000180520854849
0.031 -5.2046006 -0.000352144643467
0.032 -5.20396364 -0.000529848577866
0.033 -5.2033036 -0.000712337049304
0.034 -5.20262779 -0.000907114092286
0.035 -5.20193306 -0.00111121582662
0.036 -5.2012138 -0.00131921814454
0.037 -5.20047023 -0.00153154006428
0.038 -5.19970072 -0.00174675868557
0.039 -5.19892508 -0.00198487516206
0.04 -5.19811541 -0.0022182077369
#+end_example

* Application
** Finding poor-fitting energy minimum
*** Bulk Vacancy NEB
#+BEGIN_SRC python
from vasp import Vasp
from amp import Amp
import numpy as np

E, En = [], []

calc2 = Amp(load = './networks/db7/24-24/checkpoint-parameters.json')
for i in range(9):
    calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/image={0}'.format(i))

    atoms = calc.get_atoms()
    E += [calc.potential_energy/len(atoms)]
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()/len(atoms)]

E = np.array(E)
En = np.array(En)
error = E - En
print error
#+END_SRC

#+RESULTS:
: [-0.00200526 -0.00197038 -0.00151491 -0.00720662 -0.01346345 -0.00720662
:  -0.00151491 -0.00197042 -0.00200527]

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db7/buk-vac-img4')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from vasp import Vasp
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

calc = Vasp("./../../../NDFT/bulk=fcc/type=neb/supercell=222/image=4")

atoms = calc.get_atoms()

atoms.set_calculator(Amp(load="./../../../networks/db7/24-24/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=5)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=5)

dyn.run(100)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1463804.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db7/buk-vac-img4')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from vasp import Vasp
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

calc = Vasp("./../../../NDFT/bulk=fcc/type=neb/supercell=222/image=4")

atoms = calc.get_atoms()

atoms.set_calculator(Amp(load="./../../../networks/db7/24-24/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=5)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=5)

dyn.run(100)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db7/buk-vac-img5')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from vasp import Vasp
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

calc = Vasp("./../../../NDFT/bulk=fcc/type=neb/supercell=222/image=5")

atoms = calc.get_atoms()

atoms.set_calculator(Amp(load="./../../../networks/db7/24-24/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=5)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=5)

dyn.run(200)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1463805.gilgamesh.cheme.cmu.edu

*** Surface relaxation

#+BEGIN_SRC python
from vasp import Vasp
from amp import Amp
import numpy as np

E, En = [], []

calc2 = Amp(load = './networks/db7/24-24/checkpoint-parameters.json')

calc = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00')

atoms = calc.get_atoms()
E += [calc.potential_energy/len(atoms)]
atoms.set_calculator(calc2)
En += [atoms.get_potential_energy()/len(atoms)]

E = np.array(E)
En = np.array(En)
error = E - En
print error
#+END_SRC

#+RESULTS:
: [-0.00320072]

*** Vacancy relaxation
#+BEGIN_SRC python
from vasp import Vasp
from amp import Amp
import numpy as np

E, En = [], []

calc2 = Amp(load = './networks/db7/24-24/checkpoint-parameters.json')

calc = Vasp('NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=22')

atoms = calc.get_atoms()
E += [calc.potential_energy/len(atoms)]
atoms.set_calculator(calc2)
En += [atoms.get_potential_energy()/len(atoms)]

E = np.array(E)
En = np.array(En)
error = E - En
print error
#+END_SRC

#+RESULTS:
: [-0.00083127]

#+BEGIN_SRC python
from vasp import Vasp
from amp import Amp
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
E, En = [], []

calc2 = Amp(load = './networks/db7/24-24/checkpoint-parameters.json')

for i in range (9):

    calc = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/image={0}'.format(i))

    atoms = calc.get_atoms()
    E += [calc.potential_energy/len(atoms)]
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()/len(atoms)]

E = np.array(E)
En = np.array(En)
#error = E - En
#print error

E = E - E[0]
En = En - En[0]
x = range(len(En))
xarray = np.linspace(0, len(En))
f1 = interp1d(x, E, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(x, E, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
plt.show()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db7/sur-vac-img4')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from vasp import Vasp
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

calc = Vasp("./../../../NDFT/surface=fcc111/type=neb/class=vacancy/image=4")

atoms = calc.get_atoms()

atoms.set_calculator(Amp(load="./../../../networks/db7/24-24/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=5)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=5)

dyn.run(200)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1463851.gilgamesh.cheme.cmu.edu


#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db7/sur-vac-img5')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from vasp import Vasp
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

calc = Vasp("./../../../NDFT/surface=fcc111/type=neb/class=vacancy/image=5")

atoms = calc.get_atoms()

atoms.set_calculator(Amp(load="./../../../networks/db7/24-24/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=5)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=5)

dyn.run(200)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1463850.gilgamesh.cheme.cmu.edu

*** Adatom diffusion NEB
#+BEGIN_SRC python
from vasp import Vasp
from amp import Amp
import numpy as np

E, En = [], []

calc2 = Amp(load = './networks/db7/24-24/checkpoint-parameters.json')
for i in range (9):
#calc = Vasp('NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=22')
    calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/class=top_fcc/image={0}'.format(i))

    atoms = calc.get_atoms()
    E += [calc.potential_energy/len(atoms)]
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()/len(atoms)]

E = np.array(E)
En = np.array(En)
error = E - En
print error
#+END_SRC

#+RESULTS:
: [ 0.00584971  0.00561943  0.0049393   0.00324802  0.00104662 -0.00117011
:  -0.00283491 -0.00360671 -0.00346062]

*** adatom MD

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db7/buk-adatom-fcc')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from vasp import Vasp
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

calc = Vasp("./../../../NDFT/surface=fcc111/type=adatom/supercell=22/site=fcc")

atoms = calc.get_atoms()

atoms.set_calculator(Amp(load="./../../../networks/db7/24-24/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=5)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=5)

dyn.run(250)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1463910.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db7/buk-adatom-hcp')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from vasp import Vasp
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

calc = Vasp("./../../../NDFT/surface=fcc111/type=adatom/supercell=22/site=hcp")

atoms = calc.get_atoms()

atoms.set_calculator(Amp(load="./../../../networks/db7/24-24/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=5)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=5)

dyn.run(250)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1463911.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db7/buk-adatom-bridge')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from vasp import Vasp
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

calc = Vasp("./../../../NDFT/surface=fcc111/type=adatom/supercell=22/site=bridge")

atoms = calc.get_atoms()

atoms.set_calculator(Amp(load="./../../../networks/db7/24-24/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=5)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=5)

dyn.run(250)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1463912.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db7/buk-adatom-top')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from vasp import Vasp
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

calc = Vasp("./../../../NDFT/surface=fcc111/type=adatom/supercell=22/site=top")

atoms = calc.get_atoms()

atoms.set_calculator(Amp(load="./../../../networks/db7/24-24/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=5)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=5)

dyn.run(250)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1463913.gilgamesh.cheme.cmu.edu

** vacancy NEB
*** bulk
#+BEGIN_SRC python
from vasp import Vasp
from amp import Amp
import matplotlib.pyplot as plt
import numpy as np
from scipy.interpolate import interp1d

E, En = [], []
calc1 = Amp(load = './networks/db7/18-18/checkpoint-parameters.json')

for i in range(9):

    calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/image={}'.format(i))
    atoms = calc.get_atoms()
    E += [calc.potential_energy/len(atoms)]
    atoms.set_calculator(calc1)
    En += [atoms.get_potential_energy()/len(atoms)]

E = np.array(E)
En = np.array(En)

#E = E - E[0]
#En = En - En[0]
x = range(len(E))
xarray = np.linspace(0, len(E))
f1 = interp1d(x, E, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(range(len(E)), E, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
plt.show()
#+END_SRC

#+RESULTS:

*** surface
#+BEGIN_SRC python
from vasp import Vasp
from amp import Amp
import matplotlib.pyplot as plt
import numpy as np
from scipy.interpolate import interp1d

E, En = [], []
calc1 = Amp(load = './networks/db7/24-24/checkpoint-parameters.json')

for i in range(9):

    calc = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/image={}'.format(i))
    atoms = calc.get_atoms()
    E += [calc.potential_energy/len(atoms)]
    atoms.set_calculator(calc1)
    En += [atoms.get_potential_energy()/len(atoms)]

E = np.array(E)
En = np.array(En)

E = E - E[0]
En = En - En[0]
x = range(len(E))
xarray = np.linspace(0, len(E))
f1 = interp1d(x, E, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(range(len(E)), E, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
plt.show()
#+END_SRC

#+RESULTS:

** adatom NEB 
#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d
from amp import Amp
calc0 = Amp(load = './networks/db7/24-24/checkpoint-parameters.json')

En = []
E1 = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=top').potential_energy
E2 = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=fcc').potential_energy
E3 = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=hcp').potential_energy
calc1 = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/class=top_fcc/neb')
images, energies1 = calc1.get_neb()
nrg1 = E1 + energies1

for atoms in images:
    atoms.set_calculator(calc0)
    En += [atoms.get_potential_energy()]
calc2 = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/class=fcc_hcp/neb')
images, energies2 = calc2.get_neb()
nrg2 = E2 + energies2

for atoms in images:
    atoms.set_calculator(calc0)
    En += [atoms.get_potential_energy()]

calc3 = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/class=hcp_top/neb')
images, energies3 = calc3.get_neb()
nrg3 = E3 + energies3

for atoms in images:
    atoms.set_calculator(calc0)
    En += [atoms.get_potential_energy()]
nrg = []
nrg.append(nrg1)
nrg.append(nrg2)
nrg.append(nrg3)

print nrg
print En

#+END_SRC

#+RESULTS:
: [array([-103.16314489, -103.17362203, -103.22147716, -103.32938334,
:        -103.48398825, -103.66603531, -103.84634143, -103.98241757,
:        -104.02334307]), array([-104.02334307, -103.99930865, -103.93616107, -103.88095009,
:        -103.85664787, -103.86981663, -103.91413569, -103.96879078,
:        -103.98963043]), array([-103.98963043, -103.95344617, -103.82724601, -103.6590986 ,
:        -103.48889736, -103.34291469, -103.23595949, -103.17862415,
:        -103.16314489])]
: [-103.28791408117687, -103.28210559551798, -103.31415598466465, -103.38233098208265, -103.48706752953666, -103.62298896847966, -103.77426775888706, -103.90140493445897, -103.95419139204513, -103.95419139204513, -103.92986688779577, -103.88647148399599, -103.85058670163461, -103.83714940276464, -103.8489838586693, -103.88193490742502, -103.92461925347857, -103.9497983307213, -103.9497983307213, -103.89741984451148, -103.77199794524479, -103.6258998874668, -103.49478956597667, -103.39306005807885, -103.32366362321665, -103.28567174974906, -103.28791408117687]


#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
nrg =  np.array([-103.16314489, -103.17362203, -103.22147716, -103.32938334, -103.48398825, -103.66603531, -103.84634143, -103.98241757, -104.02334307, -103.99930865, -103.93616107, -103.88095009, -103.85664787, -103.86981663, -103.91413569, -103.96879078, -103.98963043, -103.95344617, -103.82724601, -103.6590986 , -103.48889736, -103.34291469, -103.23595949, -103.17862415, -103.16314489])

En = np.array([-103.28791408117687, -103.28210559551798, -103.31415598466465, -103.38233098208265, -103.48706752953666, -103.62298896847966, -103.77426775888706, -103.90140493445897, -103.95419139204513, -103.92986688779577, -103.88647148399599, -103.85058670163461, -103.83714940276464, -103.8489838586693, -103.88193490742502, -103.92461925347857, -103.9497983307213, -103.89741984451148, -103.77199794524479, -103.6258998874668, -103.49478956597667, -103.39306005807885, -103.32366362321665, -103.28567174974906, -103.28791408117687])
#nrg = nrg - nrg[0]
#En = En- En[0]
nrg = nrg/21
En = En/21

nrg = nrg - nrg[0]
En = En - En[0]
x = range(len(nrg))
xarray = np.linspace(0, len(nrg))
f1 = interp1d(x, nrg, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(range(len(nrg)), nrg, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
plt.show()
#plt.savefig('./figures/surf-adatom-NEB.png')
#+END_SRC

#+RESULTS:


* 9th DFT
** 211
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

VASPRC['queue.ppn'] = 4

a0 = 3.939
nrg = []

atoms = fcc211('Pd', size=(3, 3, 5), a = a0,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.z < 10.05 for atom in atoms])
atoms.set_constraint(constraint)
#view (atoms)

calc = Vasp('NDFT/surface=fcc211//type=relaxation/supercell=33',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=2,
            nsw=25,
            atoms=atoms)
		

calc.set_memory()

print calc.potential_energy
#+END_SRC

#+RESULTS:
: No calculation_required.
: -223.69267677
#+BEGIN_SRC python
from vasp import Vasp
from amp import Amp
calc = Vasp('NDFT/surface=fcc211//type=relaxation/supercell=33')
atoms = calc.get_atoms()

calc2 = Amp(load = './networks/db8/25-25/checkpoint-parameters.json')
atoms.set_calculator(calc2)
print atoms.get_potential_energy()
#+END_SRC

#+RESULTS:
: -223.528766784

** MD
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 2
images = Trajectory('./database/db7/buk-vac-img4/MD.traj', 'r')

for i in range(20):
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md5/image=4/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 9],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 2
images = Trajectory('./database/db7/buk-vac-img5/MD.traj', 'r')

for i in range(20):
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md5/image=5/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 9],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC

#+BEGIN_SRC python
from vasp import Vasp
calc = Vasp('NDFT/bulk=fcc/type=md/order=md5/image=4/MD=0')
E = calc.potential_energy
print E

calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/image=4')
E = calc.potential_energy
print E
#+END_SRC

#+RESULTS:
: -34.75184168
: -34.75753739

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 2
images = Trajectory('./database/db7/buk-adatom-fcc/MD.traj', 'r')

for i in range(25):
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md5/site=fcc/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC


#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 2
images = Trajectory('./database/db7/buk-adatom-hcp/MD.traj', 'r')

for i in range(25):
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md5/site=hcp/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 2
images = Trajectory('./database/db7/buk-adatom-bridge/MD.traj', 'r')

for i in range(25):
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md5/site=bridge/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC


#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 2
images = Trajectory('./database/db7/buk-adatom-top/MD.traj', 'r')

for i in range(25):
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md5/site=top/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC

#+RESULTS:

** Slipping barrier
*** Position
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms
from ase import Atoms, Atom

#VASPRC['queue.mem'] = '8GB'
#VASPRC['queue.walltime'] = '24:00:00'

calc = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00')
slab = calc.get_atoms()

layer = fcc111('Pd', size=(2, 2, 1), a = 3.939,  vacuum=0.0)
#end = slab.copy()
p = slab.positions

pfcc = (p[16] + p[17] + p[18])/3.0 + [0, 0, 2]
#add = Atoms([Atom('Pd')])
#add.translate(-add.get_center_of_mass())
#add.translate(pfcc)
layer.translate(pfcc)

fcc = slab + layer
#fcc = slab + add
constraint = FixAtoms(mask=[atom.z < 17  for atom in fcc])
fcc.set_constraint(constraint)
#print fcc.get_tags()
#view(fcc)

calc = Vasp('NDFT/surface=fcc111/type=neb/layer=True/position=fcc',
            xc = 'pbe',
            kpts=[9,9,1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=fcc)
calc.get_memory()
calc.calculate()

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=neb/layer=True/position=fcc submitted: 1464161.gilgamesh.cheme.cmu.edu
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms
from ase import Atoms, Atom

#VASPRC['queue.mem'] = '8GB'
#VASPRC['queue.walltime'] = '24:00:00'

calc = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00')
slab = calc.get_atoms()

layer = fcc111('Pd', size=(2, 2, 1), a = 3.939,  vacuum=0.0)
#end = slab.copy()
p = slab.positions

ptop = (p[17]  + [0, 0, 2.4])
#add = Atoms([Atom('Pd')])
#add.translate(-add.get_center_of_mass())
#add.translate(pfcc)
layer.translate(ptop)

top = slab + layer
#fcc = slab + add
constraint = FixAtoms(mask=[atom.z < 17  for atom in top])
top.set_constraint(constraint)
#print fcc.get_tags()
#view(top)

calc = Vasp('NDFT/surface=fcc111/type=neb/layer=True/position=top',
            xc = 'pbe',
            kpts=[9,9,1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=top)
calc.get_memory()
calc.calculate()

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=neb/layer=True/position=top submitted: 1464162.gilgamesh.cheme.cmu.edu
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms
from ase import Atoms, Atom

#VASPRC['queue.mem'] = '8GB'
#VASPRC['queue.walltime'] = '24:00:00'

calc = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00')
slab = calc.get_atoms()

layer = fcc111('Pd', size=(2, 2, 1), a = 3.939,  vacuum=0.0)
#end = slab.copy()
p = slab.positions

phcp = ((p[17]+p[18]+p[19])/3  + [0, 0, 2])
#add = Atoms([Atom('Pd')])
#add.translate(-add.get_center_of_mass())
#add.translate(pfcc)
layer.translate(phcp)

hcp = slab + layer
#fcc = slab + add
constraint = FixAtoms(mask=[atom.z < 17  for atom in hcp])
hcp.set_constraint(constraint)
#print fcc.get_tags()
#view(hcp)


calc = Vasp('NDFT/surface=fcc111/type=neb/layer=True/position=hcp',
            xc = 'pbe',
            kpts=[9,9,1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=hcp)
calc.get_memory()
calc.calculate()

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=neb/layer=True/position=hcp submitted: 1464163.gilgamesh.cheme.cmu.edu

** MD validation
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
from vasp import Vasp
from vasp.vasprc import VASPRC
VASPRC['queue.walltime'] = '24:00:00'

images = Trajectory('./database/db1/MD0-8-0.traj')
for i in range(200):        
    calc = Vasp('NDFT/bulk=fcc/type=validation/v_a=0_8/MD={}'.format(i),
                xc='pbe',
                kpts=[9]*3,
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.calculate()
#+END_SRC

* DB
** write
#+BEGIN_SRC python
from vasp import Vasp
A = range (20)
for i in A:        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md5/image=4/MD={}'.format(i))
    calc.write_db('./database/db8/data.db', parser='=', overwrite=False, keys={'dbkey':8, 'structure':'bulk'})  
#+END_SRC

#+RESULTS:
#+BEGIN_SRC python
from vasp import Vasp
A = range (20)
for i in A:        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md5/image=5/MD={}'.format(i))
    calc.write_db('./database/db8/data.db', parser='=', overwrite=False, keys={'dbkey':8, 'structure':'bulk'})  
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
A = range (25)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md5/site=fcc/MD={}'.format(i))
    calc.write_db('./database/db8/data.db', parser='=', overwrite=False, keys={'dbkey':8, 'structure':'surface'})  
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
A = range (25)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md5/site=hcp/MD={}'.format(i))
    calc.write_db('./database/db8/data.db', parser='=', overwrite=False, keys={'dbkey':8, 'structure':'surface'})  
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
A = range (25)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md5/site=bridge/MD={}'.format(i))
    calc.write_db('./database/db8/data.db', parser='=', overwrite=False, keys={'dbkey':8, 'structure':'surface'})  
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
A = range (25)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md5/site=top/MD={}'.format(i))
    calc.write_db('./database/db8/data.db', parser='=', overwrite=False, keys={'dbkey':8, 'structure':'surface'})  
#+END_SRC

#+RESULTS:

* Training
** Training Set
#+BEGIN_SRC python
from ase.db import connect
import os
import random
import numpy as np

db = connect('./database/db8/data.db')

n = db.count()
n_train = int(round(n * 0.9))

n_ids =  np.array(range(n)) + 1

# This will sudo-randomly select 10% of the calculations
# Which is useful for reproducing our results.
random.seed(256)
train_samples = random.sample(n_ids, n_train)
valid_samples = set(n_ids) - set(train_samples)

db.update(list(train_samples), train_set=True)
db.update(list(valid_samples), train_set=False)

#+END_SRC

#+RESULTS:

** Training
#+BEGIN_SRC python
import os
import subprocess
import time
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing

home = os.getcwd()

for n in [2]:

    wd = 'temp/db5/{0}-{0}/'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)
    os.chdir(wd)


from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing

db = connect('../../../database/db5/data.db')

images = []
for d in db.select(''):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, 2)))

calc.train(images=images,
	   data_format='db',
	   cores=4,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)

#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

for n in [18, 20, 24, 25]:

    wd = 'networks/db8/{0}-{0}/'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)
    os.chdir(wd)

    run_amp = """#!/usr/bin/env python
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing

db = connect('../../../database/db8/data.db')

images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=8,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
""".format(n)

    cmd = '''#!/bin/bash
#PBS -N {}
#PBS -l nodes=1:ppn=8
#PBS -l walltime=168:00:00
#PBS -l mem=16GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

    with open('submit.py', 'w') as f:
        f.write(run_amp)
    os.chmod('submit.py', 0777)

    with open('submit.sh', 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', 'submit.sh'])
    time.sleep(2)
    os.unlink('submit.sh')
    os.chdir(home)
#+END_SRC

#+RESULTS:
: 1464165.gilgamesh.cheme.cmu.edu

load
load=os.path.join(wd, 'checkoutpoint-parameters-0.json'),
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

for n in [18]:

    wd = 'networks/db5/{0}-{0}/'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)
    os.chdir(wd)

    run_amp = """#!/usr/bin/env python
import os
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing

db = connect('../../../database/db5/data.db')
wd = os.getcwd()
images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(load='checkpoint-parameters.json',
           label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=4,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
""".format(n)

    cmd = '''#!/bin/bash
#PBS -N {}
#PBS -l nodes=1:ppn=4
#PBS -l walltime=168:00:00
#PBS -l mem=16GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

    with open('submit.py', 'w') as f:
        f.write(run_amp)
    os.chmod('submit.py', 0777)

    with open('submit.sh', 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', 'submit.sh'])
    time.sleep(2)
    os.unlink('submit.sh')
    os.chdir(home)
#+END_SRC

#+RESULTS:
: 1461120.gilgamesh.cheme.cmu.edu


#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing
import os

home = os.getcwd()
wd = 'networks/db3/10-10/'
os.chdir(wd)

db = connect('../../../database/db3/data.db')
wd = os.getcwd()
images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(load='parameters.json',
           label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=4,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
#+END_SRC

** Update

#+BEGIN_SRC python
from ase.db import connect
from amp import Amp

db = connect('./database/db8/data.db')
calc1 = Amp(load = './networks/db8/18-18/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db8/25-25/checkpoint-parameters.json')

for d in db.select():
    atoms = db.get_atoms(d.id)
    atoms.set_calculator(calc1)
    nrg1 = atoms.get_potential_energy()

    atoms.set_calculator(calc2)
    nrg2 = atoms.get_potential_energy()
    db.update(d.id, NN18 = nrg1, NN25 = nrg2)
#+END_SRC

#+RESULTS:

** Residual
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from ase.db import connect
from amp import Amp
import os

db = connect('database/db8/data.db')

fig, ax = plt.subplots(1, 2, sharey=True, figsize=(8, 4))

for i, n in enumerate([18, 25]):

    E, nnE, var, ind = [], [], [], []
    for j, d in enumerate(db.select('')):# dbkey=0
	E += [d.energy / d.natoms]
	nnE += [d['NN{}'.format(n)]/ d.natoms]
	var += [j]
	ind += [d.train_set]

    res = np.array(nnE) - np.array(E)
    mask = np.array(ind)
    valid = np.ma.masked_array(res, mask)
    train = np.ma.masked_array(res, ~mask)
    vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
    tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))

    ax[i].text(200, -0.050,
               'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
               color='b', ha='left')
    ax[i].text(200, -0.057,
               'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
               color='r', ha='left')

    ax[i].scatter(var, train, color='b')
    ax[i].scatter(var, valid, color='r')
    ax[i].plot([min(var), max(var)], [0, 0], 'k--')
    ax[i].set_xlim(min(var), max(var))

    ax[i].set_xlabel('Calculation ID')
    ax[i].set_title('8-{0}-{0}-1 framework'.format(n))

ax[0].set_ylim(-0.060, 0.060)
ax[0].set_ylabel('Residual error (eV/atom)')
plt.tight_layout()
plt.savefig('./figures/residual-8.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/residual-8.png]]

Large error configurations
#+BEGIN_SRC python
import numpy as np
from ase.db import connect
ids = []
db = connect('database/db8/data.db')
for i, d in enumerate(db.select('type=eos')):
    E = d.energy / d.natoms
    nE = d.NN18/ d.natoms
    if abs(E - nE) > 0.03:
        ids += [i]
        print d.bulk
        print d.factor

print ids
#+END_SRC

#+RESULTS:
#+begin_example
bcc
0.99
bcc
1.0
bcc
1.01
hcp
0.88
hcp
0.89
hcp
0.9
hcp
0.91
hcp
0.99
hcp
1.0
hcp
1.01
[68, 69, 70, 111, 112, 113, 114, 122, 123, 124]
#+end_example

#+BEGIN_SRC python
from ase.db import connect

ids = [0, 296, 297, 298, 339]
db = connect('database/db8/data.db')
for i in ids:
    item = db.select('id={}'.format(i))
    print item.NN18
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.db import connect

db = connect('database/db6/data.db')
for i, d in enumerate(db.select('structure=surface', 'type=vacancy', 'supercell=22')):
        for key in d:
            print ('{0:25}:{1}'.format(key, d[key]))
#+END_SRC

#+RESULTS:

*** Bulk Residual
#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db8/data.db')

S, Qe, Ne = [], [], []

for d in db.select(['type=eos']):
    S += [d.bulk]
    Qe += [d.energy/d.natoms]
    Ne += [d.NN18/d.natoms]
    
S = np.array(S)
Qe = np.array(Qe)
Ne = np.array(Ne)

cmap, hdl = {}, []

#print Ne
for s, c in zip(set(S), ['b', 'r', 'g', 'c', 'm']):
    cmap[s] = c
    hdl +=[mpatches.Patch(color = c, label = s)]

c = []
for s in S:
    c +=[cmap[s]]

RMSE = np.sqrt(sum((Ne-Qe)** 2) / len(Ne - Qe))

(mu, sigma) = norm.fit(Ne- Qe)

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
ax0.plot([min(Qe), 0], [0,0], 'k--', lw =2)
ax0.scatter(Qe, Ne-Qe, marker = 'o', color = c)
ax0.text(min(Qe) + 0.1, 0.14,
         'RMSE: {0:1.3f}'.format(RMSE),
         fontsize = 12, va = 'top', ha = 'left')
ax0.set_xlim(min(Qe), 0)
ax0.set_ylim(-0.05, 0.05)
ax0.set_xlabel('DFT potential energy (eV/atom)')
ax0.set_ylabel('Rsidual error (eV/atom)')
ax0.legend(loc = 'best', handles =hdl, fontsize = 8, frameon = False)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(Ne-Qe, 50,
                            range = (-0.05, 0.05),
                            weights = np.ones_like(Ne-Qe)/ len(Ne),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.05, 0.04, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.05, 0.03, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.05, 0.05)
ax1.set_xlim(0, 0.3)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
plt.tight_layout(w_pad = -0.5)

plt.savefig('./figures/eos-residual-8.png')
#plt.show()

#+END_SRC

#+RESULTS:

eos-residual

[[./figures/eos-residual-8.png]]


#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db8/data.db')

S, Qe, Ne = [], [], []

for d in db.select([]):
    S += [d.structure]
    Qe += [d.energy/d.natoms]
    Ne += [d.NN18/d.natoms]
    
S = np.array(S)
Qe = np.array(Qe)
Ne = np.array(Ne)

cmap, hdl = {}, []

#print Ne
for s, c in zip(set(S), ['b', 'r']):
    cmap[s] = c
    hdl +=[mpatches.Patch(color = c, label = s)]

c = []
for s in S:
    c +=[cmap[s]]

RMSE = np.sqrt(sum((Ne-Qe)** 2) / len(Ne - Qe))

(mu, sigma) = norm.fit(Ne- Qe)

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
ax0.plot([min(Qe), 0], [0,0], 'k--', lw =2)
ax0.scatter(Qe, Ne-Qe, marker = 'o', color = c)
ax0.text(min(Qe) + 0.1, 0.14,
         'RMSE: {0:1.3f}'.format(RMSE),
         fontsize = 12, va = 'top', ha = 'left')
ax0.set_xlim(min(Qe), 0)
ax0.set_ylim(-0.05, 0.05)
ax0.set_xlabel('DFT potential energy (eV/atom)')
ax0.set_ylabel('Rsidual error (eV/atom)')
ax0.legend(loc = 'best', handles =hdl, fontsize = 8, frameon = False)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(Ne-Qe, 50,
                            range = (-0.05, 0.05),
                            weights = np.ones_like(Ne-Qe)/ len(Ne),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.05, 0.142, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.05, 0.122, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.05, 0.05)
ax1.set_xlim(0, 0.3)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
plt.tight_layout(w_pad = -0.5)

#plt.savefig('./figures/eos-residual-6.png')
plt.show()

#+END_SRC

#+RESULTS:

*** surface residual
#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db6/data.db')

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
E, nE, var, ind = [], [], [], []
#for j, d in enumerate(db.select(['order=md2','structure=surface'])):# dbkey=0
#for j, d in enumerate(db.select(['v_a=0_20'])):# dbkey=0
#for j, d in enumerate(db.select(['type=vacancy', 'structure=surface'])):# dbkey=0
for j, d in enumerate(db.select(['structure=surface', 'type=vacancy', 'supercell=22'])):
    E += [d.energy / d.natoms]
    nE += [d.NN18/ d.natoms]
    var += [j]
    ind += [d.train_set]

E = np.array(E)
nE = np.array(nE)
res = np.array(nE) - np.array(E)
mask = np.array(ind)
valid = np.ma.masked_array(res, mask)
train = np.ma.masked_array(res, ~mask)
vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))

ax0.text(380, -0.048,
           'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
           color='b', ha='left')
ax0.text(270, -0.055,
           'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
           color='r', ha='left')

ax0.scatter(var, train, color='b')
ax0.scatter(var, valid, color='r')
ax0.plot([min(var), max(var)], [0, 0], 'k--')
ax0.set_xlim(min(var), max(var))
ax0.set_ylim(-0.015, 0.015)

ax0.set_xlabel('Calculation ID')
ax0.set_title('8-15-15-1 framework')


(mu, sigma) = norm.fit(nE - E)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(nE-E, 50,
                            range = (-0.05, 0.05),
                            weights = np.ones_like(nE-E)/ len(nE),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.01, 0.04, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.01, 0.03, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.05, 0.05)
ax1.set_xlim(0, 0.20)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
ax1.set_title('Error Distribution')
plt.tight_layout(w_pad = -0.5)
#plt.savefig('./figures/surf-error-distribution-6.png')
plt.show()
#+END_SRC

#+RESULTS:

[[./figures/surf-error-distribution-6.png]]

#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

from ase.db import connect

db = connect('./database/db6/data.db')
data = db.select(['structure=surface', 'type=vacancy', 'supercell=22'])
for i in data:
    print i.energy, (i.energy-i.NN18)

'''
keys, cnt = {}, 0
for entry in data:
    cnt += 1
    for k, v in entry.key_value_pairs.iteritems():
        
        if k in keys:
            keys[k] += [v]
        else:
            keys[k] = [v]

print ('{0:15s} {1:15s} {2} calculations total'.format('keyword', 'value',cnt))

print('------------------------------------------------------')

for k, v in keys.iteritems():
    vals = list(set(v))
    if len(vals) <= 5:
        val = ", ".join(str(e) for e in vals)
        print('{0:15}: {1}'.format(k, val))

    else:
        val = ", ".join(str(e)[:5] for e in vals[:5])
        print('{0:15s}:{1}, etc...'.format(k, val))
'''
#+END_SRC
#+RESULTS:
#+begin_example
-93.70842946 -0.00365614977676
-93.74332304 -0.00503410764865
-93.75861948 -0.0066648115842
-93.76473653 -0.00896813813645
-93.76797866 -0.0136691968526
-93.77003598 -0.0128265905814
-93.7703986 -0.0121485940649
-93.77205094 -0.0120452096251
-93.77319588 -0.0120497897817
-93.77419085 -0.0125990848719
-93.77457472 -0.0133356778424
-93.77487465 -0.0143918145677
-93.77503405 -0.0156345666371
#+end_example

* Application
** EOS
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState
from ase.db import connect
from amp import Amp
from ase.visualize import view
import os
import json
import time
from ase.units import kJ

db = connect('./database/db8/data.db')

f, ax = plt.subplots(1, 5, figsize = (12, 5))
tag = ['FCC', 'BCC', 'HCP', 'SC', 'Diamond']

for i, key in enumerate(['fcc', 'bcc', 'hcp', 'sc', 'diam']):

    V, Qe, Re, Ne = [], [], [], []

    for d in db.select(['bulk={0}'.format(key), 'type=eos']):
        V += [d.volume / d.natoms]
        Qe += [d.energy / d.natoms]
        Ne += [d.NN18 / d.natoms]

    srt = [j[0] for j in sorted(enumerate(V), key = lambda x:x[1])]
    V = np.array(V)[srt]
    Qe = np.array(Qe)[srt]
    Ne = np.array(Ne)[srt]

    ax[i].plot(V, Qe, 'k-', lw=2, label = 'DFT')
    ax[i].plot(V, Ne, 'r--', lw=2, label = 'Neural')

    if i >0:
        ax[i].set_yticklabels([])

    ax[i].set_ylim(-5.5 , -2)
    ax[i].set_xlim(10, 40)
    ax[i].set_xticks([15, 25, 35])
    ax[i].set_title('{0}'.format(tag[i]))

ax[0].set_ylabel('Potantial energy (eV/atom)')
ax[2].set_xlabel('Volume ($\AA$/atom)')
ax[4].legend(loc = 'best', fontsize = 12)
plt.tight_layout(w_pad=-1.3)
plt.savefig('./figures/eos-NN-8.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/eos-NN-8.png]]

** 211 MD
   
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db8/sur-211')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function
from vasp import Vasp
from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp

calc = Vasp("./../../../NDFT/surface=fcc211/type=relaxation/supercell=33")

atoms = calc.get_atoms()

atoms.set_calculator(Amp(load="./../../../networks/db8/18-18/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(1000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1465074.gilgamesh.cheme.cmu.edu


#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

VASPRC['queue.ppn'] = 4

a0 = 3.939
nrg = []

atoms = fcc211('Pd', size=(3, 3, 5), a = a0,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.z < 10.05 for atom in atoms])
atoms.set_constraint(constraint)
#view (atoms)

calc = Vasp('NDFT/surface=fcc211//type=relaxation/supercell=33',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=2,
            nsw=25,
            atoms=atoms)
		

calc.set_memory()
calc.calculate()
#+END_SRC

** write dbkey9
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

#VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 4
images = Trajectory('./database/db8/sur-211/MD.traj', 'r')

for i in range(25):
    calc = Vasp('NDFT/surface=fcc211/type=md/order=md6/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC


#+BEGIN_SRC python :results output org drawer
from vasp import Vasp

for i in range(25):
    calc = Vasp('NDFT/surface=fcc211/type=md/order=md6/MD={}'.format(i))
    calc.write_db('./database/db9/data.db', parser='=', overwrite=False, keys={'dbkey':9, 'structure':'surface'})
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc211//type=relaxation/supercell=33'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db9/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':9, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

** vac-neb-MD
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db8/sur-vac-image5')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function

from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms
from vasp import Vasp

calc = Vasp("./../../../NDFT/surface=fcc111/type=neb/class=vacancy/image=5")
atoms = calc.get_atoms()

constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(Amp(load="./../../../networks/db8/18-18/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 900 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(500)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1465204.gilgamesh.cheme.cmu.edu

** surface energy
#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc111
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc = Amp(load='./networks/db10/18-18/checkpoint-parameters.json')
#calc = Amp(load='./networks/db6/24-24/checkpoint-parameters.json')

calc1 = Vasp('NDFT/bulk=fcc/type=eos/factor=1.00')
Eb = calc1.potential_energy
atoms=calc1.get_atoms()
atoms.set_calculator(calc)
Ebn = atoms.get_potential_energy()

calc2 = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00')
Es = calc2.potential_energy
atoms = calc2.get_atoms()
cell = atoms.get_cell()
atoms.set_calculator(calc)
nrg = atoms.get_potential_energy()

#print Es
#print nrg
#print (Es-nrg)/30
area = np.cross(cell[0], cell[1])

Ed =  Es - Eb * 20
#En =  nrg - (-5.21529201133) * 20
En =  nrg - (Ebn) * 20

A = 2 * area[-1]
print area
print A
Ed = Ed /A
En = En /A


print Ed
print En


#+END_SRC

#+RESULTS:
: [  0.           0.          26.87401709]
: 53.7480341727
: 0.0827259238117
: 0.0846739464305

#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc111
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc = Amp(load='./networks/db10/18-18/checkpoint-parameters.json')
#calc = Amp(load='./networks/db6/24-24/checkpoint-parameters.json')

calc1 = Vasp('NDFT/bulk=fcc/type=eos/factor=1.00')
Eb = calc1.potential_energy
atoms=calc1.get_atoms()
atoms.set_calculator(calc)
Ebn = atoms.get_potential_energy()

calc2 = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=23/factor=1.00')
Es = calc2.potential_energy
atoms = calc2.get_atoms()
cell = atoms.get_cell()
atoms.set_calculator(calc)
nrg = atoms.get_potential_energy()

#print Es
#print nrg
#print (Es-nrg)/30
area = np.cross(cell[0], cell[1])

Ed =  Es - Eb * 30
#En =  nrg - (-5.21529201133) * 20
En =  nrg - (Ebn) * 30

A = 2 * area[-1]
print area
print A
Ed = Ed /A
En = En /A


print Ed
print En


#+END_SRC

#+RESULTS:
: [  0.          0.         40.3110256]
: 80.6220512034
: 0.0829172085083
: 0.0846646033898


#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp

calc1 = Amp(load = './networks/db8/18-18/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db8/25-25/checkpoint-parameters.json')
traj = Trajectory('./database/db8/sur-211/MD.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
plt.xlim([0,25])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
plt.show()
#plt.savefig('./figures/MD-vac-6.png')
#+END_SRC

#+RESULTS:


* 10th DFT
** 211 vacancy
*** step edge
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

VASPRC['queue.ppn'] = 4

a0 = 3.939
nrg = []

atoms = fcc211('Pd', size=(3, 3, 5), a = a0,  vacuum=6.0)
del atoms[0]
constraint = FixAtoms(mask=[atom.z < 10.05 for atom in atoms])
atoms.set_constraint(constraint)
#view (atoms)

calc = Vasp('NDFT/surface=fcc211/type=vacancy/site=edge',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=2,
            nsw=25,
            atoms=atoms)
		

calc.set_memory()

print calc.potential_energy

#+END_SRC

#+RESULTS:
: -218.14348125

*** terrace
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

VASPRC['queue.ppn'] = 8
VASPRC['queue.walltime'] = '24:00:00'
a0 = 3.939
nrg = []

atoms = fcc211('Pd', size=(3, 3, 5), a = a0,  vacuum=6.0)
del atoms[3]
constraint = FixAtoms(mask=[atom.z < 10.05 for atom in atoms])
atoms.set_constraint(constraint)
#view (atoms)

calc = Vasp('NDFT/surface=fcc211//type=vacancy/site=middle',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=2,
            nsw=50,
            atoms=atoms)
		

calc.set_memory()

print calc.potential_energy

#+END_SRC

#+RESULTS:
: -217.62289697

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

VASPRC['queue.ppn'] = 4

a0 = 3.939
nrg = []

atoms = fcc211('Pd', size=(3, 3, 5), a = a0,  vacuum=6.0)
del atoms[6]
constraint = FixAtoms(mask=[atom.z < 10.05 for atom in atoms])
atoms.set_constraint(constraint)
#view (atoms)

calc = Vasp('NDFT/surface=fcc211//type=vacancy/site=terrace',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=2,
            nsw=25,
            atoms=atoms)
		

calc.set_memory()

print calc.potential_energy
#+END_SRC

#+RESULTS:
: -217.26609212

** adatom
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211, add_adsorbate
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np
from ase import Atom, Atoms

#VASPRC['queue.walltime']='24:00:00'
VASPRC['queue.ppn']=4

a0 = 3.939
slab = fcc211('Pd', size=(3, 3, 5), a = 3.939, vacuum = 6.0)
p = slab.positions

pstep = (p[0] + p[1] + p[16]+2*a0)/3.0 + [1, 0, -0.5]
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(pstep)

adatom = slab + add
constraint = FixAtoms(mask=[atom.z < 10.05  for atom in adatom])
adatom.set_constraint(constraint)

view(adatom)
'''
calc = Vasp('NDFT/surface=fcc211/type=adatom/site=edge',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=50,
            atoms=adatom)

calc.set_memory()
nrg = calc.potential_energy
'''
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211, add_adsorbate
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np
from ase import Atom, Atoms

#VASPRC['queue.walltime']='24:00:00'
VASPRC['queue.ppn']=4

a0 = 3.939
slab = fcc211('Pd', size=(3, 3, 5), a = 3.939, vacuum = 6.0)
p = slab.positions

pstep = (p[0] + p[1] + p[16]+2*a0)/3.0 + [1, 0, 0]
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(pstep)

adatom = slab + add
constraint = FixAtoms(mask=[atom.tag > 0  for atom in adatom])
adatom.set_constraint(constraint)

view(adatom)


#+END_SRC

[ ] the surface energy of the 211 surface 
[ ] adatom diffusion along the step, and away from the step 
[ ] vacancy formation in the step 
[ ] vacancy diffusion along the step, and into the terrace.

site=1
#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211, add_adsorbate
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np
from ase import Atom, Atoms

#VASPRC['queue.walltime']='24:00:00'
VASPRC['queue.ppn']=4

a0 = 3.939
slab = fcc211('Pd', size=(3, 3, 5), a = 3.939, vacuum = 6.0)
p = slab.positions
#view(slab)

pstep = (p[0] + p[1] + p[4])/3.0 + [0, 0, 1.9]
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(pstep)

adatom = slab + add
constraint = FixAtoms(mask=[atom.z < 10.05  for atom in adatom])
adatom.set_constraint(constraint)

#view(adatom)


calc = Vasp('NDFT/surface=fcc211/type=adatom/site=1',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=2,
            nsw=50,
            atoms=adatom)
		
calc.set_memory()

calc.calculate()

#+END_SRC

#+RESULTS:
:RESULTS:
/home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=adatom/site=1 submitted: 1465986.gilgamesh.cheme.cmu.edu
:END:

site=2 
#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211, add_adsorbate
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np
from ase import Atom, Atoms

#VASPRC['queue.walltime']='24:00:00'
VASPRC['queue.ppn']=4

a0 = 3.939
slab = fcc211('Pd', size=(3, 3, 5), a = 3.939, vacuum = 6.0)
p = slab.positions
#view(slab)

pstep = (p[0] + p[3] + p[4])/3.0 + [0, 0, 1.9]
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(pstep)

adatom = slab + add
constraint = FixAtoms(mask=[atom.z < 10.05  for atom in adatom])
adatom.set_constraint(constraint)

#view(adatom)


calc = Vasp('NDFT/surface=fcc211/type=adatom/site=2',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=2,
            nsw=50,
            atoms=adatom)
		
calc.set_memory()

calc.calculate()

#+END_SRC

#+RESULTS:
:RESULTS:
/home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=adatom/site=2 submitted: 1465987.gilgamesh.cheme.cmu.edu
:END:

site=3
#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211, add_adsorbate
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np
from ase import Atom, Atoms

#VASPRC['queue.walltime']='24:00:00'
VASPRC['queue.ppn']=4

a0 = 3.939
slab = fcc211('Pd', size=(3, 3, 5), a = 3.939, vacuum = 6.0)
p = slab.positions
#view(slab)

pstep = (p[6] + p[7] + p[4])/3.0 + [0, 0, 1.9]
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(pstep)

adatom = slab + add
constraint = FixAtoms(mask=[atom.z < 10.05  for atom in adatom])
adatom.set_constraint(constraint)

view(adatom)


calc = Vasp('NDFT/surface=fcc211/type=adatom/site=3',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=2,
            nsw=50,
            atoms=adatom)
		
calc.set_memory()

calc.calculate()

#+END_SRC

site=4
#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211, add_adsorbate
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np
from ase import Atom, Atoms

#VASPRC['queue.walltime']='24:00:00'
VASPRC['queue.ppn']=4

a0 = 3.939
slab = fcc211('Pd', size=(3, 3, 5), a = 3.939, vacuum = 6.0)
p = slab.positions
#view(slab)

pstep = (p[3] + p[6] + p[4])/3.0 + [0, 0, 1.9]
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(pstep)

adatom = slab + add
constraint = FixAtoms(mask=[atom.z < 10.05  for atom in adatom])
adatom.set_constraint(constraint)

#view(adatom)


calc = Vasp('NDFT/surface=fcc211/type=adatom/site=4',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=2,
            nsw=50,
            atoms=adatom)
		
calc.set_memory()

calc.calculate()

#+END_SRC

#+RESULTS:
:RESULTS:
/home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=adatom/site=4 submitted: 1465989.gilgamesh.cheme.cmu.edu
:END:

*** fixed slabs

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211, add_adsorbate
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np
from ase import Atom, Atoms

#VASPRC['queue.walltime']='24:00:00'
VASPRC['queue.ppn']=4

a0 = 3.939
slab = Vasp('NDFT/surface=fcc211/type=relaxation/supercell=33').get_atoms()
p = slab.positions

pstep = (p[0] + p[1] + p[16]+2*a0)/3.0 + [1, 0, -0.5]
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(pstep)

constraint = FixAtoms(mask=[atom for atom in slab])
adatom = slab + add
adatom.set_constraint(constraint)

view(adatom)

calc = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=50,
            atoms=adatom)

calc.set_memory()
nrg = calc.potential_energy

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211, add_adsorbate
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np
from ase import Atom, Atoms

#VASPRC['queue.walltime']='24:00:00'
VASPRC['queue.ppn']=4

a0 = 3.939
slab = Vasp('NDFT/surface=fcc211/type=relaxation/supercell=33').get_atoms()
p = slab.positions

pstep = (p[0] + p[1] + p[16]+[2*a0, 0, 0])/3.0 + [1, 0, 2]
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(pstep)

constraint = FixAtoms(mask=[atom for atom in slab])
adatom = slab + add
adatom.set_constraint(constraint)

view(adatom)
'''
calc = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge0',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=50,
            atoms=adatom)

calc.set_memory()
nrg = calc.potential_energy
'''
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=test/fix=True/site=edge0 submitted: 1466653.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=test/fix=True/site=edge0 Queued: 1466653.gilgamesh.cheme.cmu.edu

site=1
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211, add_adsorbate
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np
from ase import Atom, Atoms

#VASPRC['queue.walltime']='24:00:00'
VASPRC['queue.ppn']=4

a0 = 3.939
slab = Vasp('NDFT/surface=fcc211/type=relaxation/supercell=33').get_atoms()
p = slab.positions

pstep = (p[0] + p[1] + p[4])/3.0 + [0, 0, 1.9]
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(pstep)

constraint = FixAtoms(mask=[atom for atom in slab])
adatom = slab + add
adatom.set_constraint(constraint)

view(adatom)
'''
calc = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge1',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=50,
            atoms=adatom)

calc.set_memory()
nrg = calc.potential_energy
'''
#+END_SRC

#+RESULTS:


site=2 
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211, add_adsorbate
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np
from ase import Atom, Atoms

#VASPRC['queue.walltime']='24:00:00'
VASPRC['queue.ppn']=4

a0 = 3.939
slab = Vasp('NDFT/surface=fcc211/type=relaxation/supercell=33').get_atoms()
p = slab.positions

pstep = (p[0] + p[3] + p[4])/3.0 + [0, 0, 1.9]
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(pstep)

constraint = FixAtoms(mask=[atom for atom in slab])
adatom = slab + add
adatom.set_constraint(constraint)

view(adatom)
'''
calc = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge2',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=50,
            atoms=adatom)

calc.set_memory()
nrg = calc.potential_energy
'''
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=test/fix=True/site=edge2 submitted: 1466655.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=test/fix=True/site=edge2 Queued: 1466655.gilgamesh.cheme.cmu.edu

site=3
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211, add_adsorbate
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np
from ase import Atom, Atoms

#VASPRC['queue.walltime']='24:00:00'
VASPRC['queue.ppn']=4

a0 = 3.939
slab = Vasp('NDFT/surface=fcc211/type=relaxation/supercell=33').get_atoms()
p = slab.positions

pstep = (p[6] + p[7] + p[4])/3.0 + [0, 0, 1.9]
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(pstep)

constraint = FixAtoms(mask=[atom for atom in slab])
adatom = slab + add
adatom.set_constraint(constraint)

#view(adatom)

calc = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge3',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=50,
            atoms=adatom)

calc.set_memory()
nrg = calc.potential_energy

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=test/fix=True/site=edge3 submitted: 1466656.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=test/fix=True/site=edge3 Queued: 1466656.gilgamesh.cheme.cmu.edu

site=4

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211, add_adsorbate
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np
from ase import Atom, Atoms

#VASPRC['queue.walltime']='24:00:00'
VASPRC['queue.ppn']=4

a0 = 3.939
slab = Vasp('NDFT/surface=fcc211/type=relaxation/supercell=33').get_atoms()
p = slab.positions

pstep = (p[6] + p[3] + p[4])/3.0 + [0, 0, 1.9]
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(pstep)

constraint = FixAtoms(mask=[atom for atom in slab])
adatom = slab + add
adatom.set_constraint(constraint)

#view(adatom)

calc = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge4',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=50,
            atoms=adatom)

calc.set_memory()
nrg = calc.potential_energy

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=test/fix=True/site=edge4 submitted: 1466657.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=test/fix=True/site=edge4 Queued: 1466657.gilgamesh.cheme.cmu.edu

** neb
*** vacancy
**** s-s
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

VASPRC['queue.ppn'] = 8
VASPRC['queue.walltime']= '24:00:00'
a0 = 3.939
nrg = []

atoms = fcc211('Pd', size=(3, 3, 5), a = a0,  vacuum=6.0)

del atoms[1]
#atoms.translate([0.5* a0, 0, 0])
#print atoms.get_cell()

atoms.wrap(center=(0.8, 0.5, 0.5))
constraint = FixAtoms(mask=[atom.z < 10.05 for atom in atoms])
atoms.set_constraint(constraint)
view (atoms)
'''
calc = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/position=step1',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=2,
            nsw=25,
            atoms=atoms)
		

calc.set_memory()

print calc.potential_energy
'''
#+END_SRC

#+RESULTS:
: [[  6.82254813   0.           0.        ]
:  [  0.           8.35588083   0.        ]
:  [  0.           0.          23.25663011]]

#+BEGIN_SRC python :results output org drawer
from vasp import Vasp

calc = Vasp('NDFT/surface=fcc211/type=vacancy/site=edge')
calc.clone('NDFT/surface=fcc211/type=neb/class=vacancy/position=step0')
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt

VASPRC['queue.mem'] = '8GB'
c0 = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/position=step0')
ini = c0.get_atoms()

c1 = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/position=step1')
fin = c1.get_atoms()

images = [ini]
images += [ini.copy() for i in range(3)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/s-s-neb',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

#calc.set_memory()
images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/s-s-NEB.png')
#+END_SRC

#+RESULTS:
:RESULTS:
/home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=neb/class=vacancy/s-s-neb submitted: 1475951.gilgamesh.cheme.cmu.edu
:END:

[[figures/s-s-NEB.png]]

***** test
 #+BEGIN_SRC python :results output org drawer
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt

VASPRC['queue.mem'] = '8GB'
c0 = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/position=step0')
ini = c0.get_atoms()

c1 = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/position=step1')
fin = c1.get_atoms()

from ase.visualize import view

images = [ini]
images += [ini.copy() for i in range(3)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc211/type=test/class=vacancy/s-s-test',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

#calc.set_memory()
images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/s-s-NEB.png')

#+END_SRC

 #+RESULTS:
 :RESULTS:
:END:

[[./figures/s-s-NEB.png]]

 #+BEGIN_SRC python :results output org drawer
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt

VASPRC['queue.mem'] = '8GB'
c0 = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/position=step0')
ini = c0.get_atoms()

c1 = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/position=step1')
fin = c1.get_atoms()

images = [ini]
images += [ini.copy() for i in range(3)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc211/type=test/class=vacancy/s-t-neb',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

#calc.set_memory()
images, energies = calc.get_neb()

calc.stop_if(None in energies)


#+END_SRC

* Training
#+BEGIN_SRC python
from ase.db import connect
import os
import random
import numpy as np

db = connect('./database/db9/data.db')

n = db.count()
n_train = int(round(n * 0.9))

n_ids =  np.array(range(n)) + 1

# This will sudo-randomly select 10% of the calculations
# Which is useful for reproducing our results.
random.seed(256)
train_samples = random.sample(n_ids, n_train)
valid_samples = set(n_ids) - set(train_samples)

db.update(list(train_samples), train_set=True)
db.update(list(valid_samples), train_set=False)

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()
#20, 24, 25
for n in [15, 18, 20, 24, 25]:

    wd = 'networks/db9/{0}-{0}/'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)
    os.chdir(wd)

    run_amp = """#!/usr/bin/env python
import os
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing

db = connect('../../../database/db9/data.db')
wd = os.getcwd()
images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(
           label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=16,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
""".format(n)

    cmd = '''#!/bin/bash
#PBS -N {}
#PBS -l nodes=1:ppn=8
#PBS -l walltime=168:00:00
#PBS -l mem=30GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

    with open('submit.py', 'w') as f:
        f.write(run_amp)
    os.chmod('submit.py', 0777)

    with open('submit.sh', 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', 'submit.sh'])
    time.sleep(2)
    os.unlink('submit.sh')
    os.chdir(home)
#+END_SRC

* Application
** MD prediction
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp

calc1 = Amp(load = './networks/db9/15-15/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db9/20-20/checkpoint-parameters.json')
traj = Trajectory('./database/db9/211-vac-terrace/MD.traj')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
#plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
plt.show()
#plt.savefig('./figures/MD225-5.png')
#+END_SRC

#+RESULTS:

** NN NEB
*** Bulk-vacancy-diffusion
#+BEGIN_SRC python :results output org drawer
from ase import io
from ase.neb import NEB
from ase.optimize import MDMin
from vasp import Vasp
from amp import Amp

calc = Amp(load = 'networks/db9/15-15/checkpoint-parameters.json')
# Read initial and final states:
initial = Vasp('./NDFT/bulk=fcc/type=neb/supercell=222/neb-initial').get_atoms()
final = Vasp('./NDFT/bulk=fcc/type=neb/supercell=222/neb-final').get_atoms()
# Make a band consisting of 5 images:
images = [initial]
images += [initial.copy() for i in range(7)]
images += [final]
neb = NEB(images)
# Interpolate linearly the potisions of the three middle images:
neb.interpolate()
# Set calculators:
for image in images:
    image.set_calculator(calc)
# Optimize:
optimizer = MDMin(neb, trajectory='A2B.traj')
optimizer.run(fmax=0.04)
#+END_SRC

#+RESULTS:
:RESULTS:
MDMin:   0  10:31:12      -33.950470       1.9210
MDMin:   1  10:31:29      -34.215823       1.5221
MDMin:   2  10:31:45      -34.581072       0.4698
MDMin:   3  10:32:02      -34.672503       0.2331
MDMin:   4  10:32:18      -34.685577       0.3322
MDMin:   5  10:32:35      -34.688650       0.2356
MDMin:   6  10:32:51      -34.692385       0.1831
MDMin:   7  10:33:08      -34.693023       0.0903
MDMin:   8  10:33:24      -34.693461       0.0675
MDMin:   9  10:33:41      -34.693668       0.0706
MDMin:  10  10:33:58      -34.693727       0.0917
MDMin:  11  10:34:14      -34.693682       0.1640
MDMin:  12  10:34:31      -34.693727       0.0964
MDMin:  13  10:34:48      -34.693742       0.0691
MDMin:  14  10:35:04      -34.693749       0.0439
MDMin:  15  10:35:21      -34.693749       0.0445
MDMin:  16  10:35:37      -34.693749       0.0385
:END:


#+BEGIN_SRC python :results output org drawer
from ase.io.trajectory import Trajectory
from amp import Amp
from ase.io import read
import matplotlib.pyplot as plt
from vasp import Vasp
import numpy as np
from scipy.interpolate import interp1d

#images = Trajectory('A2B.traj')
images = read('trajectory/bulk-vac.traj@-9:')
calc1 = Amp(load = './networks/db10/18-18/checkpoint-parameters.json')

E, En = [], []

for image in images:
    image.set_calculator(calc1)
    En.append(image.get_potential_energy()/len(image))


for i in range (9):
    calc = Vasp('./NDFT/bulk=fcc/type=neb/supercell=222/image={0}'.format(i))
    atoms = calc.get_atoms()
    E += [calc.potential_energy/len(atoms)]

E = np.array(E)
En = np.array(En)
E = E- E[0]
En = En-En[0]
x = range(len(E))
xarray = np.linspace(0, len(E))
f1 = interp1d(x, E, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(x, E, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
plt.savefig('figures/bulk-vac-nn.png')
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

[[./figures/bulk-vac-nn.png]]

*** surface vacancy
#+BEGIN_SRC python :
from ase import io
from ase.neb import NEB
from ase.optimize import MDMin
from vasp import Vasp
from amp import Amp

calc = Amp(load = 'networks/db9/15-15/checkpoint-parameters.json')
# Read initial and final states:
initial = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/neb-initial').get_atoms()
final = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/neb-end').get_atoms()
# Make a band consisting of 5 images:
images = [initial]
images += [initial.copy() for i in range(7)]
images += [final]
neb = NEB(images)
# Interpolate linearly the potisions of the three middle images:
neb.interpolate()
# Set calculators:
for image in images:
    image.set_calculator(calc)
# Optimize:
optimizer = MDMin(neb, trajectory='NDFT/surface=fcc111/type=neb/class=vacancy/A2B.traj')
optimizer.run(fmax=0.04)
#+END_SRC

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()


run_md = '''#!/usr/bin/env python
from ase import io
from ase.neb import NEB
from ase.optimize import MDMin
from vasp import Vasp
from amp import Amp

calc = Amp(load = "networks/db10/15-15/checkpoint-parameters.json")

initial = Vasp("./NDFT/surface=fcc111/type=neb/class=vacancy/neb-initial").get_atoms()
final = Vasp("./NDFT/surface=fcc111/type=neb/class=vacancy/neb-end").get_atoms()

images = [initial]
images += [initial.copy() for i in range(7)]
images += [final]
neb = NEB(images)

neb.interpolate()

for image in images:
    image.set_calculator(calc)

optimizer = MDMin(neb, trajectory="trajectory/db10/surf-vac.traj")
optimizer.run(fmax=0.04)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('sur-vac')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')

#+END_SRC

#+RESULTS:
: 1471456.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python :results output org drawer
from ase.io.trajectory import Trajectory
from amp import Amp
from ase.io import read
import matplotlib.pyplot as plt
from vasp import Vasp
import numpy as np
from scipy.interpolate import interp1d

#images = Trajectory('A2B.traj')
images = read('trajectory/db10/surf-vac.traj@-9:')
calc1 = Amp(load = './networks/db10/18-18/checkpoint-parameters.json')

E, En, Edft = [], [], []

for image in images:
    image.set_calculator(calc1)
    En.append(image.get_potential_energy()/len(image))


for i in range (9):
    calc = Vasp('./NDFT/surface=fcc111/type=neb/class=vacancy/image={0}'.format(i))
    atoms = calc.get_atoms()
    E += [calc.potential_energy/len(atoms)]
'''
for i in range (9):
    calc = Vasp('NDFT/surface=fcc111/type=neb_nn/class=surf_vac/image={}'.format(i))
    Edft += [calc.potential_energy/len(atoms)]
'''
E = np.array(E)
En = np.array(En)
#Edft = np.array(Edft)
E = E- E[0]
En = En-En[0]
#Edft = Edft- Edft[0]
x = range(len(E))
xarray = np.linspace(0, len(E))
f1 = interp1d(x, E, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(x, E, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
#plt.plot(x, Edft, 'ko')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
#plt.show()
plt.savefig('figures/surf-vac-nn.png')
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

[[./figures/surf-vac-nn.png]]

**** DFT
#+BEGIN_SRC python :results output org drawer
from ase.io import read
from vasp import Vasp
from vasp.vasprc import VASPRC
#VASPRC['queue.walltime']= '24:00:00'
VASPRC['queue.ppn'] = 4
images = read('trajectory/surf-vac.traj@-9:')
for i in range(9):
    calc = Vasp('NDFT/surface=fcc111/type=neb_nn/class=surf-vac/image={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC

*** surface adatom
**** top-fcc
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()


run_md = '''#!/usr/bin/env python
from ase import io
from ase.neb import NEB
from ase.optimize import MDMin
from vasp import Vasp
from amp import Amp

calc = Amp(load = "networks/db9/15-15/checkpoint-parameters.json")

initial = Vasp("NDFT/surface=fcc111/type=neb/fixed=True/position=top").get_atoms()
final = Vasp("NDFT/surface=fcc111/type=neb/fixed=True/position=fcc").get_atoms()

images = [initial]
images += [initial.copy() for i in range(7)]
images += [final]
neb = NEB(images)

neb.interpolate()

for image in images:
    image.set_calculator(calc)

optimizer = MDMin(neb, trajectory="trajectory/top-fcc.traj")
optimizer.run(fmax=0.04)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('top-fcc')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')

#+END_SRC

#+RESULTS:
: 1467750.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python :results output org drawer
from ase.io.trajectory import Trajectory
from amp import Amp
from ase.io import read
import matplotlib.pyplot as plt
from vasp import Vasp
import numpy as np
from scipy.interpolate import interp1d

#images = Trajectory('A2B.traj')
images = read('trajectory/top-fcc.traj@-9:')
calc1 = Amp(load = './networks/db9/25-25/checkpoint-parameters.json')

E, En = [], []

for image in images:
    image.set_calculator(calc1)
    En.append(image.get_potential_energy()/len(image))


for i in range (9):
    calc = Vasp('./NDFT/surface=fcc111/type=neb/fixed=True/class=top_fcc/image={0}'.format(i))
    atoms = calc.get_atoms()
    E += [calc.potential_energy/len(atoms)]

E = np.array(E)
En = np.array(En)
#E = E- E[0]
#En = En-En[0]
x = range(len(E))
xarray = np.linspace(0, len(E))
f1 = interp1d(x, E, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(x, E, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
#plt.show()
plt.savefig('figures/top-fcc-nn.png')
#+END_SRC

[[./figures/top-fcc-nn.png]]
**** fcc-hcp
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()


run_md = '''#!/usr/bin/env python
from ase import io
from ase.neb import NEB
from ase.optimize import MDMin
from vasp import Vasp
from amp import Amp

calc = Amp(load = "networks/db9/15-15/checkpoint-parameters.json")

initial = Vasp("NDFT/surface=fcc111/type=neb/fixed=True/position=fcc").get_atoms()
final = Vasp("NDFT/surface=fcc111/type=neb/fixed=True/position=hcp").get_atoms()

images = [initial]
images += [initial.copy() for i in range(7)]
images += [final]
neb = NEB(images)

neb.interpolate()

for image in images:
    image.set_calculator(calc)

optimizer = MDMin(neb, trajectory="trajectory/fcc-hcp.traj")
optimizer.run(fmax=0.04)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('fcc-hcp')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')

#+END_SRC

#+RESULTS:
: 1467751.gilgamesh.cheme.cmu.edu
#+BEGIN_SRC python :results output org drawer
from ase.io.trajectory import Trajectory
from amp import Amp
from ase.io import read
import matplotlib.pyplot as plt
from vasp import Vasp
import numpy as np
from scipy.interpolate import interp1d

#images = Trajectory('A2B.traj')
images = read('trajectory/fcc-hcp.traj@-9:')
calc1 = Amp(load = './networks/db9/25-25/checkpoint-parameters.json')

E, En = [], []

for image in images:
    image.set_calculator(calc1)
    En.append(image.get_potential_energy()/len(image))


for i in range (9):
    calc = Vasp('./NDFT/surface=fcc111/type=neb/fixed=True/class=fcc_hcp/image={0}'.format(i))
    atoms = calc.get_atoms()
    E += [calc.potential_energy/len(atoms)]

E = np.array(E)
En = np.array(En)
#E = E- E[0]
#En = En-En[0]
x = range(len(E))
xarray = np.linspace(0, len(E))
f1 = interp1d(x, E, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(x, E, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
#plt.show()
plt.savefig('figures/fcc-hcp-nn.png')
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

[[./figures/fcc-hcp-nn.png]]
**** hcp-top
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()


run_md = '''#!/usr/bin/env python
from ase import io
from ase.neb import NEB
from ase.optimize import MDMin
from vasp import Vasp
from amp import Amp

calc = Amp(load = "networks/db9/15-15/checkpoint-parameters.json")

initial = Vasp("NDFT/surface=fcc111/type=neb/fixed=True/position=hcp").get_atoms()
final = Vasp("NDFT/surface=fcc111/type=neb/fixed=True/position=top").get_atoms()

images = [initial]
images += [initial.copy() for i in range(7)]
images += [final]
neb = NEB(images)

neb.interpolate()

for image in images:
    image.set_calculator(calc)

optimizer = MDMin(neb, trajectory="trajectory/hcp-top.traj")
optimizer.run(fmax=0.04)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('hcp-top')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')

#+END_SRC

#+RESULTS:
: 1467752.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python :results output org drawer
from ase.io.trajectory import Trajectory
from amp import Amp
from ase.io import read
import matplotlib.pyplot as plt
from vasp import Vasp
import numpy as np
from scipy.interpolate import interp1d

#images = Trajectory('A2B.traj')
images = read('trajectory/hcp-top.traj@-9:')
calc1 = Amp(load = './networks/db9/25-25/checkpoint-parameters.json')

E, En = [], []

for image in images:
    image.set_calculator(calc1)
    En.append(image.get_potential_energy()/len(image))


for i in range (9):
    calc = Vasp('./NDFT/surface=fcc111/type=neb/fixed=True/class=hcp_top/image={0}'.format(i))
    atoms = calc.get_atoms()
    E += [calc.potential_energy/len(atoms)]

E = np.array(E)
En = np.array(En)
#E = E- E[0]
#En = En-En[0]
x = range(len(E))
xarray = np.linspace(0, len(E))
f1 = interp1d(x, E, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(x, E, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
#plt.show()
plt.savefig('figures/hcp-top-nn.png')
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

[[./figures/hcp-top-nn.png]]

**** all
#+BEGIN_SRC python :results output org drawer
from ase.io.trajectory import Trajectory
from amp import Amp
from ase.io import read
import matplotlib.pyplot as plt
from vasp import Vasp
import numpy as np
from scipy.interpolate import interp1d

lib = ['top-fcc', 'fcc-hcp', 'hcp-top']

calc1 = Amp(load = './networks/db9/25-25/checkpoint-parameters.json')

En = []
for i in lib:
    images = read('trajectory/{0}.traj@-9:'.format(i))
    for image in images:
        image.set_calculator(calc1)
	En.append(image.get_potential_energy())

print En

#+END_SRC

#+RESULTS:
:RESULTS:
[-103.21938589255454, -103.24252883923373, -103.30799258229727, -103.41342542547983, -103.55084529829618, -103.69945464540841, -103.82769329889614, -103.90087763596894, -103.93995282735192, -103.93995282735192, -103.8933891741462, -103.87094455256694, -103.84740905494291, -103.83831231666186, -103.84922991759119, -103.87502088225781, -103.90025260139332, -103.94599636486454, -103.94599636486454, -103.90580800589039, -103.82868628939734, -103.6984685379997, -103.54950649845996, -103.41243402666349, -103.30743332160347, -103.24227336246221, -103.21938589255454]
:END:

#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
from matplotlib.offsetbox import OffsetImage, AnnotationBbox
import matplotlib.image as mpimg
import os

nrg = np.array([-103.16314489, -103.17362203, -103.22147716000001, -103.32938334000001, -103.48398825, -103.66603531, -103.84634143, -103.98241757, -104.02334307, -103.99930865, -103.93616107, -103.88095009, -103.85664787, -103.86981663, -103.91413568999999, -103.96879078000001, -103.98963043000001, -103.95344617000001, -103.82724601, -103.65909859999999, -103.48889736, -103.34291469, -103.23595949, -103.17862415, -103.16314489])

En = np.array([-103.21938589255454, -103.24252883923373, -103.30799258229727, -103.41342542547983, -103.55084529829618, -103.69945464540841, -103.82769329889614, -103.90087763596894, -103.93995282735192, -103.8933891741462, -103.87094455256694, -103.84740905494291, -103.83831231666186, -103.84922991759119, -103.87502088225781, -103.90025260139332, -103.94599636486454, -103.90580800589039, -103.82868628939734, -103.6984685379997, -103.54950649845996, -103.41243402666349, -103.30743332160347, -103.24227336246221, -103.21938589255454])
#nrg = nrg - nrg[0]
#En = En- En[0]
nrg = nrg/21
En = En/21

nrg = nrg - nrg[0]
En = En - En[0]
x = range(len(nrg))
xarray = np.linspace(0, len(nrg))
f1 = interp1d(x, nrg, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
fig = plt.figure(figsize=(6,4))
ax = fig.add_subplot(111)


image = mpimg.imread('./figures/surface.png')
imagebox = OffsetImage(image, zoom=0.3)

ax.add_artist(AnnotationBbox(imagebox,
                             xy=(12, -0.01),
                            # xybox=(6, -4.92),
                             pad = -0.2))
plt.plot(range(len(nrg)), nrg, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlim([-1, 25])
plt.xticks([0, 8, 12, 16, 24], ['top', 'fcc', 'bridge', 'hcp', 'top'])
#plt.xticklabels()
#plt.yticks([-4.95, -4.94, -4.93, -4.92, -4.91])
plt.minorticks_on()
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 4)
plt.tight_layout()
plt.show()
#plt.savefig('./figures/adatom-NEB-8.png')
#+END_SRC

#+RESULTS:

*** 211 surface neb
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()


run_md = '''#!/usr/bin/env python
from ase import io
from ase.neb import NEB
from ase.optimize import MDMin
from vasp import Vasp
from amp import Amp

calc = Amp(load = "networks/db10/15-15/checkpoint-parameters.json")

c0 = Vasp("NDFT/surface=fcc211/type=neb/class=vacancy/position=step0")
initial = c0.get_atoms()

c1 = Vasp("NDFT/surface=fcc211/type=neb/class=vacancy/position=step1")
final = c1.get_atoms()


images = [initial]
images += [initial.copy() for i in range(7)]
images += [final]
neb = NEB(images)

neb.interpolate()

for image in images:
    image.set_calculator(calc)

optimizer = MDMin(neb, trajectory="trajectory/db10/211-vac-s-s.traj")
optimizer.run(fmax=0.04)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=168:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('sur-vac')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')

#+END_SRC

#+RESULTS:
: 1474133.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()


run_md = '''#!/usr/bin/env python
from ase import io
from ase.neb import NEB
from ase.optimize import MDMin
from vasp import Vasp
from amp import Amp

calc = Amp(load = "networks/db10/15-15/checkpoint-parameters.json")

c0 = Vasp("NDFT/surface=fcc211/type=neb/class=vacancy/position=step0")
initial = c0.get_atoms()

c1 = Vasp("NDFT/surface=fcc211/type=neb/class=vacancy/position=terrace")
final = c1.get_atoms()


images = [initial]
images += [initial.copy() for i in range(7)]
images += [final]
neb = NEB(images)

neb.interpolate()

for image in images:
    image.set_calculator(calc)

optimizer = MDMin(neb, trajectory="trajectory/db10/211-vac-s-t.traj")
optimizer.run(fmax=0.04)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=168:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('211-vac-s-t')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')

#+END_SRC

#+RESULTS:
: 1474134.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()


run_md = '''#!/usr/bin/env python
from ase import io
from ase.neb import NEB
from ase.optimize import MDMin
from vasp import Vasp
from amp import Amp

calc = Amp(load = "networks/db10/15-15/checkpoint-parameters.json")

c0 = Vasp("NDFT/surface=fcc211/type=test/fix=True/site=edge0")
initial = c0.get_atoms()

c1 = Vasp("NDFT/surface=fcc211/type=test/fix=True/site=edge")
final = c1.get_atoms()


images = [initial]
images += [initial.copy() for i in range(7)]
images += [final]
neb = NEB(images)

neb.interpolate()

for image in images:
    image.set_calculator(calc)

optimizer = MDMin(neb, trajectory="trajectory/db10/211-adatom-s-s.traj")
optimizer.run(fmax=0.04)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=168:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('211-adatom-s-s')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')

#+END_SRC

#+RESULTS:
: 1474135.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()


run_md = '''#!/usr/bin/env python
from ase import io
from ase.neb import NEB
from ase.optimize import MDMin
from vasp import Vasp
from amp import Amp

calc = Amp(load = "networks/db10/15-15/checkpoint-parameters.json")

c0 = Vasp("NDFT/surface=fcc211/type=test/fix=True/site=edge0")
initial = c0.get_atoms()

c1 = Vasp("NDFT/surface=fcc211/type=test/fix=True/site=edge1")
final = c1.get_atoms()


images = [initial]
images += [initial.copy() for i in range(7)]
images += [final]
neb = NEB(images)

neb.interpolate()

for image in images:
    image.set_calculator(calc)

optimizer = MDMin(neb, trajectory="trajectory/db10/211-adatom-s-t.traj")
optimizer.run(fmax=0.04)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=168:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('211-adatom-s-t')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')

#+END_SRC

#+RESULTS:
: 1474136.gilgamesh.cheme.cmu.edu

** DFT for NN configuration
*** vacancy
#+BEGIN_SRC python :results output org drawer
from ase.io import read
from vasp import Vasp
from vasp.vasprc import VASPRC
#VASPRC['queue.walltime']= '24:00:00'
VASPRC['queue.ppn'] = 4
images = read('trajectory/surf-vac.traj@-9:')
for i in range(9):
    calc = Vasp('NDFT/surface=fcc111/type=neb_nn/class=surf_vac/image={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    print calc.potential_energy

#+END_SRC

#+RESULTS:
:RESULTS:
-93.77495035
-93.71576587
-93.52095711
-93.31584005
-93.24061587
-93.32815595
-93.5167769
-93.69999548
-93.77495045
:END:

*** adatom
#+BEGIN_SRC python :results output org drawer
from ase.io import read
from vasp import Vasp
from vasp.vasprc import VASPRC
#VASPRC['queue.walltime']= '24:00:00'
VASPRC['queue.ppn'] = 4
images = read('trajectory/top-fcc.traj@-9:')
E, En = [], []
for i in range(9):
    calc = Vasp('NDFT/surface=fcc111/type=neb_nn/class=top_fcc/image={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
		
    En += [calc.potential_energy]

print En
#+END_SRC

#+RESULTS:
:RESULTS:
[-103.16211359, -103.18393241, -103.24886419, -103.35696775, -103.50295246, -103.67459113, -103.84475487, -103.96816647, -104.02251071]
:END:


#+BEGIN_SRC python :results output org drawer
from ase.io import read
from vasp import Vasp
from vasp.vasprc import VASPRC
#VASPRC['queue.walltime']= '24:00:00'
VASPRC['queue.ppn'] = 4
images = read('trajectory/fcc-hcp.traj@-9:')
for i in range(9):
    calc = Vasp('NDFT/surface=fcc111/type=neb_nn/class=fcc_hcp/image={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])

    print calc.potential_energy
#+END_SRC

#+RESULTS:
:RESULTS:
-104.02251071
-103.96751086
-103.91092401
-103.85843703
-103.83428087
-103.84526191
-103.8855349
-103.93170313
-103.98881616
:END:

#+BEGIN_SRC python :results output org drawer
from ase.io import read
from vasp import Vasp
from vasp.vasprc import VASPRC
#VASPRC['queue.walltime']= '24:00:00'
VASPRC['queue.ppn'] = 4
images = read('trajectory/hcp-top.traj@-9:')
for i in range(9):
    calc = Vasp('NDFT/surface=fcc111/type=neb_nn/class=hcp_top/image={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    print calc.potential_energy
#+END_SRC

#+RESULTS:
:RESULTS:
-103.98881616
-103.93543839
-103.82138607
-103.66081549
-103.49543439
-103.35382704
-103.24803005
-103.18390118
-103.16211359
:END:



* 11th DFT
** MD
#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.ppn'] = 2
images = Trajectory('./database/db9/211-perfect/MD.traj', 'r')

for i in range(25):
    calc = Vasp('NDFT/surface=fcc211/type=md/order=md7/class=perfect/MD={}'.format(i),
                xc='pbe',
                kpts=[5, 5, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC

#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.ppn'] = 4
images = Trajectory('./database/db9/211-vac-step/MD.traj', 'r')

for i in range(25):
    calc = Vasp('NDFT/surface=fcc211/type=md/order=md7/class=vacancy/site=step/MD={}'.format(i),
                xc='pbe',
                kpts=[5, 5, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC

#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.ppn'] = 4
images = Trajectory('./database/db9/211-vac-terrace/MD.traj', 'r')

for i in range(25):
    calc = Vasp('NDFT/surface=fcc211/type=md/order=md7/class=vacancy/site=terrace/MD={}'.format(i),
                xc='pbe',
                kpts=[5, 5, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC

** Relaxed NEB
*** bulk vacancy

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '8GB'
#VASPRC['wall.time'] = '24:00:00'
fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([2, 2, 2])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=neb/relaxed=True/neb-initial',
          xc='pbe',
          kpts=[9, 9, 9],
	  ibrion=2,
	  nsw=20,
          encut=350,
          atoms=ini)

fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=neb/relaxed=True/neb-final',
            xc='pbe',
            kpts=[9, 9, 9],
	    ibrion=2,
	    nsw=20,
            encut=350,
            atoms=fin)

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=neb/relaxed=True/neb',
            xc='pbe',
            kpts=[9, 9, 9],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/relaxed-bulk-NEB.png')
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.675637
:          Iterations: 15
:          Function evaluations: 30


[[./figures/relaxed-bulk-NEB.png]]

** 6*6 211 surface
*** site
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

VASPRC['queue.ppn'] = 8
VASPRC['queue.walltime']= '168:00:00'
a0 = 3.939
nrg = []

atoms = fcc211('Pd', size=(6, 6, 5), a = a0,  vacuum=6.0)
#del atoms[1]
constraint = FixAtoms(mask=[atom.z < 10.05 for atom in atoms])
atoms.set_constraint(constraint)
#view (atoms)

calc = Vasp('NDFT/surface=fcc211/type=test/supercell=66/class=perfect',
            xc='pbe',
            kpts=[1, 1, 1],
            encut=350,
            ibrion=2,
            nsw=25,
            atoms=atoms)
		

calc.set_memory()

print calc.potential_energy

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=test/supercell=66/class=perfect submitted: 1474138.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=test/supercell=66/class=perfect Queued: 1474138.gilgamesh.cheme.cmu.edu
: None

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

VASPRC['queue.ppn'] = 8
VASPRC['queue.walltime']= '168:00:00'
a0 = 3.939
nrg = []

atoms = fcc211('Pd', size=(6, 3, 5), a = a0,  vacuum=6.0)
#del atoms[1]
constraint = FixAtoms(mask=[atom.z < 10.05 for atom in atoms])
atoms.set_constraint(constraint)
#view (atoms)

calc = Vasp('NDFT/surface=fcc211/type=test/supercell=63/class=perfect',
            xc='pbe',
            kpts=[1, 5, 1],
            encut=350,
            ibrion=2,
            nsw=25,
            atoms=atoms)
		

calc.set_memory()

print calc.potential_energy

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=test/supercell=63/class=perfect submitted: 1474142.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=test/supercell=63/class=perfect Queued: 1474142.gilgamesh.cheme.cmu.edu
: None

*** vacancy
**** s-s
site 0
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

VASPRC['queue.ppn'] = 8
VASPRC['queue.walltime']= '168:00:00'
a0 = 3.939
nrg = []

atoms = fcc211('Pd', size=(6, 6, 5), a = a0,  vacuum=6.0)
del atoms[0]
constraint = FixAtoms(mask=[atom.z < 10.05 for atom in atoms])
atoms.set_constraint(constraint)
view (atoms)

calc = Vasp('NDFT/surface=fcc211//type=test/supercell=66/class=vacancy/site=0',
            xc='pbe',
            kpts=[1, 1, 1],
            encut=350,
            ibrion=2,
            nsw=25,
            atoms=atoms)
		

calc.set_memory()

print calc.potential_energy

#+END_SRC

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

VASPRC['queue.ppn'] = 8
VASPRC['queue.walltime']= '168:00:00'
a0 = 3.939
nrg = []

atoms = fcc211('Pd', size=(6, 3, 5), a = a0,  vacuum=6.0)
del atoms[0]
constraint = FixAtoms(mask=[atom.z < 10.05 for atom in atoms])
atoms.set_constraint(constraint)
#view (atoms)

calc = Vasp('NDFT/surface=fcc211//type=test/supercell=63/class=vacancy/site=0',
            xc='pbe',
            kpts=[1, 5, 1],
            encut=350,
            ibrion=2,
            nsw=25,
            atoms=atoms)
		

calc.set_memory()

print calc.potential_energy

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=test/supercell=63/class=vacancy/site=0 submitted: 1474143.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=test/supercell=63/class=vacancy/site=0 Queued: 1474143.gilgamesh.cheme.cmu.edu
: None

site 1
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

VASPRC['queue.ppn'] = 8
VASPRC['queue.walltime']= '168:00:00'
a0 = 3.939
nrg = []

atoms = fcc211('Pd', size=(6, 3, 5), a = a0,  vacuum=6.0)
del atoms[1]
constraint = FixAtoms(mask=[atom.z < 10.05 for atom in atoms])
atoms.set_constraint(constraint)
#view (atoms)

calc = Vasp('NDFT/surface=fcc211//type=test/supercell=66/class=vacancy/site=1',
            xc='pbe',
            kpts=[1, 1, 1],
            encut=350,
            ibrion=2,
            nsw=25,
            atoms=atoms)
		

calc.set_memory()

print calc.potential_energy

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=test/supercell=66/class=vacancy/site=1 submitted: 1474140.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=test/supercell=66/class=vacancy/site=1 Queued: 1474140.gilgamesh.cheme.cmu.edu
: None

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

VASPRC['queue.ppn'] = 8
VASPRC['queue.walltime']= '168:00:00'
a0 = 3.939
nrg = []

atoms = fcc211('Pd', size=(6, 3, 5), a = a0,  vacuum=6.0)
del atoms[1]
constraint = FixAtoms(mask=[atom.z < 10.05 for atom in atoms])
atoms.set_constraint(constraint)
view (atoms)
'''
calc = Vasp('NDFT/surface=fcc211/type=test/supercell=63/class=vacancy/site=1',
            xc='pbe',
            kpts=[1, 5, 1],
            encut=350,
            ibrion=2,
            nsw=25,
            atoms=atoms)
		

calc.set_memory()

print calc.potential_energy
'''
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=test/supercell=63/class=vacancy/site=1 submitted: 1474144.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=test/supercell=63/class=vacancy/site=1 Queued: 1474144.gilgamesh.cheme.cmu.edu
: None


#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

VASPRC['queue.ppn'] = 8

a0 = 3.939
nrg = []

atoms = fcc211('Pd', size=(6, 3, 5), a = a0,  vacuum=6.0)
del atoms[15]
constraint = FixAtoms(mask=[atom.z < 10.05 for atom in atoms])
atoms.set_constraint(constraint)
#view (atoms)

calc = Vasp('NDFT/surface=fcc211/type=test/supercell=63/class=vacancy/site=terrace',
            xc='pbe',
            kpts=[1, 5, 1],
            encut=350,
            ibrion=2,
            nsw=25,
            atoms=atoms)
		

calc.set_memory()

print calc.potential_energy

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=test/supercell=63/class=vacancy/site=terrace submitted: 1474145.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=test/supercell=63/class=vacancy/site=terrace Queued: 1474145.gilgamesh.cheme.cmu.edu
: None

#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt

VASPRC['queue.mem'] = '8GB'
c0 = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/position=step0')
ini = c0.get_atoms()

c1 = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/position=step1')
fin = c1.get_atoms()

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/s-s-neb',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

#calc.set_memory()
images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/s-s-NEB.png')
#+END_SRC

**** s-t
#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt

VASPRC['queue.mem'] = '8GB'
c0 = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/position=step0')
ini = c0.get_atoms()

c1 = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/position=terrace')
fin = c1.get_atoms()

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/s-t-neb',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

#calc.set_memory()
images, energies = calc.get_neb()

#+END_SRC

*** adatom
#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211, add_adsorbate
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np
from ase import Atom, Atoms

#VASPRC['queue.walltime']='24:00:00'
VASPRC['queue.ppn']=8

a0 = 3.939
slab = fcc211('Pd', size=(3, 3, 5), a = 3.939, vacuum = 6.0)
p = slab.positions

pstep = (p[0] + p[1] + p[16]+[3*a0, 0, 0])/3.0 + [-0.5, 0, 2]
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(pstep)

adatom = slab + add
constraint = FixAtoms(mask=[atom.z < 10.05  for atom in adatom])
adatom.set_constraint(constraint)

#view(adatom)

calc = Vasp('NDFT/surface=fcc211/type=test/class=adatom/position=step0',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=2,
            nsw=25,
            atoms=adatom)
		
calc.set_memory()

calc.calculate()

#+END_SRC

#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt

VASPRC['queue.mem'] = '8GB'
c0 = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge0')
ini = c0.get_atoms()

c1 = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge')
fin = c1.get_atoms()

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc211/type=neb/class=adatom/s-s-neb',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

#calc.set_memory()
images, energies = calc.get_neb()

#+END_SRC

**** fixed slab
#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt

VASPRC['queue.mem'] = '8GB'
c0 = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge0')
ini = c0.get_atoms()

c1 = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge')
fin = c1.get_atoms()

images = [ini]
images += [ini.copy() for i in range(9)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc211/type=neb/class=adatom/s-s-neb',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

#calc.set_memory()
images, energies = calc.get_neb()

#+END_SRC

#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt

VASPRC['queue.mem'] = '8GB'
c0 = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge0')
ini = c0.get_atoms()

c1 = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge1')
fin = c1.get_atoms()

images = [ini]
images += [ini.copy() for i in range(9)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc211/type=neb/class=adatom/0-1-neb',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

#calc.set_memory()
images, energies = calc.get_neb()

#+END_SRC

#+RESULTS:
:RESULTS:
:END:

***** test
#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt

VASPRC['queue.mem'] = '8GB'
c0 = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge0')
ini = c0.get_atoms()

c1 = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge1')
fin = c1.get_atoms()

images = [ini]
images += [ini.copy() for i in range(3)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc211/type=test/class=adatom/0-1-neb',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

#calc.set_memory()
images, energies = calc.get_neb()

#+END_SRC

#+RESULTS:
:RESULTS:
/home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=test/class=adatom/0-1-neb submitted: 1469907.gilgamesh.cheme.cmu.edu
:END:

#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
from ase.io import read
from ase.visualize import view

atoms = read('NDFT/surface=fcc211/type=test/class=adatom/0-1-neb/01/CONTCAR')

view(atoms)

#+END_SRC

#+RESULTS:
:RESULTS:
:END:

** shifted
*** vacancy
**** s-s
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
VASPRC['queue.mem'] = '8GB'
c0 = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/position=step0')
ini = c0.get_atoms()
ini.wrap(center=(0.8, 0.5, 0.5))
#view(ini)

c1 = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/position=step1')
fin = c1.get_atoms()
fin.wrap(center=(0.8, 0.5, 0.5))
#view(fin)
images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc211/type=neb/shifted=True/class=vacancy/s-s-neb',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

#calc.set_memory()
images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/s-s-NEB.png')
#+END_SRC

**** s-t
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
VASPRC['queue.mem'] = '8GB'
c0 = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/position=step0')
ini = c0.get_atoms()
ini.wrap(center=(0.8, 0.5, 0.5))
#view(ini)

c1 = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/position=terrace')
fin = c1.get_atoms()
fin.wrap(center=(0.8, 0.5, 0.5))
view(fin)
images = [ini]
images += [ini.copy() for i in range(3)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/s-t-neb',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

#calc.set_memory()
images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/s-s-NEB.png')

#+END_SRC

*** adatom
**** s-s
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
VASPRC['queue.mem'] = '8GB'
c0 = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge0')
ini = c0.get_atoms()
ini.wrap(center=(0.8, 0.5, 0.5))
#view(ini)

c1 = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge')
fin = c1.get_atoms()
fin.wrap(center=(0.8, 0.5, 0.5))
#view(fin)
images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc211/type=neb/shifted=True/class=adatom/s-s-neb',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

#calc.set_memory()
images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/adatom-211-s-s.png')

#+END_SRC



**** 0-4
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
VASPRC['queue.mem'] = '8GB'
c0 = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge0')
ini = c0.get_atoms()
ini.wrap(center=(0.8, 0.5, 0.5))
#view(ini)

c1 = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge4')
fin = c1.get_atoms()
fin.wrap(center=(0.8, 0.5, 0.5))
#view(fin)
images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc211/type=neb/shifted=True/class=adatom/0-4-neb',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

#calc.set_memory()
images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/s-s-NEB.png')

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=neb/shifted=True/class=adatom/0-4-neb submitted: 1474601.gilgamesh.cheme.cmu.edu

** relaxed=False

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

VASPRC['queue.ppn'] = 4
VASPRC['queue.walltime']= '24:00:00'
a0 = 3.939
nrg = []

atoms = fcc211('Pd', size=(3, 3, 5), a = a0,  vacuum=6.0)

del atoms[0]
#atoms.translate([0.5* a0, 0, 0])
#print atoms.get_cell()

atoms.wrap(center=(0.8, 0.5, 0.5))
constraint = FixAtoms(mask=[atom.z < 10.05 for atom in atoms])
atoms.set_constraint(constraint)
#view (atoms)

calc = Vasp('NDFT/surface=fcc211//type=neb/class=vacancy/shifted=True/relaxed=False/position=step0',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=2,
            nsw=0,
            atoms=atoms)
		

calc.set_memory()

print calc.potential_energy

#+END_SRC

#+RESULTS:
: -217.97086824

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

VASPRC['queue.ppn'] = 4
#VASPRC['queue.walltime']= '24:00:00'
a0 = 3.939
nrg = []

atoms = fcc211('Pd', size=(3, 3, 5), a = a0,  vacuum=6.0)

del atoms[1]
#atoms.translate([0.5* a0, 0, 0])
#print atoms.get_cell()

atoms.wrap(center=(0.8, 0.5, 0.5))
constraint = FixAtoms(mask=[atom.z < 10.05 for atom in atoms])
atoms.set_constraint(constraint)
#view (atoms)

calc = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/shifted=True/relaxed=False/position=step1',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=2,
            nsw=0,
            atoms=atoms)
		

calc.set_memory()

print calc.potential_energy

#+END_SRC

#+RESULTS:
: -217.97088498

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

VASPRC['queue.ppn'] = 4
#VASPRC['queue.walltime']= '24:00:00'
a0 = 3.939
nrg = []

atoms = fcc211('Pd', size=(3, 3, 5), a = a0,  vacuum=6.0)

del atoms[6]
#atoms.translate([0.5* a0, 0, 0])
#print atoms.get_cell()

atoms.wrap(center=(0.8, 0.5, 0.5))
constraint = FixAtoms(mask=[atom.z < 10.05 for atom in atoms])
atoms.set_constraint(constraint)
#view (atoms)

calc = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/shifted=True/relaxed=False/position=terrace',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=2,
            nsw=0,
            atoms=atoms)
		

calc.set_memory()

print calc.potential_energy

#+END_SRC

#+RESULTS:
: -217.05307261
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.lattice.surface import fcc211
from ase.constraints import FixAtoms
from ase.visualize import view
import matplotlib.pyplot as plt
import numpy as np

VASPRC['queue.ppn'] = 4
VASPRC['queue.walltime']= '24:00:00'
a0 = 3.939
nrg = []

atoms = fcc211('Pd', size=(3, 3, 5), a = a0,  vacuum=6.0)

del atoms[3]
#atoms.translate([0.5* a0, 0, 0])
#print atoms.get_cell()

atoms.wrap(center=(0.8, 0.5, 0.5))
constraint = FixAtoms(mask=[atom.z < 10.05 for atom in atoms])
atoms.set_constraint(constraint)
#view (atoms)

calc = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/shifted=True/relaxed=False/position=terrace0',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=2,
            nsw=0,
            atoms=atoms)
		

calc.set_memory()

print calc.potential_energy

#+END_SRC

#+RESULTS:


#+BEGIN_SRC python 
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view

VASPRC['queue.mem'] = '8GB'
c0 = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/shifted=True/relaxed=False/position=step0')
ini = c0.get_atoms()
#view(ini)

c1 = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/shifted=True/relaxed=False/position=step1')
fin = c1.get_atoms()
#view(fin)

images = [ini]
images += [ini.copy() for i in range(3)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/shifted=True/relaxed=False/s-s-neb',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

#calc.set_memory()
images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/211-vac-s-s.png')

#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.474199
:          Iterations: 15
:          Function evaluations: 30

[[./figures/211-vac-s-s.png]]


#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d
from amp import Amp
calc0 = Amp(load = './networks/db10/18-18/checkpoint-parameters.json')
calc = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/shifted=True/relaxed=False/s-s-neb')
images, E = calc.get_neb()

En = []
for image in images:
    image.set_calculator(calc0)
    En += [image.get_potential_energy()]

En = np.array(En)
En = En-En[0]
E = np.array(E)
x = range(len(En))
xarray = np.linspace(0, len(En))
f1 = interp1d(x, E, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(x, E, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
#plt.show()
plt.savefig('figures/211-vac-ss.png')
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

[[./figures/211-vac-ss.png]]

** test
#+BEGIN_SRC python :results output org drawer
from vasp import Vasp

calc = Vasp('NDFT/surface=fcc211/type=neb/class=adatom/s-s-neb')

images, energies = calc.get_neb()

#calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/s-s-NEB.png')
#+END_SRC

#+RESULTS:
unfinished.
*** s-s 

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
VASPRC['queue.mem'] = '8GB'
c0 = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge0')
ini = c0.get_atoms()
ini.wrap(center=(0.8, 0.5, 0.5))
#view(ini)

c1 = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge')
fin = c1.get_atoms()
fin.wrap(center=(0.8, 0.5, 0.5))

#view(fin)
images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc211/type=test/shifted=True/class=adatom/s-s-adatom',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

#calc.set_memory()
images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/211-adatom-s-s.png')

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
calc = Vasp('NDFT/surface=fcc211/type=test/shifted=True/class=adatom/s-s-adatom')
#calc.set_memory()
images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/211-adatom-s-s.png')
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

[[./figures/211-adatom-s-s.png]]

*** unfinished neb
**** adatom-0-1
#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
from ase.io import read
from ase.visualize import view
from vasp.vasprc import VASPRC
VASPRC['queue.ppn'] = 4

atoms = read('NDFT/surface=fcc211/type=test/class=adatom/0-1-neb/01/CONTCAR')

calc = Vasp('NDFT/surface=fcc211/type=neb/class=adatom/0-1-neb/image=1',
            xc='pbe',
	    kpts=[5,5,1],
	    encut=350,
	    nsw=0,
	    atoms=atoms)
calc.set_memory
calc.potential_energy

#+END_SRC

#+RESULTS:
:RESULTS:
/home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=neb/class=adatom/0-1-neb/image=1 submitted: 1479055.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=neb/class=adatom/0-1-neb/image=1 Queued: 1479055.gilgamesh.cheme.cmu.edu
:END:

#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
from ase.io import read
from ase.visualize import view
from vasp.vasprc import VASPRC
VASPRC['queue.ppn'] = 4

atoms = read('NDFT/surface=fcc211/type=test/class=adatom/0-1-neb/02/CONTCAR')

calc = Vasp('NDFT/surface=fcc211/type=neb/class=adatom/0-1-neb/image=2',
            xc='pbe',
	    kpts=[5,5,1],
	    encut=350,
	    nsw=0,
	    atoms=atoms)
calc.set_memory
calc.potential_energy

#+END_SRC

#+RESULTS:
:RESULTS:
/home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=neb/class=adatom/0-1-neb/image=2 submitted: 1479056.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=neb/class=adatom/0-1-neb/image=2 Queued: 1479056.gilgamesh.cheme.cmu.edu
:END:

#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
from ase.io import read
from ase.visualize import view
from vasp.vasprc import VASPRC
VASPRC['queue.ppn'] = 4

atoms = read('NDFT/surface=fcc211/type=test/class=adatom/0-1-neb/03/CONTCAR')

calc = Vasp('NDFT/surface=fcc211/type=neb/class=adatom/0-1-neb/image=3',
            xc='pbe',
	    kpts=[5,5,1],
	    encut=350,
	    nsw=0,
	    atoms=atoms)
calc.set_memory
calc.potential_energy

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python 
import  matplotlib.pyplot as plt
from vasp import Vasp
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d

calc1 = Amp(load = './networks/db10/18-18/checkpoint-parameters.json')
E, En = [], []
c0 = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge0')
atoms = c0.get_atoms()
E += [atoms.get_potential_energy()]
atoms.set_calculator(calc1)
En += [atoms.get_potential_energy()]
for i in [1, 2, 3]:

    calc = Vasp('NDFT/surface=fcc211/type=neb/class=adatom/0-1-neb/image={}'.format(i))
    atoms = calc.get_atoms()
    E += [atoms.get_potential_energy()]
    atoms.set_calculator(calc1)
    En += [atoms.get_potential_energy()]
c1 = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge1')
atoms = c1.get_atoms()
E += [atoms.get_potential_energy()]
atoms.set_calculator(calc1)
En += [atoms.get_potential_energy()]

print E
print En
E = np.array(E)
E = E - E[0]
En = np.array(En)
En = En - En[0]
x = range(len(E))
xarray = np.linspace(0, len(E))
f1 = interp1d(x, E, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(range(len(E)), E, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV)')
plt.legend(loc = 'best')
#plt.show()
plt.savefig('figures/211-adatom-0-1.png')
#+END_SRC

#+RESULTS:
: [-228.54180914, -227.68124403, -227.32840538, -227.44861527, -227.81501179]
: [-228.55107967354232, -227.8014000243237, -227.52756570572063, -227.62126873556178, -227.85777441571386]

[[./figures/211-adatom-0-1.png]]

*** finished neb
**** vacancy ss
#+BEGIN_SRC python 
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view

VASPRC['queue.mem'] = '8GB'
c0 = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/shifted=True/relaxed=False/position=step0')
ini = c0.get_atoms()
#view(ini)

c1 = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/shifted=True/relaxed=False/position=step1')
fin = c1.get_atoms()
#view(fin)

images = [ini]
images += [ini.copy() for i in range(3)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/shifted=True/relaxed=False/s-s-neb',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

#calc.set_memory()
images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/211-vac-s-s.png')

#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.474199
:          Iterations: 15
:          Function evaluations: 30

[[./figures/211-vac-s-s.png]]

#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
from ase.io import read
from ase.visualize import view
from vasp.vasprc import VASPRC
VASPRC['queue.ppn'] = 4

iset = ['01', '02', '03']
j = 1
for i in iset:
    atoms = read('NDFT/surface=fcc211/type=neb/class=vacancy/shifted=True/relaxed=False/s-s-neb/{}/CONTCAR'.format(i))

    calc = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/shifted=True/relaxed=False/s-s-neb/image={}'.format(j),
                xc='pbe',
                kpts=[5,5,1],
                encut=350,
                nsw=0,
                atoms=atoms)
    calc.set_memory
    calc.potential_energy
    j += 1

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :results output org drawer
import  matplotlib.pyplot as plt
from vasp import Vasp
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d

calc1 = Amp(load = './networks/db10/18-18/checkpoint-parameters.json') 
E, En = [], []
c0 = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/shifted=True/relaxed=False/position=step0')
atoms = c0.get_atoms()
E += [atoms.get_potential_energy()]
atoms.set_calculator(calc1)
En += [atoms.get_potential_energy()]
for i in [1, 2, 3]:
    calc = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/shifted=True/relaxed=False/s-s-neb/image={}'.format(i))
    atoms = calc.get_atoms()
    E += [atoms.get_potential_energy()]
    atoms.set_calculator(calc1)
    En += [atoms.get_potential_energy()]
c1 = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/shifted=True/relaxed=False/position=step1')
atoms = c1.get_atoms()
E += [atoms.get_potential_energy()]
atoms.set_calculator(calc1)
En += [atoms.get_potential_energy()]

E = np.array(E)
E = E - E[0]
En = np.array(En)
En = En - En[0]
x = range(len(E))
xarray = np.linspace(0, len(E))
f1 = interp1d(x, E, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(range(len(E)), E, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV)')
plt.legend(loc = 'best')
#plt.show()
plt.savefig('figures/211-vac-ss.png')
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

[[./figures/211-vac-ss.png]]

**** vacancy st

#+BEGIN_SRC python 
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view

VASPRC['queue.mem'] = '8GB'
c0 = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/shifted=True/relaxed=False/position=step0')
ini = c0.get_atoms()
#ini.wrap(center=(0.8, 0.5, 0.5))
#view(ini)

c1 = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/shifted=True/relaxed=False/position=terrace0')
fin = c1.get_atoms()
#fin.wrap(center=(0.8, 0.5, 0.5))
#view(fin)

images = [ini]
images += [ini.copy() for i in range(3)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/shifted=True/relaxed=False/s-t-neb',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

#calc.set_memory()
images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/211-vac-s-t.png')

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=neb/class=vacancy/shifted=True/relaxed=False/s-t-neb submitted: 1482949.gilgamesh.cheme.cmu.edu

**** adatom s-s
#+BEGIN_SRC python 
from vasp import Vasp
calc = Vasp('NDFT/surface=fcc211/type=test/shifted=True/class=adatom/s-s-adatom')
#calc.set_memory()
images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/211-adatom-s-s.png')
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python 
from vasp import Vasp
from ase.io import read
from ase.visualize import view
from vasp.vasprc import VASPRC
VASPRC['queue.ppn'] = 4

iset = ['01', '02', '03', '04', '05', '06', '07']
j = 1
for i in iset:
    atoms = read('NDFT/surface=fcc211/type=test/shifted=True/class=adatom/s-s-adatom/{}/CONTCAR'.format(i))

    calc = Vasp('NDFT/surface=fcc211/type=test/shifted=True/class=adatom/s-s-adatom/image={}'.format(j),
    xc='pbe',
    kpts=[5,5,1],
    encut=350,
    nsw=0,
    atoms=atoms)
    calc.set_memory
    calc.potential_energy
    j += 1

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :results output org drawer
import  matplotlib.pyplot as plt
from vasp import Vasp
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d

calc1 = Amp(load = './networks/db10/18-18/checkpoint-parameters.json') 
E, En = [], []
c0 = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge0')
atoms = c0.get_atoms()
E += [atoms.get_potential_energy()]
atoms.set_calculator(calc1)
En += [atoms.get_potential_energy()]
for i in [2, 4, 6]:

    calc = Vasp('NDFT/surface=fcc211/type=test/shifted=True/class=adatom/s-s-adatom/image={}'.format(i))
    atoms = calc.get_atoms()
    E += [atoms.get_potential_energy()]
    atoms.set_calculator(calc1)
    En += [atoms.get_potential_energy()]
c1 = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge')
atoms = c1.get_atoms()
E += [atoms.get_potential_energy()]
atoms.set_calculator(calc1)
En += [atoms.get_potential_energy()]

E = np.array(E)
E = E - E[0]
En = np.array(En)
En = En - En[0]

#E = E[::2]
#En = En[::2]
x = range(len(E))
xarray = np.linspace(0, len(E))
f1 = interp1d(x, E, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(range(len(E)), E, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV)')
plt.legend(loc = 'best')
#plt.show()
plt.savefig('figures/211-adatom-ss.png')
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

[[./figures/211-adatom-ss.png]]
**** adatom 0-4
#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
from ase.io import read
from ase.visualize import view
from vasp.vasprc import VASPRC
VASPRC['queue.ppn'] = 4

atoms = read('NDFT/surface=fcc211/type=neb/shifted=True/class=adatom/0-4-neb/06/CONTCAR')

calc = Vasp('NDFT/surface=fcc211/type=neb/shifted=True/class=adatom/0-4-neb/image=6',
            xc='pbe',
	    kpts=[5,5,1],
	    encut=350,
	    nsw=0,
	    atoms=atoms)
calc.set_memory
calc.potential_energy

#+END_SRC

#+RESULTS:
:RESULTS:
/home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=neb/shifted=True/class=adatom/0-4-neb/image=6 submitted: 1487498.gilgamesh.cheme.cmu.edu
/home-research/tianyug1/Research/Bulk/NDFT/surface=fcc211/type=neb/shifted=True/class=adatom/0-4-neb/image=6 Queued: 1487498.gilgamesh.cheme.cmu.edu
:END:

**** subplot
#+BEGIN_SRC python :results output org drawer
import  matplotlib.pyplot as plt
from vasp import Vasp
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d
plt.figure(figsize=(6,4))
plt.subplot(121)
calc1 = Amp(load = './networks/db10/18-18/checkpoint-parameters.json') 
E, En = [], []
c0 = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/shifted=True/relaxed=False/position=step0')
atoms = c0.get_atoms()
E += [atoms.get_potential_energy()]
atoms.set_calculator(calc1)
En += [atoms.get_potential_energy()]
for i in [1, 2, 3]:
    calc = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/shifted=True/relaxed=False/s-s-neb/image={}'.format(i))
    atoms = calc.get_atoms()
    E += [atoms.get_potential_energy()]
    atoms.set_calculator(calc1)
    En += [atoms.get_potential_energy()]
c1 = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/shifted=True/relaxed=False/position=step1')
atoms = c1.get_atoms()
E += [atoms.get_potential_energy()]
atoms.set_calculator(calc1)
En += [atoms.get_potential_energy()]

E = np.array(E)
E = E - E[0]
En = np.array(En)
En = En - En[0]
x = range(len(E))
xarray = np.linspace(0, len(E))
f1 = interp1d(x, E, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(range(len(E)), E, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xticks([0, 1, 2, 3, 4])
plt.xlabel('Vacancy diffusion')
plt.ylabel('Reference Energy(eV)')
plt.legend(loc = 'best')

plt.subplot(122)
E, En = [], []
c0 = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge0')
atoms = c0.get_atoms()
E += [atoms.get_potential_energy()]
atoms.set_calculator(calc1)
En += [atoms.get_potential_energy()]
for i in [2, 4, 6]:

    calc = Vasp('NDFT/surface=fcc211/type=test/shifted=True/class=adatom/s-s-adatom/image={}'.format(i))
    atoms = calc.get_atoms()
    E += [atoms.get_potential_energy()]
    atoms.set_calculator(calc1)
    En += [atoms.get_potential_energy()]
c1 = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge')
atoms = c1.get_atoms()
E += [atoms.get_potential_energy()]
atoms.set_calculator(calc1)
En += [atoms.get_potential_energy()]

E = np.array(E)
E = E - E[0]
En = np.array(En)
En = En - En[0]

x = range(len(E))
xarray = np.linspace(0, len(E))
f1 = interp1d(x, E, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(range(len(E)), E, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Adatom diffusion')
#plt.ylabel('Potential Energy(eV)')
plt.xticks([0, 1, 2, 3, 4])
plt.legend(loc = 'best')
plt.tight_layout()
#plt.show()
plt.savefig('figures/211-diffusion.png')
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

[[./figures/211-diffusion.png]]

* DB
#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc211/type=vacancy/site=edge'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db10/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':10, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:
:RESULTS:
:END:


#+BEGIN_SRC python 
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc211/type=vacancy/site=middle'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db10/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':10, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python 
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc211/type=vacancy/site=terrace'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db10/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':10, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python 
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc211/type=adatom/site=0'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db10/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':10, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python 
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc211/type=adatom/site=1'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db10/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':10, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python 
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc211/type=adatom/site=2'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db10/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':10, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python 
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc211/type=adatom/site=3'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db10/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':10, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python 
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc211/type=adatom/site=4'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db10/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':10, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :results output org drawer
from vasp import Vasp

for i in range(9):
    calc = Vasp('NDFT/surface=fcc111/type=neb_nn/class=surf_vac/image={}'.format(i))
    calc.write_db('./database/db10/data.db', parser='=', overwrite=False, keys={'dbkey':10, 'structure':'surface'})
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

#+BEGIN_SRC python :results output org drawer
from vasp import Vasp

for i in range(9):
    calc = Vasp('NDFT/surface=fcc111/type=neb_nn/class=top_fcc/image={}'.format(i))
    calc.write_db('./database/db10/data.db', parser='=', overwrite=False, keys={'dbkey':10, 'structure':'surface'})
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

#+BEGIN_SRC python :results output org drawer
from vasp import Vasp

for i in range(9):
    calc = Vasp('NDFT/surface=fcc111/type=neb_nn/class=fcc_hcp/image={}'.format(i))
    calc.write_db('./database/db10/data.db', parser='=', overwrite=False, keys={'dbkey':10, 'structure':'surface'})
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

#+BEGIN_SRC python :results output org drawer
from vasp import Vasp

for i in range(9):
    calc = Vasp('NDFT/surface=fcc111/type=neb_nn/class=hcp_top/image={}'.format(i))
    calc.write_db('./database/db10/data.db', parser='=', overwrite=False, keys={'dbkey':10, 'structure':'surface'})
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

* Training
** Train set
#+BEGIN_SRC python
from ase.db import connect
import os
import random
import numpy as np

db = connect('./database/db10/data.db')

n = db.count()
n_train = int(round(n * 0.9))

n_ids =  np.array(range(n)) + 1

# This will sudo-randomly select 10% of the calculations
# Which is useful for reproducing our results.
random.seed(256)
train_samples = random.sample(n_ids, n_train)
valid_samples = set(n_ids) - set(train_samples)

db.update(list(train_samples), train_set=True)
db.update(list(valid_samples), train_set=False)

#+END_SRC

#+RESULTS:

** Train 
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()
#20, 24, 25
for n in [18, 20, 24, 25]:

    wd = 'networks/db10/{0}-{0}/'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)
    os.chdir(wd)

    run_amp = """#!/usr/bin/env python
import os
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing

db = connect('../../../database/db10/data.db')
wd = os.getcwd()
images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(
           label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=8,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
""".format(n)

    cmd = '''#!/bin/bash
#PBS -N {}
#PBS -l nodes=1:ppn=8
#PBS -l walltime=168:00:00
#PBS -l mem=30GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

    with open('submit.py', 'w') as f:
        f.write(run_amp)
    os.chmod('submit.py', 0777)

    with open('submit.sh', 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', 'submit.sh'])
    time.sleep(2)
    os.unlink('submit.sh')
    os.chdir(home)
#+END_SRC

#+RESULTS:
: 1471425.gilgamesh.cheme.cmu.edu
: 1471426.gilgamesh.cheme.cmu.edu
: 1471427.gilgamesh.cheme.cmu.edu
: 1471428.gilgamesh.cheme.cmu.edu

** Update

#+BEGIN_SRC python
from ase.db import connect
from amp import Amp

db = connect('./database/db10/data.db')
calc1 = Amp(load = './networks/db10/18-18/checkpoint-parameters.json')
#calc2 = Amp(load = './networks/db8/25-25/checkpoint-parameters.json')

for d in db.select():
    atoms = db.get_atoms(d.id)
    atoms.set_calculator(calc1)
    nrg1 = atoms.get_potential_energy()

#    atoms.set_calculator(calc2)
#    nrg2 = atoms.get_potential_energy()
    db.update(d.id, NN18 = nrg1)
#+END_SRC

#+RESULTS:

** Time
#+BEGIN_SRC python
from ase.db import connect
from amp import Amp
import time

db = connect('./database/db10/data.db')
calc1 = Amp(load = './networks/db10/18-18/checkpoint-parameters.json')
#calc2 = Amp(load = './networks/db8/25-25/checkpoint-parameters.json')

for d in db.select('id<29'):
    atoms = db.get_atoms(d.id)
    atoms.set_calculator(calc1)
    time1 = time.time()
    nrg1 = atoms.get_potential_energy()
    time2 = time.time()
    t = (time2-time1)*1000
#    atoms.set_calculator(calc2)
#    nrg2 = atoms.get_potential_energy()
    db.update(d.id, NN18 = nrg1, NNtime=t)
#+END_SRC

#+RESULTS:

** Residual
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from ase.db import connect
from amp import Amp
import os

db = connect('database/db8/data.db')

fig, ax = plt.subplots(1, 2, sharey=True, figsize=(8, 4))

for i, n in enumerate([18, 25]):

    E, nnE, var, ind = [], [], [], []
    for j, d in enumerate(db.select('')):# dbkey=0
	E += [d.energy / d.natoms]
	nnE += [d['NN{}'.format(n)]/ d.natoms]
	var += [j]
	ind += [d.train_set]

    res = np.array(nnE) - np.array(E)
    mask = np.array(ind)
    valid = np.ma.masked_array(res, mask)
    train = np.ma.masked_array(res, ~mask)
    vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
    tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))

    ax[i].text(200, -0.050,
               'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
               color='b', ha='left')
    ax[i].text(200, -0.057,
               'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
               color='r', ha='left')

    ax[i].scatter(var, train, color='b')
    ax[i].scatter(var, valid, color='r')
    ax[i].plot([min(var), max(var)], [0, 0], 'k--')
    ax[i].set_xlim(min(var), max(var))

    ax[i].set_xlabel('Calculation ID')
    ax[i].set_title('8-{0}-{0}-1 framework'.format(n))

ax[0].set_ylim(-0.060, 0.060)
ax[0].set_ylabel('Residual error (eV/atom)')
plt.tight_layout()
plt.savefig('./figures/residual-8.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/residual-8.png]]

Large error configurations
#+BEGIN_SRC python
import numpy as np
from ase.db import connect
ids = []
db = connect('database/db10/data.db')
for i, d in enumerate(db.select()):
    E = d.energy / d.natoms
    nE = d.NN18/ d.natoms
    if abs(E - nE) > 0.03:
        ids += [i]
        #print d.bulk
        #print d.factor

print ids
#+END_SRC

#+RESULTS:
: [296, 297, 298, 340, 341, 342, 343, 351, 352, 353, 444, 770, 824]

#+BEGIN_SRC python
from ase.db import connect

ids = [0, 296, 297, 298, 339]
db = connect('database/db8/data.db')
for i in ids:
    item = db.select('id={}'.format(i))
    print item.NN18
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.db import connect

db = connect('database/db10/data.db')
for i, d in enumerate(db.select('structure=surface', 'type=vacancy', 'supercell=22')):
        for key in d:
            print ('{0:25}:{1}'.format(key, d[key]))
#+END_SRC

#+RESULTS:

*** Bulk Residual
#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db8/data.db')

S, Qe, Ne = [], [], []

for d in db.select(['type=eos']):
    S += [d.bulk]
    Qe += [d.energy/d.natoms]
    Ne += [d.NN18/d.natoms]
    
S = np.array(S)
Qe = np.array(Qe)
Ne = np.array(Ne)

cmap, hdl = {}, []

#print Ne
for s, c in zip(set(S), ['b', 'r', 'g', 'c', 'm']):
    cmap[s] = c
    hdl +=[mpatches.Patch(color = c, label = s)]

c = []
for s in S:
    c +=[cmap[s]]

RMSE = np.sqrt(sum((Ne-Qe)** 2) / len(Ne - Qe))

(mu, sigma) = norm.fit(Ne- Qe)

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
ax0.plot([min(Qe), 0], [0,0], 'k--', lw =2)
ax0.scatter(Qe, Ne-Qe, marker = 'o', color = c)
ax0.text(min(Qe) + 0.1, 0.14,
         'RMSE: {0:1.3f}'.format(RMSE),
         fontsize = 12, va = 'top', ha = 'left')
ax0.set_xlim(min(Qe), 0)
ax0.set_ylim(-0.05, 0.05)
ax0.set_xlabel('DFT potential energy (eV/atom)')
ax0.set_ylabel('Rsidual error (eV/atom)')
ax0.legend(loc = 'best', handles =hdl, fontsize = 8, frameon = False)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(Ne-Qe, 50,
                            range = (-0.05, 0.05),
                            weights = np.ones_like(Ne-Qe)/ len(Ne),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.05, 0.04, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.05, 0.03, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.05, 0.05)
ax1.set_xlim(0, 0.3)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
plt.tight_layout(w_pad = -0.5)

plt.savefig('./figures/eos-residual-8.png')
#plt.show()

#+END_SRC

#+RESULTS:

eos-residual

[[./figures/eos-residual-8.png]]


#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db8/data.db')

S, Qe, Ne = [], [], []

for d in db.select([]):
    S += [d.structure]
    Qe += [d.energy/d.natoms]
    Ne += [d.NN18/d.natoms]
    
S = np.array(S)
Qe = np.array(Qe)
Ne = np.array(Ne)

cmap, hdl = {}, []

#print Ne
for s, c in zip(set(S), ['b', 'r']):
    cmap[s] = c
    hdl +=[mpatches.Patch(color = c, label = s)]

c = []
for s in S:
    c +=[cmap[s]]

RMSE = np.sqrt(sum((Ne-Qe)** 2) / len(Ne - Qe))

(mu, sigma) = norm.fit(Ne- Qe)

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
ax0.plot([min(Qe), 0], [0,0], 'k--', lw =2)
ax0.scatter(Qe, Ne-Qe, marker = 'o', color = c)
ax0.text(min(Qe) + 0.1, 0.14,
         'RMSE: {0:1.3f}'.format(RMSE),
         fontsize = 12, va = 'top', ha = 'left')
ax0.set_xlim(min(Qe), 0)
ax0.set_ylim(-0.05, 0.05)
ax0.set_xlabel('DFT potential energy (eV/atom)')
ax0.set_ylabel('Rsidual error (eV/atom)')
ax0.legend(loc = 'best', handles =hdl, fontsize = 8, frameon = False)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(Ne-Qe, 50,
                            range = (-0.05, 0.05),
                            weights = np.ones_like(Ne-Qe)/ len(Ne),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.05, 0.142, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.05, 0.122, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.05, 0.05)
ax1.set_xlim(0, 0.3)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
plt.tight_layout(w_pad = -0.5)

#plt.savefig('./figures/eos-residual-6.png')
plt.show()

#+END_SRC

#+RESULTS:

*** surface residual
#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db6/data.db')

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
E, nE, var, ind = [], [], [], []
#for j, d in enumerate(db.select(['order=md2','structure=surface'])):# dbkey=0
#for j, d in enumerate(db.select(['v_a=0_20'])):# dbkey=0
#for j, d in enumerate(db.select(['type=vacancy', 'structure=surface'])):# dbkey=0
for j, d in enumerate(db.select(['structure=surface', 'type=vacancy', 'supercell=22'])):
    E += [d.energy / d.natoms]
    nE += [d.NN18/ d.natoms]
    var += [j]
    ind += [d.train_set]

E = np.array(E)
nE = np.array(nE)
res = np.array(nE) - np.array(E)
mask = np.array(ind)
valid = np.ma.masked_array(res, mask)
train = np.ma.masked_array(res, ~mask)
vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))

ax0.text(380, -0.048,
           'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
           color='b', ha='left')
ax0.text(270, -0.055,
           'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
           color='r', ha='left')

ax0.scatter(var, train, color='b')
ax0.scatter(var, valid, color='r')
ax0.plot([min(var), max(var)], [0, 0], 'k--')
ax0.set_xlim(min(var), max(var))
ax0.set_ylim(-0.015, 0.015)

ax0.set_xlabel('Calculation ID')
ax0.set_title('8-15-15-1 framework')


(mu, sigma) = norm.fit(nE - E)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(nE-E, 50,
                            range = (-0.05, 0.05),
                            weights = np.ones_like(nE-E)/ len(nE),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.01, 0.04, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.01, 0.03, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.05, 0.05)
ax1.set_xlim(0, 0.20)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
ax1.set_title('Error Distribution')
plt.tight_layout(w_pad = -0.5)
#plt.savefig('./figures/surf-error-distribution-6.png')
plt.show()
#+END_SRC

#+RESULTS:

[[./figures/surf-error-distribution-6.png]]

#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

from ase.db import connect

db = connect('./database/db6/data.db')
data = db.select(['structure=surface', 'type=vacancy', 'supercell=22'])
for i in data:
    print i.energy, (i.energy-i.NN18)

'''
keys, cnt = {}, 0
for entry in data:
    cnt += 1
    for k, v in entry.key_value_pairs.iteritems():
        
        if k in keys:
            keys[k] += [v]
        else:
            keys[k] = [v]

print ('{0:15s} {1:15s} {2} calculations total'.format('keyword', 'value',cnt))

print('------------------------------------------------------')

for k, v in keys.iteritems():
    vals = list(set(v))
    if len(vals) <= 5:
        val = ", ".join(str(e) for e in vals)
        print('{0:15}: {1}'.format(k, val))

    else:
        val = ", ".join(str(e)[:5] for e in vals[:5])
        print('{0:15s}:{1}, etc...'.format(k, val))
'''
#+END_SRC
#+RESULTS:
#+begin_example
-93.70842946 -0.00365614977676
-93.74332304 -0.00503410764865
-93.75861948 -0.0066648115842
-93.76473653 -0.00896813813645
-93.76797866 -0.0136691968526
-93.77003598 -0.0128265905814
-93.7703986 -0.0121485940649
-93.77205094 -0.0120452096251
-93.77319588 -0.0120497897817
-93.77419085 -0.0125990848719
-93.77457472 -0.0133356778424
-93.77487465 -0.0143918145677
-93.77503405 -0.0156345666371
#+end_example

* Application
** NN NEB
*** Bulk-vacancy-diffusion
#+BEGIN_SRC python :results output org drawer
from ase import io
from ase.neb import NEB
from ase.optimize import MDMin
from vasp import Vasp
from amp import Amp

calc = Amp(load = 'networks/db10/18-18/checkpoint-parameters.json')
# Read initial and final states:
initial = Vasp('./NDFT/bulk=fcc/type=neb/supercell=333/neb-initial').get_atoms()
final = Vasp('./NDFT/bulk=fcc/type=neb/supercell=333/neb-final').get_atoms()
# Make a band consisting of 5 images:
images = [initial]
images += [initial.copy() for i in range(7)]
images += [final]
neb = NEB(images)
# Interpolate linearly the potisions of the three middle images:
neb.interpolate()
# Set calculators:
for image in images:
    image.set_calculator(calc)
# Optimize:
optimizer = MDMin(neb, trajectory='trajectory/333.traj')
optimizer.run(fmax=0.04)
#+END_SRC

#+RESULTS:
:RESULTS:
MDMin:   0  10:31:12      -33.950470       1.9210
MDMin:   1  10:31:29      -34.215823       1.5221
MDMin:   2  10:31:45      -34.581072       0.4698
MDMin:   3  10:32:02      -34.672503       0.2331
MDMin:   4  10:32:18      -34.685577       0.3322
MDMin:   5  10:32:35      -34.688650       0.2356
MDMin:   6  10:32:51      -34.692385       0.1831
MDMin:   7  10:33:08      -34.693023       0.0903
MDMin:   8  10:33:24      -34.693461       0.0675
MDMin:   9  10:33:41      -34.693668       0.0706
MDMin:  10  10:33:58      -34.693727       0.0917
MDMin:  11  10:34:14      -34.693682       0.1640
MDMin:  12  10:34:31      -34.693727       0.0964
MDMin:  13  10:34:48      -34.693742       0.0691
MDMin:  14  10:35:04      -34.693749       0.0439
MDMin:  15  10:35:21      -34.693749       0.0445
MDMin:  16  10:35:37      -34.693749       0.0385
:END:


#+BEGIN_SRC python :results output org drawer
from ase.io.trajectory import Trajectory
from amp import Amp
from ase.io import read
import matplotlib.pyplot as plt
from vasp import Vasp
import numpy as np
from scipy.interpolate import interp1d

#images = Trajectory('A2B.traj')
images = read('trajectory/bulk-vac.traj@-9:')
calc1 = Amp(load = './networks/db10/18-18/checkpoint-parameters.json')

E, En = [], []

for image in images:
    image.set_calculator(calc1)
    En.append(image.get_potential_energy()/len(image))


for i in range (9):
    calc = Vasp('./NDFT/bulk=fcc/type=neb/supercell=222/image={0}'.format(i))
    atoms = calc.get_atoms()
    E += [calc.potential_energy/len(atoms)]

E = np.array(E)
En = np.array(En)
E = E- E[0]
En = En-En[0]
x = range(len(E))
xarray = np.linspace(0, len(E))
f1 = interp1d(x, E, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(x, E, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
plt.savefig('figures/bulk-vac-nn.png')
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

[[./figures/bulk-vac-nn.png]]

*** surface vacancy
#+BEGIN_SRC python :
from ase import io
from ase.neb import NEB
from ase.optimize import MDMin
from vasp import Vasp
from amp import Amp

calc = Amp(load = 'networks/db9/15-15/checkpoint-parameters.json')
# Read initial and final states:
initial = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/neb-initial').get_atoms()
final = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/neb-end').get_atoms()
# Make a band consisting of 5 images:
images = [initial]
images += [initial.copy() for i in range(7)]
images += [final]
neb = NEB(images)
# Interpolate linearly the potisions of the three middle images:
neb.interpolate()
# Set calculators:
for image in images:
    image.set_calculator(calc)
# Optimize:
optimizer = MDMin(neb, trajectory='NDFT/surface=fcc111/type=neb/class=vacancy/A2B.traj')
optimizer.run(fmax=0.04)
#+END_SRC

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()


run_md = '''#!/usr/bin/env python
from ase import io
from ase.neb import NEB
from ase.optimize import MDMin
from vasp import Vasp
from amp import Amp

calc = Amp(load = "networks/db10/15-15/checkpoint-parameters.json")

initial = Vasp("./NDFT/surface=fcc111/type=neb/class=vacancy/neb-initial").get_atoms()
final = Vasp("./NDFT/surface=fcc111/type=neb/class=vacancy/neb-end").get_atoms()

images = [initial]
images += [initial.copy() for i in range(7)]
images += [final]
neb = NEB(images)

neb.interpolate()

for image in images:
    image.set_calculator(calc)

optimizer = MDMin(neb, trajectory="trajectory/db10/surf-vac.traj")
optimizer.run(fmax=0.04)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('sur-vac')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')

#+END_SRC

#+RESULTS:
: 1471456.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python :results output org drawer
from ase.io.trajectory import Trajectory
from amp import Amp
from ase.io import read
import matplotlib.pyplot as plt
from vasp import Vasp
import numpy as np
from scipy.interpolate import interp1d

#images = Trajectory('A2B.traj')
images = read('trajectory/db10/333.traj@-9:')
calc1 = Amp(load = './networks/db10/18-18/checkpoint-parameters.json')

E, En, Edft = [], [], []

for image in images:
    image.set_calculator(calc1)
    En.append(image.get_potential_energy()/len(image))


for i in range (9):
    calc = Vasp('./NDFT/surface=fcc111/type=neb/class=vacancy/image={0}'.format(i))
    atoms = calc.get_atoms()
    E += [calc.potential_energy/len(atoms)]
'''
for i in range (9):
    calc = Vasp('NDFT/surface=fcc111/type=neb_nn/class=surf_vac/image={}'.format(i))
    Edft += [calc.potential_energy/len(atoms)]
'''
E = np.array(E)
En = np.array(En)
#Edft = np.array(Edft)
E = E- E[0]
En = En-En[0]
#Edft = Edft- Edft[0]
x = range(len(E))
xarray = np.linspace(0, len(E))
f1 = interp1d(x, E, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(x, E, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
#plt.plot(x, Edft, 'ko')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
plt.show()
#plt.savefig('figures/surf-vac-nn.png')
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

[[./figures/surf-vac-nn.png]]

**** DFT
#+BEGIN_SRC python :results output org drawer
from ase.io import read
from vasp import Vasp
from vasp.vasprc import VASPRC
#VASPRC['queue.walltime']= '24:00:00'
VASPRC['queue.ppn'] = 4
images = read('trajectory/surf-vac.traj@-9:')
for i in range(9):
    calc = Vasp('NDFT/surface=fcc111/type=neb_nn/class=surf-vac/image={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC

*** surface adatom
**** top-fcc
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()


run_md = '''#!/usr/bin/env python
from ase import io
from ase.neb import NEB
from ase.optimize import MDMin
from vasp import Vasp
from amp import Amp

calc = Amp(load = "networks/db9/15-15/checkpoint-parameters.json")

initial = Vasp("NDFT/surface=fcc111/type=neb/fixed=True/position=top").get_atoms()
final = Vasp("NDFT/surface=fcc111/type=neb/fixed=True/position=fcc").get_atoms()

images = [initial]
images += [initial.copy() for i in range(7)]
images += [final]
neb = NEB(images)

neb.interpolate()

for image in images:
    image.set_calculator(calc)

optimizer = MDMin(neb, trajectory="trajectory/top-fcc.traj")
optimizer.run(fmax=0.04)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('top-fcc')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')

#+END_SRC

#+RESULTS:
: 1467750.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python :results output org drawer
from ase.io.trajectory import Trajectory
from amp import Amp
from ase.io import read
import matplotlib.pyplot as plt
from vasp import Vasp
import numpy as np
from scipy.interpolate import interp1d

#images = Trajectory('A2B.traj')
images = read('trajectory/top-fcc.traj@-9:')
calc1 = Amp(load = './networks/db9/25-25/checkpoint-parameters.json')

E, En = [], []

for image in images:
    image.set_calculator(calc1)
    En.append(image.get_potential_energy()/len(image))


for i in range (9):
    calc = Vasp('./NDFT/surface=fcc111/type=neb/fixed=True/class=top_fcc/image={0}'.format(i))
    atoms = calc.get_atoms()
    E += [calc.potential_energy/len(atoms)]

E = np.array(E)
En = np.array(En)
#E = E- E[0]
#En = En-En[0]
x = range(len(E))
xarray = np.linspace(0, len(E))
f1 = interp1d(x, E, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(x, E, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
#plt.show()
plt.savefig('figures/top-fcc-nn.png')
#+END_SRC

[[./figures/top-fcc-nn.png]]
**** fcc-hcp
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()


run_md = '''#!/usr/bin/env python
from ase import io
from ase.neb import NEB
from ase.optimize import MDMin
from vasp import Vasp
from amp import Amp

calc = Amp(load = "networks/db9/15-15/checkpoint-parameters.json")

initial = Vasp("NDFT/surface=fcc111/type=neb/fixed=True/position=fcc").get_atoms()
final = Vasp("NDFT/surface=fcc111/type=neb/fixed=True/position=hcp").get_atoms()

images = [initial]
images += [initial.copy() for i in range(7)]
images += [final]
neb = NEB(images)

neb.interpolate()

for image in images:
    image.set_calculator(calc)

optimizer = MDMin(neb, trajectory="trajectory/fcc-hcp.traj")
optimizer.run(fmax=0.04)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('fcc-hcp')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')

#+END_SRC

#+RESULTS:
: 1467751.gilgamesh.cheme.cmu.edu
#+BEGIN_SRC python :results output org drawer
from ase.io.trajectory import Trajectory
from amp import Amp
from ase.io import read
import matplotlib.pyplot as plt
from vasp import Vasp
import numpy as np
from scipy.interpolate import interp1d

#images = Trajectory('A2B.traj')
images = read('trajectory/fcc-hcp.traj@-9:')
calc1 = Amp(load = './networks/db9/25-25/checkpoint-parameters.json')

E, En = [], []

for image in images:
    image.set_calculator(calc1)
    En.append(image.get_potential_energy()/len(image))


for i in range (9):
    calc = Vasp('./NDFT/surface=fcc111/type=neb/fixed=True/class=fcc_hcp/image={0}'.format(i))
    atoms = calc.get_atoms()
    E += [calc.potential_energy/len(atoms)]

E = np.array(E)
En = np.array(En)
#E = E- E[0]
#En = En-En[0]
x = range(len(E))
xarray = np.linspace(0, len(E))
f1 = interp1d(x, E, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(x, E, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
#plt.show()
plt.savefig('figures/fcc-hcp-nn.png')
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

[[./figures/fcc-hcp-nn.png]]
**** hcp-top
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()


run_md = '''#!/usr/bin/env python
from ase import io
from ase.neb import NEB
from ase.optimize import MDMin
from vasp import Vasp
from amp import Amp

calc = Amp(load = "networks/db9/15-15/checkpoint-parameters.json")

initial = Vasp("NDFT/surface=fcc111/type=neb/fixed=True/position=hcp").get_atoms()
final = Vasp("NDFT/surface=fcc111/type=neb/fixed=True/position=top").get_atoms()

images = [initial]
images += [initial.copy() for i in range(7)]
images += [final]
neb = NEB(images)

neb.interpolate()

for image in images:
    image.set_calculator(calc)

optimizer = MDMin(neb, trajectory="trajectory/hcp-top.traj")
optimizer.run(fmax=0.04)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('hcp-top')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')

#+END_SRC

#+RESULTS:
: 1467752.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python :results output org drawer
from ase.io.trajectory import Trajectory
from amp import Amp
from ase.io import read
import matplotlib.pyplot as plt
from vasp import Vasp
import numpy as np
from scipy.interpolate import interp1d

#images = Trajectory('A2B.traj')
images = read('trajectory/hcp-top.traj@-9:')
calc1 = Amp(load = './networks/db9/25-25/checkpoint-parameters.json')

E, En = [], []

for image in images:
    image.set_calculator(calc1)
    En.append(image.get_potential_energy()/len(image))


for i in range (9):
    calc = Vasp('./NDFT/surface=fcc111/type=neb/fixed=True/class=hcp_top/image={0}'.format(i))
    atoms = calc.get_atoms()
    E += [calc.potential_energy/len(atoms)]

E = np.array(E)
En = np.array(En)
#E = E- E[0]
#En = En-En[0]
x = range(len(E))
xarray = np.linspace(0, len(E))
f1 = interp1d(x, E, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(x, E, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
#plt.show()
plt.savefig('figures/hcp-top-nn.png')
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

[[./figures/hcp-top-nn.png]]

**** all
#+BEGIN_SRC python :results output org drawer
from ase.io.trajectory import Trajectory
from amp import Amp
from ase.io import read
import matplotlib.pyplot as plt
from vasp import Vasp
import numpy as np
from scipy.interpolate import interp1d

lib = ['top-fcc', 'fcc-hcp', 'hcp-top']

calc1 = Amp(load = './networks/db9/25-25/checkpoint-parameters.json')

En = []
for i in lib:
    images = read('trajectory/{0}.traj@-9:'.format(i))
    for image in images:
        image.set_calculator(calc1)
	En.append(image.get_potential_energy())

print En

#+END_SRC

#+RESULTS:
:RESULTS:
[-103.21938589255454, -103.24252883923373, -103.30799258229727, -103.41342542547983, -103.55084529829618, -103.69945464540841, -103.82769329889614, -103.90087763596894, -103.93995282735192, -103.93995282735192, -103.8933891741462, -103.87094455256694, -103.84740905494291, -103.83831231666186, -103.84922991759119, -103.87502088225781, -103.90025260139332, -103.94599636486454, -103.94599636486454, -103.90580800589039, -103.82868628939734, -103.6984685379997, -103.54950649845996, -103.41243402666349, -103.30743332160347, -103.24227336246221, -103.21938589255454]
:END:

#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
from matplotlib.offsetbox import OffsetImage, AnnotationBbox
import matplotlib.image as mpimg
import os

nrg = np.array([-103.16314489, -103.17362203, -103.22147716000001, -103.32938334000001, -103.48398825, -103.66603531, -103.84634143, -103.98241757, -104.02334307, -103.99930865, -103.93616107, -103.88095009, -103.85664787, -103.86981663, -103.91413568999999, -103.96879078000001, -103.98963043000001, -103.95344617000001, -103.82724601, -103.65909859999999, -103.48889736, -103.34291469, -103.23595949, -103.17862415, -103.16314489])

En = np.array([-103.21938589255454, -103.24252883923373, -103.30799258229727, -103.41342542547983, -103.55084529829618, -103.69945464540841, -103.82769329889614, -103.90087763596894, -103.93995282735192, -103.8933891741462, -103.87094455256694, -103.84740905494291, -103.83831231666186, -103.84922991759119, -103.87502088225781, -103.90025260139332, -103.94599636486454, -103.90580800589039, -103.82868628939734, -103.6984685379997, -103.54950649845996, -103.41243402666349, -103.30743332160347, -103.24227336246221, -103.21938589255454])
#nrg = nrg - nrg[0]
#En = En- En[0]
nrg = nrg/21
En = En/21

nrg = nrg - nrg[0]
En = En - En[0]
x = range(len(nrg))
xarray = np.linspace(0, len(nrg))
f1 = interp1d(x, nrg, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
fig = plt.figure(figsize=(6,4))
ax = fig.add_subplot(111)


image = mpimg.imread('./figures/surface.png')
imagebox = OffsetImage(image, zoom=0.3)

ax.add_artist(AnnotationBbox(imagebox,
                             xy=(12, -0.01),
                            # xybox=(6, -4.92),
                             pad = -0.2))
plt.plot(range(len(nrg)), nrg, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlim([-1, 25])
plt.xticks([0, 8, 12, 16, 24], ['top', 'fcc', 'bridge', 'hcp', 'top'])
#plt.xticklabels()
#plt.yticks([-4.95, -4.94, -4.93, -4.92, -4.91])
plt.minorticks_on()
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 4)
plt.tight_layout()
plt.show()
#plt.savefig('./figures/adatom-NEB-8.png')
#+END_SRC

#+RESULTS:

*** 211 surface neb
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()


run_md = '''#!/usr/bin/env python
from ase import io
from ase.neb import NEB
from ase.optimize import MDMin
from vasp import Vasp
from amp import Amp

calc = Amp(load = "networks/db10/15-15/checkpoint-parameters.json")

c0 = Vasp("NDFT/surface=fcc211/type=neb/class=vacancy/position=step0")
initial = c0.get_atoms()
initial.wrap(center=(0.8, 0.5, 0.5))
c1 = Vasp("NDFT/surface=fcc211/type=neb/class=vacancy/position=step1")
final = c1.get_atoms()
final.wrap(center=(0.8, 0.5, 0.5))

images = [initial]
images += [initial.copy() for i in range(7)]
images += [final]
neb = NEB(images)

neb.interpolate()

for image in images:
    image.set_calculator(calc)

optimizer = MDMin(neb, trajectory="trajectory/db10/shifted-vac-s-s.traj")
optimizer.run(fmax=0.04)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=168:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('sur-vac')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')

#+END_SRC

#+RESULTS:
: 1475160.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()


run_md = '''#!/usr/bin/env python
from ase import io
from ase.neb import NEB
from ase.optimize import MDMin
from vasp import Vasp
from amp import Amp

calc = Amp(load = "networks/db10/15-15/checkpoint-parameters.json")

c0 = Vasp("NDFT/surface=fcc211/type=neb/class=vacancy/position=step0")
initial = c0.get_atoms()
initial.wrap(center=(0.8, 0.5, 0.5))

c1 = Vasp("NDFT/surface=fcc211/type=neb/class=vacancy/position=terrace")
final = c1.get_atoms()
final.wrap(center=(0.8, 0.5, 0.5))

images = [initial]
images += [initial.copy() for i in range(7)]
images += [final]
neb = NEB(images)

neb.interpolate()

for image in images:
    image.set_calculator(calc)

optimizer = MDMin(neb, trajectory="trajectory/db10/shifted-vac-s-t.traj")
optimizer.run(fmax=0.04)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=168:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('211-vac-s-t')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')

#+END_SRC

#+RESULTS:
: 1475161.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()


run_md = '''#!/usr/bin/env python
from ase import io
from ase.neb import NEB
from ase.optimize import MDMin
from vasp import Vasp
from amp import Amp

calc = Amp(load = "networks/db10/15-15/checkpoint-parameters.json")

c0 = Vasp("NDFT/surface=fcc211/type=test/fix=True/site=edge0")
initial = c0.get_atoms()
initial.wrap(center=(0.8, 0.5, 0.5))

c1 = Vasp("NDFT/surface=fcc211/type=test/fix=True/site=edge")
final = c1.get_atoms()
final.wrap(center=(0.8, 0.5, 0.5))

images = [initial]
images += [initial.copy() for i in range(7)]
images += [final]
neb = NEB(images)

neb.interpolate()

for image in images:
    image.set_calculator(calc)

optimizer = MDMin(neb, trajectory="trajectory/db10/shifted-adatom-s-s.traj")
optimizer.run(fmax=0.04)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=168:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('211-adatom-s-s')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')

#+END_SRC

#+RESULTS:
: 1475162.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()


run_md = '''#!/usr/bin/env python
from ase import io
from ase.neb import NEB
from ase.optimize import MDMin
from vasp import Vasp
from amp import Amp

calc = Amp(load = "networks/db10/15-15/checkpoint-parameters.json")

c0 = Vasp("NDFT/surface=fcc211/type=test/fix=True/site=edge0")
initial = c0.get_atoms()
initial.wrap(center=(0.8, 0.5, 0.5))
c1 = Vasp("NDFT/surface=fcc211/type=test/fix=True/site=edge1")
final = c1.get_atoms()
final.wrap(center=(0.8, 0.5, 0.5))

images = [initial]
images += [initial.copy() for i in range(7)]
images += [final]
neb = NEB(images)

neb.interpolate()

for image in images:
    image.set_calculator(calc)

optimizer = MDMin(neb, trajectory="trajectory/db10/shifted-adatom-s-t.traj")
optimizer.run(fmax=0.04)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=168:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('211-adatom-s-t')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')

#+END_SRC

#+RESULTS:
: 1475163.gilgamesh.cheme.cmu.edu

** 211 surface 
*** RMSE
#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db10/data.db')

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
E, nE, var, ind = [], [], [], []
#for j, d in enumerate(db.select()):
for j, d in enumerate(db.select(['surface=fcc211'])):# dbkey=0
    E += [d.energy / d.natoms]
    nE += [d.NN18/ d.natoms]
    var += [j]
    ind += [d.train_set]

E = np.array(E)
nE = np.array(nE)
res = np.array(nE) - np.array(E)
mask = np.array(ind)
valid = np.ma.masked_array(res, mask)
train = np.ma.masked_array(res, ~mask)
vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))
'''
ax0.text(380, -0.048,
           'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
           color='b', ha='left')
ax0.text(270, -0.055,
           'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
           color='r', ha='left')
'''


ax0.text(25, 0.015,
           'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
           color='b', ha='left')
ax0.text(25, 0.010,
           'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
           color='r', ha='left')

ax0.scatter(E, train, color='b')
ax0.scatter(E, valid, color='r')
ax0.plot([min(E), max(E)], [0, 0], 'k--')
ax0.set_xlim(min(E), max(E))
ax0.set_ylim(-0.02, 0.02)
ax0.set_xlabel('DFT potential energy (eV/atom)')
ax0.set_ylabel('Residual error (eV/atom)')
#ax0.set_title('211 surface')
ax0.set_yticks([-0.02, -0.01, 0, 0.01, 0.02])
ax0.minorticks_on()
(mu, sigma) = norm.fit(nE - E)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(nE-E, 50,
                            range = (-0.02, 0.02),
                            weights = np.ones_like(nE-E)/ len(nE),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.01, 0.015, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.01, 0.018, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.02, 0.02)
ax1.set_xlim(0, 0.25)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
#ax1.set_title('Error Distribution')
plt.tight_layout()
plt.savefig('./figures/error-211.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/error-211.png]]

*** Surface energy
#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
calc1 = Vasp('NDFT/surface=fcc211/type=relaxation/supercell=33')
print calc1.potential_energy
atoms = calc1.get_atoms()

calc = Amp(load='./networks/db10/18-18/checkpoint-parameters.json')
atoms.set_calculator(calc)
nrg = atoms.get_potential_energy()
print nrg
#+END_SRC

#+RESULTS:
: -223.69267677
: -223.662885662

#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc211
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc1 = Vasp('NDFT/atomic-Pd')
Eatomic = calc1.potential_energy

calc2 = Vasp('NDFT/surface=fcc211/type=vacancy/site=edge')
Ev = calc2.potential_energy

calc3 = Vasp('NDFT/surface=fcc211/type=relaxation/supercell=33')
Es = calc3.potential_energy

calc = Amp(load='./networks/db10/18-18/checkpoint-parameters.json')

atoms = fcc211('Pd', size=(3, 3, 5), a = 3.939,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.z < 10.05 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgs = atoms.get_potential_energy()


atoms = fcc211('Pd', size=(3, 3, 5), a = 3.939,  vacuum=6.0)
del atoms[0]
constraint = FixAtoms(mask=[atom.z < 10.05 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgv = atoms.get_potential_energy()
print Ev, nrgv
print Es, nrgs
print Ev - Es + Eatomic
print nrgv - nrgs + Eatomic
#+END_SRC


#+BEGIN_EXAMPLE
BFGS:   0  14:29:02     -223.610529       0.5191
BFGS:   1  14:29:57     -223.630283       0.4638
BFGS:   2  14:30:51     -223.687404       0.2378
BFGS:   3  14:31:45     -223.692011       0.2861
BFGS:   4  14:32:39     -223.696544       0.2967
BFGS:   5  14:33:33     -223.704348       0.1928
BFGS:   6  14:34:27     -223.707442       0.1422
BFGS:   7  14:35:21     -223.710388       0.1572
BFGS:   8  14:36:16     -223.712753       0.1336
BFGS:   9  14:37:10     -223.713525       0.0832
BFGS:  10  14:38:04     -223.711530       0.0755
BFGS:  11  14:38:58     -223.708909       0.0699
BFGS:  12  14:39:52     -223.706905       0.0548
BFGS:  13  14:40:46     -223.704684       0.0621
BFGS:  14  14:41:40     -223.703081       0.0496
BFGS:   0  14:43:06     -218.053742       0.6857
BFGS:   1  14:43:58     -218.079218       0.6169
BFGS:   2  14:44:49     -218.144897       0.3464
BFGS:   3  14:45:41     -218.157278       0.4786
BFGS:   4  14:46:33     -218.162269       0.4316
BFGS:   5  14:47:25     -218.178601       0.1192
BFGS:   6  14:48:17     -218.178503       0.1540
BFGS:   7  14:49:09     -218.178682       0.1536
BFGS:   8  14:50:01     -218.178248       0.1130
BFGS:   9  14:50:53     -218.178162       0.0945
BFGS:  10  14:51:45     -218.178924       0.0874
BFGS:  11  14:52:37     -218.179561       0.1061
BFGS:  12  14:53:29     -218.178896       0.1046
BFGS:  13  14:54:21     -218.176321       0.0739
BFGS:  14  14:55:12     -218.173330       0.0670
BFGS:  15  14:56:04     -218.171023       0.0735
BFGS:  16  14:56:56     -218.168774       0.0836
BFGS:  17  14:57:48     -218.167344       0.0549
BFGS:  18  14:58:40     -218.167378       0.0427
-218.14348125 -218.167378412
-223.69267677 -223.703081194
4.08949388
4.07600114137
#+END_EXAMPLE

#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc211
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc1 = Vasp('NDFT/bulk=fcc/type=eos/factor=1.00')
Eatomic = calc1.potential_energy

calc2 = Vasp('NDFT/surface=fcc211/type=vacancy/site=middle')
Ev = calc2.potential_energy

calc3 = Vasp('NDFT/surface=fcc211/type=relaxation/supercell=33')
Es = calc3.potential_energy

calc = Amp(load='./networks/db10/18-18/checkpoint-parameters.json')

nrgs = -223.703081194


atoms = fcc211('Pd', size=(3, 3, 5), a = 3.939,  vacuum=6.0)
del atoms[3]
constraint = FixAtoms(mask=[atom.z < 10.05 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)
#view (atoms)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgv = atoms.get_potential_energy()
print Ev, nrgv
print Es, nrgs
print Ev - Es + Eatomic
print nrgv - nrgs + Eatomic
#+END_SRC

#+BEGIN_EXAMPLE
BFGS:   0  15:07:57     -217.568350       0.6200
BFGS:   1  15:08:48     -217.596943       0.5651
BFGS:   2  15:09:40     -217.680348       0.3311
BFGS:   3  15:10:31     -217.700843       0.4018
BFGS:   4  15:11:23     -217.707911       0.3739
BFGS:   5  15:12:14     -217.731898       0.1715
BFGS:   6  15:13:06     -217.733268       0.1991
BFGS:   7  15:13:57     -217.735647       0.1965
BFGS:   8  15:14:49     -217.736945       0.1163
BFGS:   9  15:15:41     -217.737886       0.0976
BFGS:  10  15:16:32     -217.739188       0.0912
BFGS:  11  15:17:24     -217.740464       0.1208
BFGS:  12  15:18:15     -217.740685       0.1302
BFGS:  13  15:19:07     -217.739273       0.0942
BFGS:  14  15:19:59     -217.737347       0.0667
BFGS:  15  15:20:50     -217.735509       0.0785
BFGS:  16  15:21:42     -217.733430       0.0827
BFGS:  17  15:22:33     -217.732065       0.0606
BFGS:  18  15:23:25     -217.732119       0.0498
-217.62289697 -217.732119025
-223.69267677 -223.703081194
0.85530982
0.756492189255
#+END_EXAMPLE

#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc211
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc1 = Vasp('NDFT/bulk=fcc/type=eos/factor=1.00')
Eatomic = calc1.potential_energy

calc2 = Vasp('NDFT/surface=fcc211/type=adatom/site=0')
Ev = calc2.potential_energy
atoms = calc2.get_atoms()

calc3 = Vasp('NDFT/surface=fcc211/type=relaxation/supercell=33')
Es = calc3.potential_energy

calc = Amp(load='./networks/db10/18-18/checkpoint-parameters.json')

nrgs = -223.703081194


#atoms = fcc211('Pd', size=(3, 3, 5), a = 3.939,  vacuum=6.0)
#del atoms[3]
#constraint = FixAtoms(mask=[atom.z < 10.05 for atom in atoms])
#atoms.set_constraint(constraint)
atoms.set_calculator(calc)
#view (atoms)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgv = atoms.get_potential_energy()
print Ev, nrgv
print Es, nrgs
#print Ev - Es + Eatomic
#print nrgv - nrgs + Eatomic
#+END_SRC

#+BEGIN_EXAMPLE
BFGS:   0  15:28:42     -228.606724       0.3844
BFGS:   1  15:29:35     -228.618748       0.3141
BFGS:   2  15:30:28     -228.636588       0.1841
BFGS:   3  15:31:21     -228.638408       0.1735
BFGS:   4  15:32:14     -228.627297       0.1134
BFGS:   5  15:33:07     -228.626033       0.1077
BFGS:   6  15:34:00     -228.608752       0.0909
BFGS:   7  15:34:53     -228.607433       0.0903
BFGS:   8  15:35:47     -228.599632       0.0893
BFGS:   9  15:36:40     -228.592595       0.0693
BFGS:  10  15:37:33     -228.585779       0.0610
BFGS:  11  15:38:26     -228.582555       0.0611
BFGS:  12  15:39:19     -228.579096       0.0603
BFGS:  13  15:40:12     -228.576746       0.0484
-228.61999163 -228.576745652
-223.69267677 -223.703081194
#+END_EXAMPLE

#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc211
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc1 = Vasp('NDFT/bulk=fcc/type=eos/factor=1.00')
Eatomic = calc1.potential_energy

calc2 = Vasp('NDFT/surface=fcc211/type=adatom/site=1')
Ev = calc2.potential_energy
atoms = calc2.get_atoms()

calc3 = Vasp('NDFT/surface=fcc211/type=relaxation/supercell=33')
Es = calc3.potential_energy

calc = Amp(load='./networks/db10/18-18/checkpoint-parameters.json')

nrgs = -223.703081194


#atoms = fcc211('Pd', size=(3, 3, 5), a = 3.939,  vacuum=6.0)
#del atoms[3]
#constraint = FixAtoms(mask=[atom.z < 10.05 for atom in atoms])
#atoms.set_constraint(constraint)
atoms.set_calculator(calc)
#view (atoms)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgv = atoms.get_potential_energy()
print Ev, nrgv
print Es, nrgs
#print Ev - Es + Eatomic
#print nrgv - nrgs + Eatomic
#+END_SRC




* relaxed neb 3*3*3
c0-end
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic
VASPRC['queue.ppn'] = 4
fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
				    latticeconstant = 3.939)


atoms = fcc.repeat([3, 3, 3])

ini = atoms.copy()
del ini[0]

# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=test/supercell=333/neb-initial',
          xc='pbe',
          kpts=[5, 5, 5],
          encut=350,
	  ibrion=2,
	  nsw=20,
          atoms=ini)
c0.calculate()
fin = atoms.copy()
del fin[1]

cend = Vasp('NDFT/bulk=fcc/type=test/supercell=333/neb-final',
            xc='pbe',
            kpts=[5, 5, 5],
            encut=350,
	    nsw=20,
	    ibrion=2,
            atoms=fin)
cend.calculate()
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/supercell=333/neb-initial submitted: 1487641.gilgamesh.cheme.cmu.edu
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/supercell=333/neb-final submitted: 1487642.gilgamesh.cheme.cmu.edu


#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.cubic import FaceCenteredCubic

VASPRC['queue.mem'] = '8GB'


# Get unrelaxed initial and final states for speed.
c0 = Vasp('NDFT/bulk=fcc/type=test/supercell=333/neb-initial')
ini = c0.get_atoms()

cend = Vasp('NDFT/bulk=fcc/type=test/supercell=333/neb-final')
fin = cend.get_atoms()

Vasp.stop_if(None in [c0.potential_energy, cend.potential_energy])

images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/bulk=fcc/type=test/supercell=333/neb',
            xc='pbe',
            kpts=[5, 5, 5],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/333-NEB.png')
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/bulk=fcc/type=test/supercell=333/neb submitted: 1487643.gilgamesh.cheme.cmu.edu

[[./images/333-NEB.png]

#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d
from ase.calculators.singlepoint import SinglePointCalculator as SPC

calc = Vasp('NDFT/bulk=fcc/type=test/supercell=333/neb')
images, energies = calc.get_neb()
calc2 = Amp(load = 'networks/db10/24-24/checkpoint-parameters.json')
En, E = [], []

for atoms in images:
    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

En = np.array(En)
E = En-En[0]
x = range(len(images))
xarray = np.linspace(0, len(images))
f1 = interp1d(x, energies, kind='cubic', bounds_error=False)
f2 = interp1d(x, E, kind='cubic', bounds_error=False)
plt.plot(x, energies, 'bo', label = 'NEB')
plt.plot(x, E, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')

plt.savefig('./figures/NEB-NN-333.png')

#+END_SRC

#+RESULTS:

[[./figures/NEB-NN-333.png]]

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()


run_md = '''#!/usr/bin/env python
from ase import io
from ase.neb import NEB
from ase.optimize import MDMin
from vasp import Vasp
from amp import Amp

calc = Amp(load = "networks/db10/18-18/checkpoint-parameters.json")

initial = Vasp("./NDFT/bulk=fcc/type=test/supercell=333/neb-initial").get_atoms()
final = Vasp("./NDFT/bulk=fcc/type=test/supercell=333/neb-final").get_atoms()

images = [initial]
images += [initial.copy() for i in range(7)]
images += [final]
neb = NEB(images)

neb.interpolate()

for image in images:
    image.set_calculator(calc)

optimizer = MDMin(neb, trajectory="trajectory/db10/333.traj")
optimizer.run(fmax=0.04)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=24:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('sur-vac')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')

#+END_SRC

#+RESULTS:
: 1498628.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python :results output org drawer
from ase.io.trajectory import Trajectory
from amp import Amp
from ase.io import read
import matplotlib.pyplot as plt
from vasp import Vasp
import numpy as np
from scipy.interpolate import interp1d

#images = Trajectory('A2B.traj')
images = read('trajectory/db10/333.traj@-9:')
calc1 = Amp(load = './networks/db10/18-18/checkpoint-parameters.json')

E, En, Edft = [], [], []

for image in images:
    image.set_calculator(calc1)
    En.append(image.get_potential_energy())

'''
for i in range (9):
    calc = Vasp('./NDFT/surface=fcc111/type=neb/class=vacancy/image={0}'.format(i))
    atoms = calc.get_atoms()
    E += [calc.potential_energy/len(atoms)]

for i in range (9):
    calc = Vasp('NDFT/surface=fcc111/type=neb_nn/class=surf_vac/image={}'.format(i))
    Edft += [calc.potential_energy/len(atoms)]
'''
#E = np.array(E)
En = np.array(En)
#Edft = np.array(Edft)
#E = E- E[0]
En = En-En[0]
#Edft = Edft- Edft[0]
x = range(len(En))
xarray = np.linspace(0, len(En))
#f1 = interp1d(x, E, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
#plt.plot(x, E, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
#plt.plot(x, Edft, 'ko')
#plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
plt.show()
#plt.savefig('figures/surf-vac-nn.png')
#+END_SRC

#+RESULTS:
:RESULTS:
:END:



* DFT time
#+BEGIN_SRC python :results output org drawer
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.ppn'] = 4
VASPRC['queue.walltime'] = '24:00:00'
Ne, nrg, res, s = [], [], [], []
calcs = []

a = range(50)
t = []
images = Trajectory('./database/db1/MD1-63-1.traj', 'r')
#Ne = [images[i].get_potential_energy() for i in a]
for i in a:
       
        calc = Vasp('NDFT/bulk=fcc/type=time/v_a=1_63/MD={}'.format(i),
                     xc='pbe',
                     kpts=[3, 3, 3],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        t += [calc.get_elapsed_time()/3600]
	calc.write_db('./database/db10/time/data.db', parser='=', overwrite=False) 

#+END_SRC

#+BEGIN_SRC python :results output org drawer
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.ppn'] = 4
VASPRC['queue.walltime'] = '24:00:00'
Ne, nrg, res, s = [], [], [], []
calcs = []

a = range(50)
t = []
nset = []
nset
#Ne = [images[i].get_potential_energy() for i in a]
for i in a:

    
    calc = Vasp('NDFT/bulk=fcc/type=time/v_a=1_63/MD={}'.format(i))
   # calc.calculate()
    etime =calc.get_elapsed_time()/3600
    
    t += [etime]
    
    if etime > 6:
        nset += [i]
print nset
plt.plot(a, t, 'o')
plt.show()
#plt.savefig('figures/temp.png')
#+END_SRC

#+RESULTS:
:RESULTS:
[3, 5, 7, 14, 27, 31, 38]
:END:


[[./figures/temp.png]]

#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
A = [3, 5, 7, 11, 14, 27, 31, 38, 39, 40, 49]
t1, t2 = [], []
for i in A:
    calc1 = Vasp('NDFT/bulk=fcc/type=time/v_a=1_63/MD={}'.format(i))
    calc2 = Vasp('NDFT/bulk=fcc/type=time/v_a=1_63_2/MD={}'.format(i))
    
    t1 += [calc1.get_elapsed_time()]
    t2 += [calc2.get_elapsed_time()]
xs
import matplotlib.pyplot as plt
plt.plot(range(len(t1)), t1, 'bo')
plt.plot(range(len(t2)), t2, 'ro')
plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.ppn'] = 4
VASPRC['queue.walltime'] = '24:00:00'

A = [3, 5, 7, 11, 14, 27, 31, 38, 39, 40, 49]

for i in A:
    calc = Vasp('NDFT/bulk=fcc/type=time/v_a=1_63/MD={}'.format(i))
    atoms = calc.get_atoms()
    calc = Vasp('NDFT/bulk=fcc/type=time/v_a=1_63_2/MD={}'.format(i),
                xc='pbe',
                kpts=[3, 3, 3],
                encut=350,
                nsw=0,
                atoms=atoms)
    calc.calculate()
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python :results output org drawer
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.ppn'] = 4
VASPRC['queue.walltime'] = '24:00:00'
Ne, nrg, res, s = [], [], [], []
calcs = []

a = range(50)
t = []

#Ne = [images[i].get_potential_energy() for i in a]
for i in a:
    atoms =Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD={}'.format(i)).get_atoms()
    
    calc = Vasp('NDFT/bulk=fcc/type=time/v_a=1_35/MD={}'.format(i),
                xc='pbe',
                kpts=[5, 5, 3],
                encut=350,
                nsw=0,
                atoms=atoms)
    calc.calculate()
    #t += [calc.get_elapsed_time()/3600]
#+END_SRC

#+BEGIN_SRC python :results output org drawer
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.ppn'] = 4
VASPRC['queue.walltime'] = '24:00:00'
Ne, nrg, res, s = [], [], [], []
calcs = []

a = range(50)
t = []

#Ne = [images[i].get_potential_energy() for i in a]
for i in a:
    atoms =Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD={}'.format(i)).get_atoms()
    
    calc = Vasp('NDFT/bulk=fcc/type=time/v_a=1_26/MD={}'.format(i),
                xc='pbe',
                kpts=[5, 5, 5],
                encut=350,
                nsw=0,
                atoms=atoms)
    calc.calculate()
    #t += [calc.get_elapsed_time()/3600]
#+END_SRC

#+BEGIN_SRC python :results output org drawer
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.ppn'] = 4
VASPRC['queue.walltime'] = '24:00:00'
Ne, nrg, res, s = [], [], [], []
calcs = []

a = range(50)
t = []

#Ne = [images[i].get_potential_energy() for i in a]
for i in a:
    atoms =Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_11/MD={}'.format(i)).get_atoms()
    
    calc = Vasp('NDFT/bulk=fcc/type=time/v_a=1_11/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 5],
                encut=350,
                nsw=0,
                atoms=atoms)
    calc.calculate()
    #t += [calc.get_elapsed_time()/3600]
#+END_SRC

#+BEGIN_SRC python :results output org drawer
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.ppn'] = 4
VASPRC['queue.walltime'] = '24:00:00'
Ne, nrg, res, s = [], [], [], []
calcs = []

a = range(50)
t = []

#Ne = [images[i].get_potential_energy() for i in a]
for i in a:
    atoms =Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_17/MD={}'.format(i)).get_atoms()
    
    calc = Vasp('NDFT/bulk=fcc/type=time/v_a=1_17/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 5, 5],
                encut=350,
                nsw=0,
                atoms=atoms)
    calc.calculate()
    #t += [calc.get_elapsed_time()/3600]
#+END_SRC

#+BEGIN_SRC python :results output org drawer
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.ppn'] = 4
VASPRC['queue.walltime'] = '24:00:00'
Ne, nrg, res, s = [], [], [], []
calcs = []

a = range(50)
t = []

#Ne = [images[i].get_potential_energy() for i in a]
for i in a:
    atoms =Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/MD={}'.format(i)).get_atoms()
    
    calc = Vasp('NDFT/bulk=fcc/type=time/v_a=1_7/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 9],
                encut=350,
                nsw=0,
                atoms=atoms)
    calc.calculate()
    #t += [calc.get_elapsed_time()/3600]
#+END_SRC
** write
#+BEGIN_SRC python :results output org drawer
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC

a = range(50)

for i in a:
        calc = Vasp('NDFT/bulk=fcc/type=time/v_a=1_63/MD={}'.format(i))
	calc.write_db('./database/db10/time/data.db', parser='=', overwrite=False)
	calc = Vasp('NDFT/bulk=fcc/type=time/v_a=1_47/MD={}'.format(i))
	calc.write_db('./database/db10/time/data.db', parser='=', overwrite=False)
        calc = Vasp('NDFT/bulk=fcc/type=time/v_a=1_35/MD={}'.format(i))
	calc.write_db('./database/db10/time/data.db', parser='=', overwrite=False) 
        calc = Vasp('NDFT/bulk=fcc/type=time/v_a=1_26/MD={}'.format(i))
	calc.write_db('./database/db10/time/data.db', parser='=', overwrite=False) 
        calc = Vasp('NDFT/bulk=fcc/type=time/v_a=1_17/MD={}'.format(i))
	calc.write_db('./database/db10/time/data.db', parser='=', overwrite=False) 
        calc = Vasp('NDFT/bulk=fcc/type=time/v_a=1_11/MD={}'.format(i))
	calc.write_db('./database/db10/time/data.db', parser='=', overwrite=False) 
        calc = Vasp('NDFT/bulk=fcc/type=time/v_a=1_7/MD={}'.format(i))
	calc.write_db('./database/db10/time/data.db', parser='=', overwrite=False) 
#+END_SRC

#+BEGIN_SRC python :results output org drawer
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np
from vasp import Vasp


T, Tn = [], []

with connect('database/db10/time/data.db') as db:
    for d in db.select(['v_a=1_63']):
        path = d.data.path

        calc = Vasp('{}'.format(path))

        time = calc.get_elapsed_time()
        db.update(d.id, etime=time)
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

#+BEGIN_SRC python :results output org drawer
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np
from vasp import Vasp


T, n = [], []

with connect('database/db10/time/data.db') as db:
    for d in db.select([]):
        n += [d.natoms]
	T += [d.etime/3600]

plt.plot(n, T, 'o')
plt.show()
#+END_SRC

#+BEGIN_SRC python
from ase.db import connect
from amp import Amp
import time

db = connect('./database/db10/time/data.db')
calc1 = Amp(load = './networks/db10/18-18/checkpoint-parameters.json')
#calc2 = Amp(load = './networks/db8/25-25/checkpoint-parameters.json')

for d in db.select():
    atoms = db.get_atoms(d.id)
    atoms.set_calculator(calc1)
    time1 = time.time()
    nrg1 = atoms.get_potential_energy()
    time2 = time.time()
    t = (time2-time1)*1000
#    atoms.set_calculator(calc2)
#    nrg2 = atoms.get_potential_energy()
    db.update(d.id, NN18 = nrg1, NNtime=t)
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np
from vasp import Vasp
import matplotlib.cm as cm
n, T, Tn = [], [], []
plt.figure()
numbers = set()
db = connect('database/db10/time/data.db') 
for d in db.select():
    n += [d.natoms]
    T += [d.etime/3600.]
    Tn += [d.NNtime]

plt.scatter(T, Tn, c=n)
cb = plt.colorbar()
cb.set_label('number of atoms')
plt.xlim([0, 10])
#plt.ylim([0, 1000])
plt.xlabel('DFT calculation time (h)')
plt.ylabel('NN calculation time (ms)')
plt.tight_layout()
plt.savefig('./figures/time-color-md.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/time-color-md.png]]
* Figure & Table
** MD comparison
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from vasp import Vasp
from vasp.vasprc import VASPRC



calc1 = Amp(load = './networks/db7/20-20/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db7/24-24/checkpoint-parameters.json')
images = Trajectory('./database/db5/perfect/MD.traj', 'r')
E1, E2 = [], []

for atoms in images:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in images:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

#E1 = np.array(E1)
#E2 = np.array(E2)

print E1
print E2

'''

import numpy as np
import matplotlib.pyplot as plt


plt.plot(range(len(E1)), E1, 'b-', label='NN1 prediction')
plt.plot(range(len(E2)), E2, 'r--', label='NN2 prediction')

plt.xlim((0, len(E1)))
plt.ylabel('Potential energy (eV)')

plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
#plt.savefig('./figures/sur-vac-5.png')
plt.show()
'''
#+END_SRC


#+BEGIN_SRC python
import matplotlib.pyplot as plt
import numpy as np

E1 = [-4.9886863350744335, -4.98708993301773, -4.986239354591937, -4.985998099867134, -4.985004366009107, -4.982944525227191, -4.983208607463974, -4.981883072848922, -4.984592026347449, -4.981668418450702, -4.980190333740592, -4.980468577084957, -4.982281341225994, -4.980553210182636, -4.975737205621396, -4.979236621867372, -4.975454616894665, -4.975315650841281, -4.9708980791867114, -4.975890036541204, -4.96836540357278, -4.966245375542796, -4.974285768845819, -4.961509694555171, -4.972948699288221, -4.966515209202764, -4.967436819807881, -4.966065672141282, -4.969403577163529, -4.957821966620372, -4.96984027686503, -4.96867522456542, -4.958306659570075, -4.964800426642645, -4.964717905000437, -4.964707053030668, -4.959757055795671, -4.959712346222894, -4.9492646033823275, -4.968672435654025, -4.960176595289338, -4.957365925827833, -4.967763631013662, -4.949792616002002, -4.9651380467535615, -4.9627828759861385, -4.959603449839799, -4.956347908625088, -4.957521943008582, -4.965287950232707, -4.948275487499553, -4.956749983192019, -4.955891794861899, -4.958427337639264, -4.952532717739011, -4.962108143681759, -4.9412603724651385, -4.943542731988856, -4.952282092273335, -4.947200316086756, -4.952633168364051, -4.951148126229219, -4.948582864015288, -4.944491760458098, -4.9588381743309835, -4.942266337529241, -4.9536888307750555, -4.933355065894256, -4.93707225268625, -4.943599551216388, -4.940211859272421, -4.94447824495196, -4.951433826111664, -4.9214484861425785, -4.942543863980594, -4.9419633611653015, -4.933315190923347, -4.929657544940428, -4.9254636606876705, -4.939889970925652, -4.942088930219244, -4.92903423981168, -4.924326270794384, -4.939417852364636, -4.940805854649668, -4.930182027845005, -4.953110080743233, -4.947241643424604, -4.94184223814702, -4.940426225353081, -4.934121775984833, -4.934168685500177, -4.940025892044994, -4.93612176031225, -4.947038614300135, -4.939065207868346, -4.948809711746245, -4.939814991289722, -4.946232151218018, -4.936158858324258, -4.949208871101892, -4.948315811219309, -4.935658758874695, -4.959271895669174, -4.946771041406994, -4.934806777243358, -4.957917872360409, -4.94110281827784, -4.954464754185309, -4.944805042571082, -4.945448389510181, -4.944124214542007, -4.949377526880272, -4.948514959404443, -4.94545759601027, -4.943439571084587, -4.949255222867448, -4.9392628274200625, -4.932856025321658, -4.938860790847865, -4.943000294406874, -4.95044519995279, -4.944568302405985, -4.940358209737731, -4.94739360868473, -4.949111468954928, -4.937682730840281, -4.9427866718599125, -4.954314899553596, -4.932085399105033, -4.939282031178448, -4.9509582730844155, -4.927981674733099, -4.947760040489351, -4.940338702046181, -4.937048659257365, -4.926435933647435, -4.954162518815889, -4.953163305813685, -4.9413121931362305, -4.947491222214689, -4.942850156742481, -4.947365142781161, -4.940520715033964, -4.944875057112829, -4.940863989846999, -4.9479515867956465, -4.943688377406885, -4.946638717021408, -4.938977986832848, -4.94470954672133, -4.937765795677182, -4.94980977443464, -4.941116862279122, -4.93672272408313, -4.941678971730566, -4.93731357221055, -4.940930854668742, -4.933213012187826, -4.9489917453597885, -4.948734054090229, -4.943739728120513, -4.952856862383987, -4.953808187854028, -4.952582241687812, -4.938036165329114, -4.949280542396882, -4.939999025515691, -4.937481968972766, -4.93683833971143, -4.956665031551564, -4.934759355432805, -4.9285029760746095, -4.9352900885837325, -4.947917637327118, -4.939914527267891, -4.924487407918168, -4.952444982586434, -4.931427149872592, -4.939692842367181, -4.919742794996031, -4.945086515222223, -4.937578634002919, -4.934572635466741, -4.942792330310414, -4.946428710023346, -4.932539323173227, -4.945191550890247, -4.929719927595412, -4.9489201215517715, -4.9545407137200375, -4.928325135140521, -4.9321026256147835, -4.934170337146871, -4.939882693405275, -4.953259264733915, -4.9240969647207224, -4.9365735280641445, -4.934781142277382, -4.947505501206273, -4.9415449245871725, -4.941352586384433, -4.933375388550886, -4.948423327506721, -4.93835226614485, -4.944040535904831, -4.9410592065018495, -4.950351185473226, -4.927322063794894, -4.946725875736844, -4.931229570294975, -4.950725038972367, -4.934809131989624, -4.931238033276537, -4.93832385706647, -4.946439070323041, -4.927730894960666, -4.923671245484963, -4.9542184226155905, -4.932643816487863, -4.939328472653381, -4.927695579453234, -4.9251930574704765, -4.930726215740796, -4.934639637680506, -4.916823894312172, -4.931306664398905, -4.92707020754714, -4.932169124834685, -4.936237040099461, -4.937273434572459, -4.931617986423434, -4.946072937392741, -4.9280239973295314, -4.935009134079825, -4.933373759260823, -4.918938025123219, -4.92736901686395, -4.912553243707359, -4.946233378550646, -4.9458891350951255, -4.9270504130776285, -4.933447359590874, -4.926300542718663, -4.94020396636169, -4.926048662354374, -4.92991350384658, -4.934760973945169, -4.926128999326373, -4.907038003110349, -4.928100172710417, -4.9154061414635315, -4.916922486442645, -4.93839574985139, -4.93152732649315, -4.922313515884286, -4.911193286509893, -4.9308026416452675, -4.939854472774388, -4.930630239804261, -4.9269624243295995, -4.937013232717896, -4.920956769506542, -4.9173232366734965, -4.9124072315318354, -4.9403968314726745, -4.919648052994128, -4.91842632078198, -4.9261945848884805, -4.907179451793881, -4.923026990712055, -4.906959617833943, -4.92110547088263, -4.915552195840487, -4.9182591732965095, -4.936181226685026, -4.918730206790267, -4.916978878423619, -4.902095441197283, -4.93580170707981, -4.942075146656114, -4.930145067654171, -4.927583618100519, -4.92798099953611, -4.928747209676397, -4.907502786223462, -4.932354554401228, -4.918518707009716, -4.932271139459543, -4.912551774842719, -4.920348695171284, -4.931502290076152, -4.907397693560389, -4.938940543261062, -4.939955798830292, -4.906107243641221, -4.939188061896283, -4.925589789139269, -4.927427498152004, -4.916683321135488, -4.947388804826167, -4.917621662489195, -4.894316727228502, -4.916791364262673, -4.897603076110285, -4.897434008043094, -4.919087095994182, -4.882225423969237, -4.917777182423927, -4.914988716745252, -4.891963662159802, -4.904989470708772, -4.918277214559209, -4.891311937142075, -4.897998745550369, -4.919435401675319, -4.917305985896531, -4.883989117807128, -4.915481837947463, -4.894504672603046, -4.912761619358679, -4.922476053646903, -4.899213368791797, -4.939160539591851, -4.9197800417497835, -4.928664350728407, -4.916228027303893, -4.921383300200059, -4.9066687067649095, -4.88950032521404, -4.902550201771476, -4.9036476637967965, -4.886858844046143, -4.929259189695916, -4.892766050968854, -4.908500930782184, -4.927363801308325, -4.920551783300103, -4.937547224252953, -4.905001036571395, -4.931315494170928, -4.905939196582346, -4.927836750269302, -4.929215168151295, -4.915514927700229, -4.9299137366822965, -4.901849525550594, -4.914626288057624, -4.908651929599978, -4.912456930957855, -4.924547103256761, -4.907854691833898, -4.885090227533398, -4.918432741839994, -4.918721245379592, -4.905464234006287, -4.922292050988514, -4.89910045144242, -4.897705693032789, -4.911831891461059, -4.901495502996605, -4.890039994547108, -4.898148993289583, -4.937870412658926, -4.927593975862536, -4.915651883930121, -4.922601508083915, -4.921920216548497, -4.924040930597402, -4.942578713003676, -4.913743504974205, -4.902691794379269, -4.909013496176137, -4.912728291178399, -4.908762248225875, -4.908850460061572, -4.912683053807378, -4.889502541473293, -4.877130705880859, -4.916674202370631, -4.922387779345983, -4.893596886763384, -4.912686030937458, -4.900511164785579, -4.90415692925503, -4.928797031150154, -4.909734302311936, -4.922032870781104, -4.951412333605131, -4.918423627143025, -4.938003759973968, -4.91880569463123, -4.940129387870529, -4.901105750847538, -4.923973762424816, -4.922527641160639, -4.900859527267928, -4.923216377195568, -4.918934536587463, -4.897687468308421]

E2 = [-4.988014033062972, -4.985933121648388, -4.985893446639678, -4.985551949120318, -4.984527200987393, -4.982999911037753, -4.9821225034915555, -4.981214261313618, -4.984768668264133, -4.980944526408267, -4.979589518915576, -4.980812605319883, -4.981584972112666, -4.97983477474109, -4.976487614906444, -4.977219826156832, -4.975784516493057, -4.97600311887399, -4.970271324200883, -4.976062777452372, -4.9701265082202815, -4.965392455299034, -4.975498157581016, -4.963594888692283, -4.971011914826672, -4.9649795902135825, -4.9693030094566435, -4.965221558495471, -4.969325411103461, -4.957457396340499, -4.968316710627368, -4.969130370158533, -4.960174901694591, -4.964468498844503, -4.9644783005217965, -4.965910066910922, -4.959465520130136, -4.960279065437778, -4.951145008286656, -4.967833373699263, -4.96030626026855, -4.956894489835226, -4.967903951566721, -4.950042953490779, -4.9670750869060765, -4.960602710306473, -4.9602167021424295, -4.9570395993014085, -4.957590039021518, -4.964449211167751, -4.949540876120655, -4.956011635429075, -4.958378169437074, -4.960848601019399, -4.9508082657449295, -4.962516513041199, -4.944636809462243, -4.946365541144946, -4.953370008394118, -4.949518613185178, -4.950157648645028, -4.9515428888065225, -4.94967052448537, -4.945122701665672, -4.95727035107091, -4.940363831822479, -4.9529259481181525, -4.931200172564358, -4.939389146970973, -4.940908716561899, -4.941235354818113, -4.943686988583153, -4.953712916541372, -4.91766879890173, -4.944968031575593, -4.944062794865489, -4.9369119402953405, -4.933070384442991, -4.92943714831412, -4.940300706584234, -4.9450577742155115, -4.931866515874455, -4.924130840256406, -4.940655768159885, -4.943395593234035, -4.92861524939057, -4.952871744128821, -4.949048135868577, -4.944599618574976, -4.938450302555085, -4.938441199942042, -4.938416216415538, -4.942725753373599, -4.9381964496058375, -4.947930733697649, -4.9390094382275125, -4.949243930327986, -4.93831046351695, -4.945054565487408, -4.932897271105546, -4.951135376785693, -4.946598916603865, -4.938275973611743, -4.960476977400387, -4.946707374326107, -4.9379378862614605, -4.960864828709559, -4.94183263173421, -4.956799328155206, -4.947596554016673, -4.948403836751653, -4.9449067404219225, -4.949815962852364, -4.94976089459551, -4.943845401695005, -4.945633083824808, -4.949097801661908, -4.938881723318353, -4.932532566684693, -4.941826385518172, -4.945988563899461, -4.953349701832565, -4.944983101750571, -4.941178836549526, -4.949475605351412, -4.952627952659993, -4.9404948006483, -4.9441517963453, -4.949085327235799, -4.934510271114507, -4.941279405894628, -4.951956801803681, -4.9228337950105345, -4.949756639169719, -4.935768830574345, -4.93980927432478, -4.925833526290297, -4.954481816030217, -4.951043976022896, -4.943090739347946, -4.950331217734731, -4.945768681998952, -4.947393368594013, -4.936095114778908, -4.947846419590222, -4.941045765491353, -4.947123407155055, -4.94613278693463, -4.944614542570404, -4.941423416814359, -4.948304628003303, -4.9379334169551345, -4.9480640798894076, -4.942498228949047, -4.9383125941580035, -4.944273056620894, -4.940126895226691, -4.94202557698414, -4.931175019971457, -4.9520139123159215, -4.950380276998741, -4.9459038541173195, -4.95434991547377, -4.9528950837512165, -4.954067515716105, -4.938630687128025, -4.951696306471347, -4.941133591846288, -4.938569907121603, -4.937219209377905, -4.958619911050472, -4.935407084976122, -4.928163005069465, -4.938026619976414, -4.95103482864476, -4.936402714165273, -4.927925424839211, -4.955023666294286, -4.932538219529248, -4.942647199114673, -4.923711715995111, -4.948795359523869, -4.94029703502096, -4.933763533685894, -4.944431761307679, -4.9430024395375955, -4.935242418824922, -4.94407047148434, -4.930026708299517, -4.947455628969926, -4.955040550425058, -4.930259948995222, -4.93068563203067, -4.933855372258879, -4.939389176121233, -4.954610182931112, -4.925208799650058, -4.9403540069435845, -4.933493839406488, -4.948201523804848, -4.9390750413418, -4.945401779644955, -4.93156551410777, -4.950473862702725, -4.940420142880994, -4.9447782865737615, -4.940521696427316, -4.954081284279839, -4.928676234980196, -4.949334965592795, -4.9345494266421195, -4.95301036315592, -4.933339125890824, -4.93489209939091, -4.938035681495543, -4.9476570060329905, -4.928048399694766, -4.92735538153863, -4.952061167842841, -4.934362192449885, -4.942370948791205, -4.930701293284611, -4.928132406775719, -4.932223631501924, -4.934886480999358, -4.919462999562417, -4.934922687324351, -4.9294023534305, -4.9350071909655195, -4.936685762316507, -4.939134947959374, -4.93310503254233, -4.94927471972811, -4.929720050493727, -4.936061171844999, -4.935893273038511, -4.922649242730172, -4.930801793089525, -4.913415991395128, -4.947344635285253, -4.947255078755928, -4.928209186211741, -4.932718249881952, -4.927685482267332, -4.939100336182763, -4.925382995848315, -4.933725841776803, -4.937582310441568, -4.9271659905260545, -4.911616377489184, -4.930564137655938, -4.9171862202445125, -4.919732172095236, -4.9404868381653895, -4.9338390852870315, -4.9232499947384145, -4.910941058488555, -4.932392788440273, -4.943687208835489, -4.930513763729764, -4.926058724857023, -4.93640432185469, -4.921774888896918, -4.921716015176321, -4.909352841827775, -4.939483124467169, -4.91868830403172, -4.921899113423773, -4.923579148916536, -4.906711594308755, -4.921166017679823, -4.905191443986764, -4.925655204277623, -4.9158551080207875, -4.916679483413367, -4.938001221959721, -4.918172336406568, -4.920826033706696, -4.902171925821433, -4.937921543178105, -4.943256490546536, -4.9332594144640876, -4.92906075126505, -4.931983325796767, -4.929503346665002, -4.909015354818488, -4.935738422229506, -4.916998182624736, -4.932994214935926, -4.916629983963304, -4.9207890937156495, -4.9334664563537665, -4.911855386289109, -4.940098024683714, -4.9388876752280835, -4.909797461011517, -4.94049343234682, -4.92605930809842, -4.929063792936184, -4.914869238255323, -4.947009495949926, -4.921395387980016, -4.89755811230114, -4.9187664520244585, -4.901137259164157, -4.90021421495503, -4.918113065696948, -4.885405434837554, -4.920041831016377, -4.914204069173406, -4.896479626493813, -4.909980944301901, -4.919070638669112, -4.892922119563886, -4.898595161981847, -4.923013002907075, -4.920821920688791, -4.887385887567818, -4.918782721660504, -4.897419323553814, -4.915074880562953, -4.925982748886588, -4.897682677508896, -4.9379102095196235, -4.9230922387271985, -4.931544107483501, -4.912938652745793, -4.921120704014495, -4.910154655727549, -4.892428717154388, -4.904227112833153, -4.9037766507170435, -4.8841655596913, -4.933646694383792, -4.897182306147737, -4.9120968630985455, -4.928391211217055, -4.924266747506764, -4.935755451794945, -4.90521998452896, -4.935674880902225, -4.9056317953319715, -4.925172015073956, -4.932163686535827, -4.915141589726035, -4.931119504989097, -4.9052588771911525, -4.91865173900903, -4.911702515502989, -4.91654056364896, -4.927786173479603, -4.911858089396755, -4.888867062244722, -4.919822789559373, -4.922377211509543, -4.909732730229882, -4.920853238757493, -4.900692611698529, -4.8998840848276775, -4.91495813100201, -4.9062370681414595, -4.894895589902857, -4.902614638334582, -4.93788584183147, -4.924272098704586, -4.918095853118422, -4.926560217193214, -4.920776704521088, -4.925763838076635, -4.943537310453465, -4.915674268175013, -4.908115950228192, -4.913522021006446, -4.913219081315793, -4.911750334574007, -4.912761845158884, -4.9165282617896615, -4.890004695867615, -4.88181344107704, -4.917504033302086, -4.919541546059745, -4.898645831736833, -4.9167976185975935, -4.902331937497866, -4.905842291676732, -4.9321636563475675, -4.9123293156970576, -4.923261429598031, -4.950237847524022, -4.918421849575189, -4.9385071544922265, -4.921217730536592, -4.943717446833661, -4.902190730042872, -4.92751190267786, -4.9224743588495645, -4.903868998644208, -4.9257692791525285, -4.919518203486277, -4.897956777075404]

E3 = E1[50::5]
E4 = E2[50::5]
'''
plt.plot(range(len(E3)), E3, 'b-', label='NN1 prediction')
plt.plot(range(len(E4)), E4, 'r--', label='NN2 prediction')

plt.xlim((0, len(E3)))
plt.ylabel('Potential energy (eV)')

plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
#plt.savefig('./figures/sur-vac-5.png')
plt.show()
'''
print E3
print E4
#+END_SRC



#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import spline

E1 = np.array([-4.948275487499553, -4.962108143681759, -4.950633168364051, -4.942266337529241, -4.941211859272421, -4.9449633611653015, -4.945088930219244, -4.928182027845005, -4.930521775984833, -4.939065207868346, -4.95008871101892, -4.93806777243358, -4.94940389510181, -4.945439571084587, -4.94580294406874, -4.952111468954928, -4.939282031178448, -4.94048659257365, -4.949491222214689, -4.940863989846999, -4.94470954672133, -4.940678971730566, -4.945734054090229, -4.938536165329114, -4.958665031551564, -4.939914527267891, -4.924742794996031, -4.946428710023346, -4.9505407137200375, -4.953259264733915, -4.9385449245871725, -4.944040535904831, -4.931229570294975, -4.948439070323041, -4.939828472653381, -4.916823894312172, -4.940273434572459, -4.93573759260823, -4.9458891350951255, -4.926048662354374, -4.930100172710417, -4.922313515884286, -4.9259624243295995, -4.9403968314726745, -4.923026990712055, -4.936181226685026, -4.942075146656114, -4.909502786223462, -4.920348695171284, -4.909107243641221, -4.947388804826167, -4.897434008043094, -4.891963662159802, -4.919435401675319, -4.912761619358679, -4.928664350728407, -4.902550201771476, -4.908500930782184, -4.935315494170928, -4.9311137366822965, -4.927547103256761]) 

E2 = np.array([-4.949540876120655, -4.962316513041199, -4.950157648645028, -4.942263831822479, -4.941235354818113, -4.944562794865489, -4.9450577742155115, -4.92861524939057, -4.938441199942042, -4.9390094382275125, -4.950835376785693, -4.9379378862614605, -4.949403836751653, -4.945633083824808, -4.945988563899461, -4.952627952659993, -4.941279405894628, -4.93980927432478, -4.950331217734731, -4.941045765491353, -4.948304628003303, -4.945273056620894, -4.950380276998741, -4.938630687128025, -4.958619911050472, -4.936402714165273, -4.923711715995111, -4.9430024395375955, -4.958040550425058, -4.954610182931112, -4.9390750413418, -4.9447782865737615, -4.9315494266421195, -4.9476570060329905, -4.942370948791205, -4.915462999562417, -4.939134947959374, -4.935893273038511, -4.947255078755928, -4.925382995848315, -4.930564137655938, -4.9232499947384145, -4.926058724857023, -4.939483124467169, -4.921166017679823, -4.938001221959721, -4.941256490546536, -4.909015354818488, -4.9207890937156495, -4.90797461011517, -4.947009495949926, -4.91021421495503, -4.89479626493813, -4.920013002907075, -4.914074880562953, -4.928044107483501, -4.903027112833153, -4.9120968630985455, -4.935674880902225, -4.931119504989097, -4.927786173479603]) 

from scipy.interpolate import interp1d
from scipy.interpolate import spline


x = np.linspace(0,600,61)
xarray = np.linspace(0, 600, 500)
S1 = spline(x, E1-E1[0], xarray)
S2 = spline(x, E2-E2[0]-0.001, xarray)
plt.plot(xarray, S1, 'b-', label='NN1')
plt.plot(xarray, S2, 'r-', label='NN2')
#plt.xticks([0, 0.01, 0.02])
plt.xlabel('Time Steps')
plt.ylabel('Reference Energy (eV/atom)')
plt.legend(loc = 'best')
plt.fill_between(xarray,
                 y1 = S1,
                 y2 = S2,
                 color='gray', alpha=0.40)
#plt.show()
plt.savefig('./figures/MD-comparison.png')
#+END_SRC

#+RESULTS:






[[./figures/MD-comparison.png]]
** MD validation
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from vasp import Vasp
from vasp.vasprc import VASPRC



calc1 = Amp(load = './networks/db7/20-20/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db7/24-24/checkpoint-parameters.json')
images = Trajectory('./database/db1/MD0-8-0.traj')

E1, E2 = [], []

for i in range(200):
    atoms = images[i]
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)


nrg, res, s = [], [], []
calcs = []

for i in range(200):        
    calc = Vasp('NDFT/bulk=fcc/type=validation/v_a=0_8/MD={}'.format(i))

    nrg += [calc.potential_energy/8]

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(6,4))

ax[0].plot(range(len(E1)), E1, 'b-', label='NN1')
ax[0].plot(range(len(E2)), E2, 'r--', label='NN2')
#ax[0].scatter(range(len(E1)), nrg, facecolor='none',
#	   edgecolor='r', label='DFT prediction')

ax[0].set_xlim((0, len(E1)))
ax[0].set_ylabel('Potential energy (eV)')

ax[0].legend(loc=2)

nrg = np.array(nrg)
error = nrg - E1
#print error
h = np.arange(len(E1))+1
ax[1].bar(h, error, color='gray', alpha=0.6)
ax[1].set_xlabel('Time step')
ax[1].set_ylabel('Error (eV/atom)')
plt.tight_layout()
plt.savefig('./figures/MD-validation.png')
#plt.show()

#+END_SRC

#+RESULTS:

[[./figures/MD-validation.png]]



#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from vasp import Vasp
from vasp.vasprc import VASPRC



calc1 = Amp(load = './networks/db8/18-18/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db8/25-25/checkpoint-parameters.json')
images = Trajectory('./database/db1/MD0-8-0.traj')

E1, E2 = [], []

for i in range(50):
    atoms = images[i]
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

E1 = np.array(E1)
E2 = np.array(E2)


nrg, res, s = [], [], []
calcs = []

for i in range(50):        
    calc = Vasp('NDFT/bulk=fcc/type=validation/v_a=0_8/MD={}'.format(i))

    nrg += [calc.potential_energy/8]

fig, ax = plt.subplots(2, 1, sharex=True, figsize=(6,4))

ax[0].plot(range(len(E1)), E1, 'b-', label='NN1')
ax[0].plot(range(len(E2)), E2, 'r--', label='NN2')
ax[0].scatter(range(len(E1)), nrg, facecolor='none',
	   edgecolor='k', alpha=0.8, label='DFT')

ax[0].set_xlim((0, len(E1)))
ax[0].set_ylabel('Potential energy \n [eV/atom]')
ax[0].set_yticks([-5.22, -5.18, -5.14, -5.10])
ax[0].legend(loc='best', fontsize='small')

nrg = np.array(nrg)
error = nrg - E1
#print error
h = np.arange(len(E1))+1
ax[1].bar(h, error, color='gray', alpha=0.6)
ax[1].set_xlabel('Time step')
ax[1].set_ylabel('DFT validation error \n [eV/atom]')
ax[1].set_yticks([-0.004, 0, 0.004, 0.008])
plt.tight_layout()
plt.savefig('./figures/MD-validation-2.png')
#plt.show()

#+END_SRC

#+RESULTS:

[[./figures/MD-validation-2.png]]
** EOS
#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState
from ase.db import connect
from amp import Amp
from ase.visualize import view
import os
import json
import time
from ase.units import kJ

db = connect('./database/db10/data.db')

f, ax = plt.subplots(1, 5, figsize = (12, 5))
tag = ['FCC', 'BCC', 'HCP', 'SC', 'Diamond']

for i, key in enumerate(['fcc', 'bcc', 'hcp', 'sc', 'diam']):

    V, Qe, Re, Ne = [], [], [], []

    for d in db.select(['bulk={0}'.format(key), 'type=eos']):
        V += [d.volume / d.natoms]
        Qe += [d.energy / d.natoms]
        Ne += [d.NN18 / d.natoms]

    srt = [j[0] for j in sorted(enumerate(V), key = lambda x:x[1])]
    V = np.array(V)[srt]
    Qe = np.array(Qe)[srt]
    Ne = np.array(Ne)[srt]

    ax[i].plot(V, Qe, 'k-', lw=2, label = 'DFT')
    ax[i].plot(V, Ne, 'r--', lw=2, label = 'Neural')

    if i >0:
        ax[i].set_yticklabels([])

    ax[i].set_ylim(-5.5 , -2)
    ax[i].set_xlim(10, 40)
    ax[i].set_xticks([15, 25, 35])
    ax[i].set_title('{0}'.format(tag[i]))

ax[0].set_ylabel('Potantial energy (eV/atom)')
ax[2].set_xlabel('Volume ($\AA$/atom)')
ax[4].legend(loc = 'best', fontsize = 12)
plt.tight_layout(w_pad=-1.3)
plt.savefig('./figures/eos-NN-8.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/eos-NN-8.png]]

** Training error distribution
#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db10/data.db')

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
E, nE, var, ind = [], [], [], []
for j, d in enumerate(db.select()):
#for j, d in enumerate(db.select([])):# dbkey=0
    E += [d.energy / d.natoms]
    nE += [d.NN18/ d.natoms]
    var += [j]
    ind += [d.train_set]

E = np.array(E)
nE = np.array(nE)
res = np.array(nE) - np.array(E)
mask = np.array(ind)
valid = np.ma.masked_array(res, mask)
train = np.ma.masked_array(res, ~mask)
vRMSE = np.sqrt(np.sum(valid ** 2)/ len(valid))
tRMSE = np.sqrt(np.sum(train ** 2)/ len(train))


ax0.text(200, -0.050,
           'Trained RMSE: {:.2f} meV/atom'.format(tRMSE * 1000),
           color='b', ha='left')
ax0.text(200, -0.057,
           'Validation RMSE: {:.2f} meV/atom'.format(vRMSE * 1000),
           color='r', ha='left')

ax0.scatter(var, train, color='b')
ax0.scatter(var, valid, color='r')
ax0.plot([min(var), max(var)], [0, 0], 'k--')
ax0.set_xlim(min(var), max(var))
ax0.set_ylim(-0.06, 0.06)
ax0.set_xlabel('Calculation ID')
ax0.set_title('8-18-18-1 framework')

(mu, sigma) = norm.fit(nE - E)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(nE-E, 50,
                            range = (-0.06, 0.06),
                            weights = np.ones_like(nE-E)/ len(nE),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.01, 0.04, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.01, 0.03, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.06, 0.06)
ax1.set_xlim(0, 0.25)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
ax1.set_title('Error Distribution')
plt.tight_layout(w_pad = -0.5)
plt.savefig('./figures/error-dist.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/error-dist.png]]
** Bulk Vacancy neb
#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d

#calc = Vasp('NDFT/bulk=fcc/type=neb/supercell=222/neb')
#images, energies = calc.get_neb()
En, E = [], []
calc2 = Amp(load = './networks/db10/18-18/checkpoint-parameters.json')
for i in range (9):
    calc = Vasp('./NDFT/bulk=fcc/type=neb/supercell=222/image={0}'.format(i))
    atoms = calc.get_atoms()
    E += [calc.potential_energy/len(atoms)]

    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()/len(atoms)]
E = np.array(E)
En = np.array(En)

E = E- E[0]
En = En-En[0]
x = range(len(E))
xarray = np.linspace(0, len(E))
f1 = interp1d(x, E, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(x, E, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 'best')
#plt.show()
plt.savefig('figures/bulk-vac.png')
#+END_SRC

#+RESULTS:

[[./figures/bulk-vac.png]]

#+BEGIN_SRC python :results output org drawer
from ase.io.trajectory import Trajectory
from amp import Amp
from ase.io import read
import matplotlib.pyplot as plt
from vasp import Vasp
import numpy as np
from scipy.interpolate import interp1d

#images = Trajectory('A2B.traj')
images = read('trajectory/db9/bulk-vac.traj@-9:')
calc1 = Amp(load = './networks/db10/18-18/checkpoint-parameters.json')

E, En = [], []

for image in images:
    image.set_calculator(calc1)
    En.append(image.get_potential_energy())


for i in range (9):
    calc = Vasp('./NDFT/bulk=fcc/type=neb/supercell=222/image={0}'.format(i))
    atoms = calc.get_atoms()
    E += [calc.potential_energy]

E = np.array(E)
En = np.array(En)
E = E- E[0]
En = En-En[0]
x = range(len(E))
xarray = np.linspace(0, len(E))
f1 = interp1d(x, E, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(x, E, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.ylim([-0.1, 0.75])
plt.xlabel('Images')
plt.ylabel('Reference Energy(eV)')
plt.annotate('NN, DFT $E^\\ddag$= {:1.2f}'.format(E[4]),
             xy=(4, E[4]), xytext=(1, E[4]),
	     ha='left', va='center', color='k',
             arrowprops=dict(arrowstyle="->",
                             shrinkB=10,
                             color='k'))
plt.legend(loc = 'best')
plt.savefig('figures/bulk-vac-nn.png')
#+END_SRC

#+RESULTS:
:RESULTS:
:END:


[[./figures/bulk-vac-nn.png]]
** adatom neb
#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d
from amp import Amp
calc0 = Amp(load = './networks/db9/18-18/checkpoint-parameters.json')

En = []
E1 = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=top').potential_energy
E2 = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=fcc').potential_energy
E3 = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/position=hcp').potential_energy
calc1 = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/class=top_fcc/neb')
images, energies1 = calc1.get_neb()
nrg1 = E1 + energies1

for atoms in images:
    atoms.set_calculator(calc0)
    En += [atoms.get_potential_energy()]
calc2 = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/class=fcc_hcp/neb')
images, energies2 = calc2.get_neb()
nrg2 = E2 + energies2

for atoms in images:
    atoms.set_calculator(calc0)
    En += [atoms.get_potential_energy()]

calc3 = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/class=hcp_top/neb')
images, energies3 = calc3.get_neb()
nrg3 = E3 + energies3

for atoms in images:
    atoms.set_calculator(calc0)
    En += [atoms.get_potential_energy()]
nrg = []
nrg.extend(nrg1)
nrg.extend(nrg2)
nrg.extend(nrg3)

print nrg
print En

#+END_SRC

#+RESULTS:
: [-103.16314489, -103.17362203, -103.22147716000001, -103.32938334000001, -103.48398825, -103.66603531, -103.84634143, -103.98241757, -104.02334307, -104.02334307, -103.99930865, -103.93616107, -103.88095009, -103.85664787, -103.86981663, -103.91413568999999, -103.96879078000001, -103.98963043000001, -103.98963043000001, -103.95344617000001, -103.82724601, -103.65909859999999, -103.48889736, -103.34291469, -103.23595949, -103.17862415, -103.16314489]
: [-103.18602724195243, -103.1835945762378, -103.23322160964435, -103.33499044314306, -103.4681963511034, -103.6135898228566, -103.7586268984079, -103.87871178030132, -103.92797417100765, -103.92797417100765, -103.90021353640988, -103.85287299393143, -103.81726365305819, -103.80555311381093, -103.8190807915432, -103.85427480688878, -103.90046136305304, -103.92777608970438, -103.92777608970438, -103.87978742505548, -103.76315882296697, -103.62194621921562, -103.47995415258693, -103.35035107665048, -103.24814275188515, -103.18902401325589, -103.18602724195243]

#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
nrg = np.array([-103.16314489, -103.17362203, -103.22147716000001, -103.32938334000001, -103.48398825, -103.66603531, -103.84634143, -103.98241757, -104.02334307, -104.02334307, -103.99930865, -103.93616107, -103.88095009, -103.85664787, -103.86981663, -103.91413568999999, -103.96879078000001, -103.98963043000001, -103.98963043000001, -103.95344617000001, -103.82724601, -103.65909859999999, -103.48889736, -103.34291469, -103.23595949, -103.17862415, -103.16314489])

En = np.array([-103.18602724195243, -103.1835945762378, -103.23322160964435, -103.33499044314306, -103.4681963511034, -103.6135898228566, -103.7586268984079, -103.87871178030132, -103.92797417100765, -103.92797417100765, -103.90021353640988, -103.85287299393143, -103.81726365305819, -103.80555311381093, -103.8190807915432, -103.85427480688878, -103.90046136305304, -103.92777608970438, -103.92777608970438, -103.87978742505548, -103.76315882296697, -103.62194621921562, -103.47995415258693, -103.35035107665048, -103.24814275188515, -103.18902401325589, -103.18602724195243])
#nrg = nrg - nrg[0]
#En = En- En[0]
nrg = nrg
En = En

nrg = nrg - nrg[0]
En = En - En[0]
x = range(len(nrg))
xarray = np.linspace(0, len(nrg))
f1 = interp1d(x, nrg, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(range(len(nrg)), nrg, 'bo', label = 'NEB')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlim([-1, 25])
plt.xticks([0, 8, 12, 16, 24], ['top', 'fcc', 'bridge', 'hcp', 'top'])
#plt.xticklabels()
plt.xlabel('Images')
plt.ylabel('Potential Energy(eV/atom)')
plt.legend(loc = 4)
plt.show()
#plt.savefig('./figures/surf-adatom-NEB.png')
#+END_SRC

#+RESULTS:


[[./figures/surface.png]]


#+BEGIN_SRC python
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import interp1d
from matplotlib.offsetbox import OffsetImage, AnnotationBbox
import matplotlib.image as mpimg
import os

nrg = np.array([-103.16314489, -103.17362203, -103.22147716000001, -103.32938334000001, -103.48398825, -103.66603531, -103.84634143, -103.98241757, -104.02334307, -103.99930865, -103.93616107, -103.88095009, -103.85664787, -103.86981663, -103.91413568999999, -103.96879078000001, -103.98963043000001, -103.95344617000001, -103.82724601, -103.65909859999999, -103.48889736, -103.34291469, -103.23595949, -103.17862415, -103.16314489])

En = np.array([-103.18233597408036, -103.18437873720981, -103.22284648570202, -103.31057481062057, -103.4390704004474, -103.59824385276374, -103.76909916055763, -103.90972556151868,  -103.96611171758107, -103.93807524063449, -103.88732887572675, -103.84545136139151, -103.8298515304951, -103.84428514224818, -103.88371075131808, -103.9338895295332, -103.96272954851156, -103.90659881511719, -103.76806877869788, -103.60234020552744, -103.44837157197468, -103.32355631431838, -103.23498430696414, -103.18835282438987, -103.18233597408036])
#nrg = nrg - nrg[0]
#En = En- En[0]
nrg = nrg
En = En

nrg = nrg - nrg[0]
En = En - En[0]
x = range(len(nrg))
xarray = np.linspace(0, len(nrg))
f1 = interp1d(x, nrg, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
fig = plt.figure(figsize=(6,4))
ax = fig.add_subplot(111)


image = mpimg.imread('./figures/surface.png')
imagebox = OffsetImage(image, zoom=0.3)

ax.add_artist(AnnotationBbox(imagebox,
                             xy=(12, -0.2),
                            # xybox=(6, -4.92),
                             pad = -0.2))
plt.plot(range(len(nrg)), nrg, 'bo', label = 'DFT')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlim([-1, 25])
plt.xticks([0, 8, 12, 16, 24], ['top', 'fcc', 'bridge', 'hcp', 'top'])
#plt.xticklabels()
#plt.yticks([-4.95, -4.94, -4.93, -4.92, -4.91])
plt.minorticks_on()
plt.xlabel('Images')
plt.ylabel('Reference Energy(eV)')
plt.legend(loc = 4)
plt.tight_layout()
#plt.show()
plt.savefig('./figures/adatom-NEB-8.png')
#+END_SRC

#+RESULTS:

[[./figures/adatom-NEB-8.png]]

#+BEGIN_SRC python :results output org drawer
import numpy as np

nrg = np.array([-103.16314489, -103.17362203, -103.22147716000001, -103.32938334000001, -103.48398825, -103.66603531, -103.84634143, -103.98241757, -104.02334307, -103.99930865, -103.93616107, -103.88095009, -103.85664787, -103.86981663, -103.91413568999999, -103.96879078000001, -103.98963043000001, -103.95344617000001, -103.82724601, -103.65909859999999, -103.48889736, -103.34291469, -103.23595949, -103.17862415, -103.16314489])

En = np.array([-103.18233597408036, -103.18437873720981, -103.22284648570202, -103.31057481062057, -103.4390704004474, -103.59824385276374, -103.76909916055763, -103.90972556151868,  -103.96611171758107, -103.93807524063449, -103.88732887572675, -103.84545136139151, -103.8298515304951, -103.84428514224818, -103.88371075131808, -103.9338895295332, -103.96272954851156, -103.90659881511719, -103.76806877869788, -103.60234020552744, -103.44837157197468, -103.32355631431838, -103.23498430696414, -103.18835282438987, -103.18233597408036])

print En[8]-En[12]
print nrg[8]-nrg[12]

print En[12]-En[16]
#+END_SRC

#+RESULTS:
:RESULTS:
-0.136260187086
-0.1666952
:END:


#+BEGIN_SRC python
import matplotlib.pyplot as plt
from ase.db import connect
import matplotlib.mlab as mlab
import numpy as np
from scipy.stats import norm
from matplotlib import gridspec
import matplotlib.patches as mpatches

db = connect('./database/db8/data.db')

S, Qe, Ne = [], [], []

for d in db.select(['type=elastic']):
    S += [d.bulk]
    Qe += [d.energy/d.natoms]
    Ne += [d.NN25/d.natoms]
    
S = np.array(S)
Qe = np.array(Qe)
Ne = np.array(Ne)

cmap, hdl = {}, []

#print Ne
for s, c in zip(set(S), ['b', 'r']):
    cmap[s] = c
    hdl +=[mpatches.Patch(color = c, label = s)]

c = []
for s in S:
    c +=[cmap[s]]

RMSE = np.sqrt(sum((Ne-Qe)** 2) / len(Ne - Qe))

(mu, sigma) = norm.fit(Ne- Qe)

fig = plt.figure(figsize = (6,4))
gs = gridspec.GridSpec(1, 2, width_ratios= [2, 1])
ax0 = plt.subplot(gs[0])
ax0.plot([min(Qe), 0], [0,0], 'k--', lw =2)
ax0.scatter(Qe, Ne-Qe, marker = 'o', color = c)
ax0.text(min(Qe) + 0.1, 0.14,
         'RMSE: {0:1.3f}'.format(RMSE),
         fontsize = 12, va = 'top', ha = 'left')
ax0.set_xlim(min(Qe), 0)
ax0.set_ylim(-0.05, 0.05)
ax0.set_xlabel('DFT potential energy (eV/atom)')
ax0.set_ylabel('Rsidual error (eV/atom)')
ax0.legend(loc = 'best', handles =hdl, fontsize = 8, frameon = False)

ax1 = plt.subplot(gs[1])
n, bins, patches = ax1.hist(Ne-Qe, 50,
                            range = (-0.05, 0.05),
                            weights = np.ones_like(Ne-Qe)/ len(Ne),
                            facecolor = 'k',
                            alpha = 0.5,
                            orientation = 'horizontal')

y = mlab.normpdf(bins, mu, sigma)
ax1.text(0.05, 0.142, '$\mu$: {0:1.3f}'.format(mu), fontsize=12, va='top', ha='left')
ax1.text(0.05, 0.122, '$\sigma$: {0:1.3f}'.format(sigma), fontsize=12, va='top', ha='left')
ax1.plot(y/sum(y), bins, 'k--', lw = 2)
ax1.plot([0,50], [0,0], 'k--', lw = 2)
ax1.set_xlabel('Probability')
ax1.set_ylim(-0.05, 0.05)
ax1.set_xlim(0, 0.3)
ax1.set_yticklabels([])
ax1.set_xticks(ax1.get_xticks()[1::2])
plt.tight_layout(w_pad = -0.5)

#plt.savefig('./figures/eos-residual-4.png')
plt.show()

#+END_SRC

#+RESULTS:

** Surface-vac
#+BEGIN_SRC python
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d
energies = []
En, E = [], []
#calc2 = Amp(load = './networks/db8/18-18/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db10/18-18/checkpoint-parameters.json')
#calc = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/neb')
#images, energies = calc.get_neb()
for i in range(9):
    calc = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/image={}'.format(i))
    energies += [calc.potential_energy]
    atoms = calc.get_atoms()

    atoms.set_calculator(calc2)
    En += [atoms.get_potential_energy()]

En = np.array(En)

En = En-En[0]
energies = np.array(energies)
energies = energies - energies[0]
x = range(len(En))
xarray = np.linspace(0, len(En))
f1 = interp1d(x, energies, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(x, energies, 'bo', label = 'DFT')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Images')
plt.ylabel('Reference Energy(eV)')
plt.annotate('DFT $E^\\ddag$= {:1.2f}'.format(energies[4]),
             xy=(4, energies[4]), xytext=(1, energies[4]),
	     ha='left', va='center', color='b',
             arrowprops=dict(arrowstyle="->",
                             shrinkB=10,
                             color='b'))
plt.annotate('NN $E^\\ddag$= {:1.2f}'.format(En[4]),
             xy=(4, En[4]), xytext=(1.1, En[4]),
	     ha='left', va='center', color='r',
             arrowprops=dict(arrowstyle="->",
                             shrinkB=10,
                             color='r'))
plt.legend(loc = 'best')
#plt.show()
plt.savefig('./figures/sur-vac-NEB-8.png')
#print (energies[4] - En[4])

#+END_SRC

#+RESULTS:

[[./figures/sur-vac-NEB-8.png]]
** Elastic constant
#+BEGIN_SRC python
from vasp import Vasp
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
import matplotlib.pyplot as plt
from amp import Amp
from ase.units import GPa

factor = np.linspace(0, 0.005, 6)
fspan = np.linspace(0, 0.005)

Ed1, En1, Vd1, Vn1 = [], [], [], []
Ed4, En4, Vd4, Vn4 = [], [], [], []

# FCC
for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=11/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed1.append(atoms.get_potential_energy())
    Vd1.append(atoms.get_volume()/len(atoms))

    #calc2 = Amp(load = './networks/db3/24-24/checkpoint-parameters.json')
    calc2 = Amp(load = './networks/db8/18-18/checkpoint-parameters.json')
    atoms.set_calculator(calc2)
    En1.append(atoms.get_potential_energy())

from scipy.optimize import curve_fit
def func(x, a, c):
    return a * x**2 + c

En1 = np.array(En1)*1000
Ed1 = np.array(Ed1)*1000

En1 = En1 - En1[0]
Ed1 = Ed1 - Ed1[0]
poptd, pcovd = curve_fit(func, factor, Ed1/Vd1[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En1/Vd1[0])
print poptn

plt.subplot(2, 1, 1)
plt.plot(factor, Ed1/Vd1[0], 'bo', label = 'DFT')
plt.plot(factor, En1/Vd1[0], 'ro', label = 'NN')
plt.plot(fspan, func(fspan, *poptd), 'b-', label = 'DFT fit')
plt.plot(fspan, func(fspan, *poptn), 'r-', label = 'NN fit')
#plt.ylim([0, 1.5e-4])
#plt.yticks([0, 5e-5, 1e-4, 1.5e-4])
#plt.minorticks_on()
plt.ticklabel_format(style='sci', axis='y', scilimits=(0,0))
plt.xlabel('Strain 1')
plt.ylabel('Energy Density (meV/$\AA^3$)')
plt.legend(loc='best')

for x in factor:
    wd = 'NDFT/bulk=fcc/type=elastic/dirs=44/factor={0:1.3f}'.format(x)
       
    calc1 = Vasp(wd) 
    atoms = calc1.get_atoms()
    Ed4.append(atoms.get_potential_energy())
    Vd4.append(atoms.get_volume()/len(atoms))

   # calc2 = Amp(load = './networks/db6/24-24/checkpoint-parameters.json')

    atoms.set_calculator(calc2)
    En4.append(atoms.get_potential_energy())

En4 = np.array(En4)*1000
Ed4 = np.array(Ed4)*1000

En4 = En4 - En4[0]
Ed4 = Ed4 - Ed4[0]
poptd, pcovd = curve_fit(func, factor, Ed4/Vd4[0])
print poptd

poptn, pcovn = curve_fit(func, factor, En4/Vd4[0])
print poptn

#plt.savefig('./figures/elastic-1.png')
plt.subplot(2, 1, 2)
plt.plot(factor, Ed4/Vd4[0], 'bo', label = 'DFT')
plt.plot(factor, En4/Vd4[0], 'ro', label = 'NN')
plt.plot(fspan, func(fspan, *poptd), 'b-', label = 'DFT fit')
plt.plot(fspan, func(fspan, *poptn), 'r-', label = 'NN fit')
#plt.yticks([0, 1e-5, 2e-5])
#plt.ticklabel_format(style='sci', axis='y', scilimits=(0,0))
plt.minorticks_on()
plt.xlabel('Strain 2')
plt.ylabel('Energy Density (meV/$\AA^3$)')
plt.legend(loc='best')

plt.tight_layout()
#plt.show()
plt.savefig('./figures/els-cons-10.png')
#+END_SRC

#+RESULTS:
: [  2.29184361e+03   4.14043580e-04]
: [  3.47161089e+03   9.51585299e-05]
: [  7.89468938e+02   7.28327012e-04]
: [  8.39472679e+02  -1.15493091e-06]

[[./figures/els-cons-10.png]]


[[./figures/els-cons-8.png]]

** Bulk properties
*** Cohesive energy
#+BEGIN_SRC python
from vasp import Vasp
from amp import Amp
calc1 = Amp(load= './networks/db10/18-18/checkpoint-parameters.json')

calc = Vasp ('./NDFT/atomic-Pd') 
Eatom = calc.potential_energy
 
calc = Vasp ('./NDFT/bulk=fcc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEfcc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEfcc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=bcc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEbcc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEbcc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=hcp/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEhcp = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEhcp = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=sc/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEsc = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEsc = atoms.get_potential_energy()/len(atoms)

calc = Vasp ('./NDFT/bulk=diam/type=eos/factor=1.00') 
atoms = calc.get_atoms()
DEdiam = atoms.get_potential_energy()/len(atoms)

atoms.set_calculator(calc1)
NEdiam = atoms.get_potential_energy()/len(atoms)
print DEfcc-Eatom, NEfcc-Eatom
print DEbcc-Eatom, NEbcc-Eatom
print DEhcp-Eatom, NEhcp-Eatom
print DEsc-Eatom, NEsc-Eatom
print DEdiam-Eatom, NEdiam-Eatom
#+END_SRC

#+RESULTS:
: -3.75476834 -3.75561820342
: -3.71312559 -3.74562837141
: -3.72459561 -3.75710647995
: -3.2532599 -3.25822304362
: -2.6162620675 -2.61543522701

*** Bulk Modulus
#+BEGIN_SRC python
from ase.db import connect
import matplotlib.pyplot as plt
from ase.utils.eos import EquationOfState
from ase.units import kJ
import numpy as np
from vasp import Vasp
from amp import Amp

factor = np.arange(0.85, 1.2, 0.01)
#calc2 = Amp(load = './database/db1/2-24-2/-parameters-checkpoint-0.json')
         
calc2 = Amp(load= './networks/db10/18-18/checkpoint-parameters.json')

configs = ['fcc', 'bcc', 'hcp', 'sc', 'diam']

for config in configs:
    nrg, vol = [], []
    nn = []
    for f in factor:
        calc = Vasp('./NDFT/bulk={0}/type=eos/factor={1:.2f}'.format(config,f))
        atoms = calc.get_atoms()
        nrg += [atoms.get_potential_energy()/len(atoms)]
        vol += [atoms.get_volume()/len(atoms)]
        atoms.set_calculator(calc2)
        nn +=[atoms.get_potential_energy()/len(atoms)]
        

    vol = np.array(vol)
    nrg = np.array(nrg)
    nn = np.array(nn)
# Fit the data to SJEOS
    eos = EquationOfState(vol, nrg)
    v0, e0, B0 = eos.fit()
    eos = EquationOfState(vol, nn)
    v1, e1, B1 = eos.fit()
    print '{0}'.format(config)
    print v0, e0, B0*160.2177
    print v1, e1, B1*160.2177
#+END_SRC

#+RESULTS:
#+begin_example
fcc
15.2979724806 -5.22438476072 175.450329406
15.2906822239 -5.21893680712 175.866213229
bcc
15.4257962561 -5.18249419589 170.583471265
15.4431541675 -5.19040783745 171.572730556
hcp
15.3645769219 -5.19379582623 173.442639001
15.3190169139 -5.21708645503 176.228338775
sc
17.8024966568 -4.72110919112 125.360569608
17.7913453214 -4.72568301907 125.831130644
diam
24.3558101786 -4.08130798908 68.5972094168
24.3898320926 -4.07968512319 67.9378995573
#+end_example

** 111 surface
*** surface energy
#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc111
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc = Amp(load='./networks/db10/18-18/checkpoint-parameters.json')
#calc = Amp(load='./networks/db6/24-24/checkpoint-parameters.json')

calc1 = Vasp('NDFT/bulk=fcc/type=eos/factor=1.00')
Eb = calc1.potential_energy
atoms=calc1.get_atoms()
atoms.set_calculator(calc)
Ebn = atoms.get_potential_energy()

calc2 = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00')
Es = calc2.potential_energy
atoms = calc2.get_atoms()
cell = atoms.get_cell()
atoms.set_calculator(calc)
nrg = atoms.get_potential_energy()

#print Es
#print nrg
#print (Es-nrg)/30
area = np.cross(cell[0], cell[1])

Ed =  Es - Eb * 20
#En =  nrg - (-5.21529201133) * 20
En =  nrg - (Ebn) * 20

A = 2 * area[-1]
print area
print A
Ed = Ed /A
En = En /A


print Ed
print En


#+END_SRC

#+RESULTS:
: [  0.           0.          26.87401709]
: 53.7480341727
: 0.0827259238117
: 0.0846739464305

#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc111
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc = Amp(load='./networks/db10/18-18/checkpoint-parameters.json')
#calc = Amp(load='./networks/db6/24-24/checkpoint-parameters.json')

calc1 = Vasp('NDFT/bulk=fcc/type=eos/factor=1.00')
Eb = calc1.potential_energy
atoms=calc1.get_atoms()
atoms.set_calculator(calc)
Ebn = atoms.get_potential_energy()

calc2 = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=33/factor=1.00')
Es = calc2.potential_energy
atoms = calc2.get_atoms()
cell = atoms.get_cell()
atoms.set_calculator(calc)
nrg = atoms.get_potential_energy()

#print Es
#print nrg
#print (Es-nrg)/30
area = np.cross(cell[0], cell[1])

Ed =  Es - Eb * 45
#En =  nrg - (-5.21529201133) * 20
En =  nrg - (Ebn) * 45

A = 2 * area[-1]
print area
print A
Ed = Ed /A
En = En /A


print Ed
print En


#+END_SRC

#+RESULTS:
: [  0.          0.         60.4665384]
: 120.933076805
: 0.082677685164
: 0.0847158120747

#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc111
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc = Amp(load='./networks/db10/18-18/checkpoint-parameters.json')
#calc = Amp(load='./networks/db6/24-24/checkpoint-parameters.json')

calc1 = Vasp('NDFT/bulk=fcc/type=eos/factor=1.00')
Eb = calc1.potential_energy
atoms=calc1.get_atoms()
atoms.set_calculator(calc)
Ebn = atoms.get_potential_energy()

calc2 = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=34/factor=1.00')
Es = calc2.potential_energy
atoms = calc2.get_atoms()
cell = atoms.get_cell()
atoms.set_calculator(calc)
nrg = atoms.get_potential_energy()

#print Es
#print nrg
#print (Es-nrg)/30
area = np.cross(cell[0], cell[1])

Ed =  Es - Eb * 60
#En =  nrg - (-5.21529201133) * 20
En =  nrg - (Ebn) * 60

A = 2 * area[-1]
print area
print A
Ed = Ed /A
En = En /A

print Ed
print En
#+END_SRC

#+RESULTS:
: [  0.           0.          80.62205126]
: 161.244102518
: 0.0830074695507
: 0.0847499912437

#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc111
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc = Amp(load='./networks/db10/18-18/checkpoint-parameters.json')
#calc = Amp(load='./networks/db6/24-24/checkpoint-parameters.json')

calc1 = Vasp('NDFT/bulk=fcc/type=eos/factor=1.00')
Eb = calc1.potential_energy
atoms=calc1.get_atoms()
atoms.set_calculator(calc)
Ebn = atoms.get_potential_energy()

calc2 = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=44/factor=1.00')
Es = calc2.potential_energy
atoms = calc2.get_atoms()
cell = atoms.get_cell()
atoms.set_calculator(calc)
nrg = atoms.get_potential_energy()

#print Es
#print nrg
#print (Es-nrg)/30
area = np.cross(cell[0], cell[1])

Ed =  Es - Eb * 80
#En =  nrg - (-5.21529201133) * 20
En =  nrg - (Ebn) * 80

A = 2 * area[-1]
print area
print A
Ed = Ed /A
En = En /A

print Ed
print En
#+END_SRC

#+RESULTS:
: [   0.            0.          107.49606835]
: 214.992136691
: 0.0832692544274
: 0.0847406222967

*** vacancy formation
#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc111
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc1 = Vasp('NDFT/bulk=fcc/type=eos/factor=1.00')
Eatomic = calc1.potential_energy

calc2 = Vasp('NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=22')
Ev = calc2.potential_energy

calc3 = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00')
Es = calc3.potential_energy

calc = Amp(load='./networks/db10/18-18/checkpoint-parameters.json')

atoms = fcc111('Pd', size=(2, 2, 5), a = 3.939,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgs = atoms.get_potential_energy()


atoms = fcc111('Pd', size=(2, 2, 5), a = 3.939,  vacuum=6.0)
del atoms[-1]
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgv = atoms.get_potential_energy()
print Ev, nrgv
print Es, nrgs
print Ev - Es + Eatomic
print nrgv - nrgs + Eatomic
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  19:08:47      -99.762439       0.2581
BFGS:   1  19:08:59      -99.768400       0.2279
BFGS:   2  19:09:11      -99.782055       0.1123
BFGS:   3  19:09:24      -99.782602       0.0967
BFGS:   4  19:09:36      -99.782555       0.0249
BFGS:   0  19:09:47      -93.675840       0.5328
BFGS:   1  19:09:58      -93.693620       0.4823
BFGS:   2  19:10:09      -93.747498       0.1775
BFGS:   3  19:10:20      -93.752089       0.3015
BFGS:   4  19:10:30      -93.754045       0.2705
BFGS:   5  19:10:41      -93.757282       0.0744
BFGS:   6  19:10:52      -93.757751       0.0716
BFGS:   7  19:11:03      -93.760895       0.0497
-93.77503405 -93.7608951846
-99.84304382 -99.7825546981
0.85353979
0.807189533457
#+end_example

#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc111
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc1 = Vasp('NDFT/bulk=fcc/type=eos/factor=1.00')
Eatomic = calc1.potential_energy

calc2 = Vasp('NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=23')
Ev = calc2.potential_energy

calc3 = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=23/factor=1.00')
Es = calc3.potential_energy

calc = Amp(load='./networks/db10/18-18/checkpoint-parameters.json')

atoms = fcc111('Pd', size=(2, 3, 5), a = 3.939,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgs = atoms.get_potential_energy()


atoms = fcc111('Pd', size=(2, 3, 5), a = 3.939,  vacuum=6.0)
del atoms[-1]
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgv = atoms.get_potential_energy()
print Ev, nrgv
print Es, nrgs
print Ev - Es + Eatomic
print nrgv - nrgs + Eatomic
#+END_SRC

#+RESULTS:
#+begin_example
BFGS:   0  22:50:30     -149.643658       0.2686
BFGS:   1  22:50:55     -149.652168       0.2526
BFGS:   2  22:51:19     -149.670459       0.1700
BFGS:   3  22:51:44     -149.671608       0.1396
BFGS:   4  22:52:08     -149.667276       0.0984
BFGS:   5  22:52:32     -149.663378       0.0799
BFGS:   6  22:52:57     -149.658885       0.0713
BFGS:   7  22:53:21     -149.652763       0.0835
BFGS:   8  22:53:46     -149.644671       0.0973
BFGS:   9  22:54:10     -149.641172       0.0822
BFGS:  10  22:54:35     -149.644104       0.0684
BFGS:  11  22:54:59     -149.647663       0.0550
BFGS:  12  22:55:23     -149.650672       0.0445
BFGS:   0  22:55:46     -143.592135       0.5017
BFGS:   1  22:56:09     -143.611508       0.4572
BFGS:   2  22:56:31     -143.671295       0.2026
BFGS:   3  22:56:54     -143.675305       0.2796
BFGS:   4  22:57:17     -143.677018       0.2704
BFGS:   5  22:57:39     -143.674863       0.1298
BFGS:   6  22:58:02     -143.674751       0.1029
BFGS:   7  22:58:25     -143.674964       0.1179
BFGS:   8  22:58:47     -143.673694       0.1060
BFGS:   9  22:59:10     -143.668501       0.0969
BFGS:  10  22:59:33     -143.662257       0.1394
BFGS:  11  22:59:56     -143.658309       0.1551
BFGS:  12  23:00:18     -143.655938       0.1514
BFGS:  13  23:00:41     -143.653645       0.1272
BFGS:  14  23:01:04     -143.651963       0.0926
BFGS:  15  23:01:27     -143.652148       0.0863
BFGS:  16  23:01:49     -143.653710       0.0663
BFGS:  17  23:02:12     -143.655108       0.0583
BFGS:  18  23:02:35     -143.655448       0.0458
-143.63339034 -143.655447524
-149.74914397 -149.650672175
0.90128365
0.78075467083
#+end_example

#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc111
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc1 = Vasp('NDFT/bulk=fcc/type=eos/factor=1.00')
Eatomic = calc1.potential_energy

calc2 = Vasp('NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=33')
Ev = calc2.potential_energy

calc3 = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=33/factor=1.00')
Es = calc3.potential_energy

calc = Amp(load='./networks/db10/18-18/checkpoint-parameters.json')

atoms = fcc111('Pd', size=(3, 3, 5), a = 3.939,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgs = atoms.get_potential_energy()


atoms = fcc111('Pd', size=(3, 3, 5), a = 3.939,  vacuum=6.0)
del atoms[-1]
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgv = atoms.get_potential_energy()
print Ev, nrgv
print Es, nrgs
print Ev - Es + Eatomic
print nrgv - nrgs + Eatomic
#+END_SRC

#+BEGIN_example
BFGS:   0  09:19:33     -224.465487       0.3255
BFGS:   1  09:20:22     -224.478491       0.3094
BFGS:   2  09:21:11     -224.500201       0.2166
BFGS:   3  09:22:00     -224.503330       0.1745
BFGS:   4  09:22:49     -224.496430       0.1342
BFGS:   5  09:23:38     -224.483100       0.1146
BFGS:   6  09:24:27     -224.467363       0.1271
BFGS:   7  09:25:16     -224.447075       0.1355
BFGS:   8  09:26:05     -224.417629       0.1596
BFGS:   9  09:26:54     -224.401040       0.1821
BFGS:  10  09:27:43     -224.408730       0.1577
BFGS:  11  09:28:32     -224.422533       0.1183
BFGS:  12  09:29:22     -224.432530       0.0755
BFGS:  13  09:30:11     -224.432896       0.0618
BFGS:  14  09:31:00     -224.421328       0.0542
BFGS:  15  09:31:49     -224.408777       0.0516
BFGS:  16  09:32:38     -224.400225       0.0477
BFGS:   0  09:33:24     -218.428203       0.4263
BFGS:   1  09:34:11     -218.451541       0.3842
BFGS:   2  09:34:58     -218.522519       0.1948
BFGS:   3  09:35:44     -218.522245       0.2544
BFGS:   4  09:36:31     -218.518080       0.2463
BFGS:   5  09:37:18     -218.505449       0.1994
BFGS:   6  09:38:05     -218.500280       0.1405
BFGS:   7  09:38:51     -218.500136       0.1517
BFGS:   8  09:39:38     -218.498466       0.1451
BFGS:   9  09:40:24     -218.488995       0.1372
BFGS:  10  09:41:11     -218.471339       0.1511
BFGS:  11  09:41:58     -218.455568       0.1816
BFGS:  12  09:42:44     -218.444109       0.1868
BFGS:  13  09:43:31     -218.432267       0.1689
BFGS:  14  09:44:18     -218.423812       0.1271
BFGS:  15  09:45:04     -218.424887       0.1032
BFGS:  16  09:45:51     -218.431939       0.0751
BFGS:  17  09:46:37     -218.438956       0.0668
BFGS:  18  09:47:24     -218.442862       0.0470
-218.47332036 -218.442862065
-224.65268225 -224.400225274
0.96489191
0.74289322
#+END_example

#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc111
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc1 = Vasp('NDFT/bulk=fcc/type=eos/factor=1.00')
Eatomic = calc1.potential_energy

calc2 = Vasp('NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=34')
Ev = calc2.potential_energy

calc3 = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=34/factor=1.00')
Es = calc3.potential_energy

calc = Amp(load='./networks/db10/18-18/checkpoint-parameters.json')

atoms = fcc111('Pd', size=(3, 4, 5), a = 3.939,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgs = atoms.get_potential_energy()

atoms = fcc111('Pd', size=(3, 4, 5), a = 3.939,  vacuum=6.0)
del atoms[-1]
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgv = atoms.get_potential_energy()
print Ev, nrgv
print Es, nrgs
print Ev - Es + Eatomic
print nrgv - nrgs + Eatomic
#+END_SRC

#+BEGIN_EXAMPLE
BFGS:   0  14:31:51     -299.287316       0.3616
BFGS:   1  14:33:05     -299.303961       0.3285
BFGS:   2  14:34:19     -299.321716       0.1888
BFGS:   3  14:35:33     -299.324891       0.1554
BFGS:   4  14:36:47     -299.306714       0.0938
BFGS:   5  14:38:01     -299.294822       0.1086
BFGS:   6  14:39:15     -299.275808       0.1118
BFGS:   7  14:40:29     -299.257339       0.1219
BFGS:   8  14:41:43     -299.240092       0.1256
BFGS:   9  14:42:57     -299.239594       0.1211
BFGS:  10  14:44:11     -299.248631       0.0959
BFGS:  11  14:45:25     -299.257370       0.0780
BFGS:  12  14:46:39     -299.261609       0.0641
BFGS:  13  14:47:53     -299.256120       0.0611
BFGS:  14  14:49:07     -299.245785       0.0620
BFGS:  15  14:50:20     -299.236830       0.0574
BFGS:  16  14:51:34     -299.230698       0.0643
BFGS:  17  14:52:48     -299.231881       0.0650
BFGS:  18  14:54:02     -299.239933       0.0624
BFGS:  19  14:55:16     -299.248341       0.0573
BFGS:  20  14:56:30     -299.255025       0.0500
BFGS:   0  14:57:44     -293.247932       0.5276
BFGS:   1  14:58:55     -293.274560       0.4812
BFGS:   2  15:00:07     -293.344007       0.2172
BFGS:   3  15:01:18     -293.337185       0.3169
BFGS:   4  15:02:29     -293.334661       0.2948
BFGS:   5  15:03:40     -293.311746       0.1194
BFGS:   6  15:04:52     -293.310223       0.1228
BFGS:   7  15:06:03     -293.308285       0.1317
BFGS:   8  15:07:14     -293.302011       0.1289
BFGS:   9  15:08:26     -293.288070       0.0978
BFGS:  10  15:09:37     -293.277146       0.0896
BFGS:  11  15:10:48     -293.272377       0.0849
BFGS:  12  15:12:00     -293.270418       0.0854
BFGS:  13  15:13:11     -293.269086       0.0706
BFGS:  14  15:14:23     -293.268324       0.0813
BFGS:  15  15:15:34     -293.268442       0.0730
BFGS:  16  15:16:46     -293.269158       0.0767
BFGS:  17  15:17:57     -293.269967       0.0704
BFGS:  18  15:19:09     -293.270208       0.0633
BFGS:  19  15:20:20     -293.269904       0.0608
BFGS:  20  15:21:32     -293.269582       0.0469
-218.47332036 -293.26958173
-224.65268225 -299.25502511
0.96489191
0.770973399939
#+END_EXAMPLE

#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc111
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc1 = Vasp('NDFT/bulk=fcc/type=eos/factor=1.00')
Eatomic = calc1.potential_energy

calc2 = Vasp('NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=44')
Ev = calc2.potential_energy

calc3 = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=44/factor=1.00')
Es = calc3.potential_energy

calc = Amp(load='./networks/db10/18-18/checkpoint-parameters.json')

atoms = fcc111('Pd', size=(4, 4, 5), a = 3.939,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgs = atoms.get_potential_energy()

atoms = fcc111('Pd', size=(4, 4, 5), a = 3.939,  vacuum=6.0)
del atoms[-1]
constraint = FixAtoms(mask=[atom.tag > 3 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgv = atoms.get_potential_energy()
print Ev, nrgv
print Es, nrgs
print Ev - Es + Eatomic
print nrgv - nrgs + Eatomic
#+END_SRC

** 211 surface
*** vacancy formation
**** step
#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc11
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc1 = Vasp('NDFT/bulk=fcc/type=eos/factor=1.00')
Eatomic = calc1.potential_energy

calc2 = Vasp('NDFT/surface=fcc211/type=vacancy/site=edge')
Ev = calc2.potential_energy

calc3 = Vasp('NDFT/surface=fcc211/type=relaxation/supercell=33',)
Es = calc3.potential_energy

calc = Amp(load='./networks/db10/18-18/checkpoint-parameters.json')

atoms = fcc211('Pd', size=(3, 3, 5), a = 3.939,  vacuum=6.0)
#del atoms[0]
constraint = FixAtoms(mask=[atom.z < 10.05 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgs = atoms.get_potential_energy()

atoms = fcc211('Pd', size=(3, 3, 5), a = 3.939,  vacuum=6.0)
del atoms[0]
constraint = FixAtoms(mask=[atom.z < 10.05 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgv = atoms.get_potential_energy()
print Ev, nrgv
print Es, nrgs
print Ev - Es + Eatomic
print nrgv - nrgs + Eatomic
#+END_SRC

**** terrace
#+BEGIN_SRC python
from amp import Amp
from vasp import Vasp
import numpy as np
from ase.lattice.surface import fcc11
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.optimize import BFGS
from ase.constraints import FixAtoms

calc1 = Vasp('NDFT/bulk=fcc/type=eos/factor=1.00')
Eatomic = calc1.potential_energy

calc2 = Vasp('NDFT/surface=fcc211/type=vacancy/site=terrace')
Ev = calc2.potential_energy

calc3 = Vasp('NDFT/surface=fcc211/type=relaxation/supercell=33',)
Es = calc3.potential_energy

calc = Amp(load='./networks/db10/18-18/checkpoint-parameters.json')

atoms = fcc211('Pd', size=(3, 3, 5), a = 3.939,  vacuum=6.0)
constraint = FixAtoms(mask=[atom.z < 10.05 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgs = atoms.get_potential_energy()

atoms = fcc211('Pd', size=(3, 3, 5), a = 3.939,  vacuum=6.0)
del atoms[6]
constraint = FixAtoms(mask=[atom.z < 10.05 for atom in atoms])
atoms.set_constraint(constraint)
atoms.set_calculator(calc)

dyn = BFGS(atoms)
dyn.run(fmax=0.05)

nrgv = atoms.get_potential_energy()
print Ev, nrgv
print Es, nrgs
print Ev - Es + Eatomic
print nrgv - nrgs + Eatomic
#+END_SRC

*** NEB
#+BEGIN_SRC python :results output org drawer
import  matplotlib.pyplot as plt
from vasp import Vasp
from amp import Amp
import numpy as np
from scipy.interpolate import interp1d
plt.figure(figsize=(6,4))
plt.subplot(121)
calc1 = Amp(load = './networks/db10/18-18/checkpoint-parameters.json') 
E, En = [], []
c0 = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/shifted=True/relaxed=False/position=step0')
atoms = c0.get_atoms()
E += [atoms.get_potential_energy()]
atoms.set_calculator(calc1)
En += [atoms.get_potential_energy()]
for i in [1, 2, 3]:
    calc = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/shifted=True/relaxed=False/s-s-neb/image={}'.format(i))
    atoms = calc.get_atoms()
    E += [atoms.get_potential_energy()]
    atoms.set_calculator(calc1)
    En += [atoms.get_potential_energy()]
c1 = Vasp('NDFT/surface=fcc211/type=neb/class=vacancy/shifted=True/relaxed=False/position=step1')
atoms = c1.get_atoms()
E += [atoms.get_potential_energy()]
atoms.set_calculator(calc1)
En += [atoms.get_potential_energy()]

E = np.array(E)
E = E - E[0]
En = np.array(En)
En = En - En[0]
x = range(len(E))
xarray = np.linspace(0, len(E))
f1 = interp1d(x, E, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(range(len(E)), E, 'bo', label = 'DFT')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xticks([0, 1, 2, 3, 4])
plt.xlabel('Vacancy diffusion')
plt.ylabel('Reference Energy(eV)')
'''
plt.annotate('$E^\\ddag_$= {0:1.2f}'.format(E[2]),
             xy=(2, E[2]), xytext=(0, E[2]),
	     ha='left', va='center', color='b',
             arrowprops=dict(arrowstyle="->",
                             shrinkB=10,
                             color='b'))
plt.annotate('NN $E^\\ddag$= {:1.2f}'.format(En[2]),
             xy=(2, En[2]), xytext=(0.5, En[2]),
	     ha='left', va='center', color='r',
             arrowprops=dict(arrowstyle="->",
                             shrinkB=10,
                             color='r'))
'''
plt.legend(loc = 'best')

plt.subplot(122)
E, En = [], []
c0 = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge0')
atoms = c0.get_atoms()
E += [atoms.get_potential_energy()]
atoms.set_calculator(calc1)
En += [atoms.get_potential_energy()]
for i in [2, 4, 6]:

    calc = Vasp('NDFT/surface=fcc211/type=test/shifted=True/class=adatom/s-s-adatom/image={}'.format(i))
    atoms = calc.get_atoms()
    E += [atoms.get_potential_energy()]
    atoms.set_calculator(calc1)
    En += [atoms.get_potential_energy()]
c1 = Vasp('NDFT/surface=fcc211/type=test/fix=True/site=edge')
atoms = c1.get_atoms()
E += [atoms.get_potential_energy()]
atoms.set_calculator(calc1)
En += [atoms.get_potential_energy()]

E = np.array(E)
E = E - E[0]
En = np.array(En)
En = En - En[0]

x = range(len(E))
xarray = np.linspace(0, len(E))
f1 = interp1d(x, E, kind='cubic', bounds_error=False)
f2 = interp1d(x, En, kind='cubic', bounds_error=False)
plt.plot(range(len(E)), E, 'bo', label = 'DFT')
plt.plot(x, En, 'ro', label = 'NN')
plt.plot(xarray, f1(xarray), 'b-')
plt.plot(xarray, f2(xarray), 'r-')
plt.xlabel('Adatom diffusion')
'''
plt.annotate('$E_{DFT}^\\ddag$= {:1.2f}'.format(E[2]),
             xy=(2, E[2]), xytext=(0.5, E[2]),
	     ha='left', va='center', color='b',
             arrowprops=dict(arrowstyle="->",
                             shrinkB=10,
                             color='b'))
#plt.annotate('$E_{DNN}^\\ddag$= {:1.2f}'.format(En[2]),
             xy=(2, En[2]), xytext=(0.5, En[2]),
	     ha='left', va='center', color='r',
             arrowprops=dict(arrowstyle="->",
                             shrinkB=10,
                             color='r'))
'''
#plt.ylabel('Potential Energy(eV)')
plt.xticks([0, 1, 2, 3, 4])
plt.legend(loc = 'best')
plt.tight_layout()
#plt.show()
plt.savefig('figures/211-diffusion.png')
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

** Diffusion
#+BEGIN_SRC python 
from ase.io.trajectory import Trajectory
import numpy as np
from ase.io import read
from ase.visualize import view
import matplotlib.pyplot as plt
from pycse import regress

mdset= [ ['1st', '3rd', '4th','5th', '6th', '7th'], #800
         ['1st', '3rd', '4th','5th', '6th', '7th','8th'], #900
        # ['1st', '3rd', '4th','5th', '6th', '7th'], #1000
         ['1st', '2nd', '3rd', '4th','5th', '7th','8th'],#1100k
         ['1st', '2nd', '3rd', '4th','5th', '6th', '7th','8th'],
         ['1st', '2nd', '3rd', '4th','5th', '6th', '7th','8th'],
         ['1st', '2nd', '3rd', '5th','6th', '7th', '8th']] #1500K
start = [800, 900,  600, 700, 700, 1100]
Tset = np.array([800, 900, 1100, 1200, 1300, 1500])
colorset = ['b', 'g', 'r', 'c', 'm', 'y']
Diff = []
plt.figure()
plt.subplot(121)
for t,T in enumerate(Tset):
    msd = np.zeros(300)
    s = start[t]
    md = mdset[t]
    for n, p in enumerate(md):
        images = read('database/db11/2e5-12/{0}-{1}/MD.traj@{2}:{3}:'.format(T,p,s, (s+300)))
        r2 = [0]
        total = range(len(images))
        del total[0]

        for i in total:
            p0 = images[i-1].positions[20]
            p1 = images[i].positions[20]
            dist = np.linalg.norm(p1-p0)**2
            r2.append(dist+r2[-1])
        r2 = np.array(r2)
        msd = r2 + msd

    time = range(len(r2))

    time = np.delete(time, 0)
    time = np.array(time) * 10

    msd = np.delete(msd, 0)
    ave = np.array(msd)/len(md)
    D = ave/time

    X = np.column_stack([time, time**0])
    p, pint, se = regress(X, ave, 0.05)
    Diff.append(p[0])
    plt.plot(time, np.dot(X, p), '{0}-'.format(colorset[t]))
    plt.plot(time, ave, '{0}--'.format(colorset[t]), label='{0}K'.format(T))
plt.legend(loc='best')
plt.minorticks_on()
plt.xlim([min(time), max(time)])
plt.ylim([0, 1.1])
plt.xlabel('Time (fs)')
plt.ylabel('MSD ($\AA^2$)')

plt.subplot(122)
Diff= np.array(Diff)/1e5/4
Diff = np.log(Diff)
Tinv = 1.0/Tset*1000
plt.plot(Tinv, Diff,'o')
from scipy import stats
slope, inter, r, p, std = stats.linregress(Tinv, Diff)
plt.plot(Tinv, slope*Tinv+inter)
plt.text(0.80, -21.0, '$lnD={0:.2f}/T - {1:.2f}$'.format(slope*1000, abs(inter)))
plt.text(0.90, -21.06, '$R^2={0:.3f}$'.format(r**2))
plt.text(0.90, -21.12, '$E={0:.3f} eV$'.format(abs(slope)*8.314*0.01036)) # unit conversion
plt.xlim([0.6, 1.4])
plt.xlabel('1000/T')
plt.ylabel('lnD')
plt.tight_layout()
plt.savefig('figures/msd-comp-2.png')
#+END_SRC

** Time comparison
*** keywords
[24, 25, 26, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 1508, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1527, 1528, 1529, 1531, 1533, 1535, 1537, 1539, 1541, 1542, 1544, 1546, 1548, 1549, 1551, 1552, 1554, 1556, 2249]
#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

from ase.db import connect

db = connect('./database/db10/data.db')
data = db.select(['id=2080'])

keys, cnt = {}, 0
for entry in data:
    cnt += 1
    for k, v in entry.key_value_pairs.iteritems():
        
        if k in keys:
            keys[k] += [v]
        else:
            keys[k] = [v]

print ('{0:15s} {1:15s} {2} calculations total'.format('keyword', 'value',cnt))

print('------------------------------------------------------')

for k, v in keys.iteritems():
    vals = list(set(v))
    if len(vals) <= 5:
        val = ", ".join(str(e) for e in vals)
        print('{0:15}: {1}'.format(k, val))

    else:
        val = ", ".join(str(e)[:5] for e in vals[:5])
        print('{0:15s}:{1}, etc...'.format(k, val))
#+END_SRC

#+RESULTS:
#+begin_example
keyword         value           1 calculations total
------------------------------------------------------
NN25           : -143.679974751
NN15           : -143.668257882
train_set      : True
NNtime         : 282.76014328
NN24           : -143.685207274
NN18           : -143.646033019
dbkey          : 4
etime          : 197843.206
supercell      : 23
surface        : fcc111
vrelax         : False
type           : vacancy
structure      : surface
NN20           : -143.699113634
#+end_example

#+BEGIN_SRC python :results output org drawer
import numpy as np
from ase.db import connect
ids = []
db = connect('database/db10/data.db')
for i, d in enumerate(db.select('')):

    if d.NNtime > 900:
   # if d.etime > 100*3600:
        ids += [i]

print ids
#+END_SRC

#+RESULTS:
:RESULTS:
[24, 25]
:END:

#+BEGIN_SRC python 
from vasp import Vasp
wd ='./NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell=344/factor=0.900'
calc = Vasp(wd)
print calc.get_elapsed_time()

#+END_SRC

#+RESULTS:
: 221211.571

#+BEGIN_SRC python 
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np
from vasp import Vasp


T, Tn = [], []

with connect('database/db10/data.db') as db:
    for d in db.select([]):
        path = d.data.path
	print path

        calc = Vasp('{}'.format(path))

        time = calc.get_elapsed_time()
        db.update(d.id, etime=time)
	#T += d.data
	#Tn += [d.NNtime]
#print T

#+END_SRC

#+BEGIN_SRC python
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np
from vasp import Vasp

T, Tn, idset = [], [], []
E = []
with connect('database/db10/data.db') as db:
#    for d in db.select(['id>2800', 'id<3000']):
    for d in db.select(['v_a=1_63','order=md2']):
        T += [d.etime/3600.]
	E += [d.energy]
	Tn += [d.NNtime]
	idset += [d.id]
print len(E)
plt.plot(idset,T,'o')
#plt.ylabel('DFT calculation time (h)')
#plt.xlabel('DFT energy (eV)')
#print len(T)
plt.savefig('figures/time.png')
#plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

[[./figures/time.png]]

#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
a = range(50)
md = []
for i in a:
       
        calc = Vasp('NDFT/bulk=fcc/type=md/order=md2/v_a=1_63/MD={}'.format(i))
	t = calc.get_elapsed_time()
	if t > 3600*80:
	    md += [i]
print md
#+END_SRC

#+RESULTS:
:RESULTS:
[3, 5, 11, 14, 31]
:END:


**** re-check 1:63
#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from vasp import Vasp
import matplotlib.pyplot as plt
from vasp.vasprc import VASPRC
VASPRC['queue.ppn'] = 4
Ne, nrg, res, s = [], [], [], []
calcs = []

a = [3, 5, 11, 14, 31]
images = Trajectory('./database/db1/MD1-63-1.traj', 'r')
Ne = [images[i].get_potential_energy() for i in a]
for i in a:
       
        calc = Vasp('NDFT/bulk=fcc/type=time/v_a=1_63/MD={}'.format(i),
                     xc='pbe',
                     kpts=[3, 3, 3],
                     encut=350,
                     nsw=0,
                     atoms=images[i])
        calcs +=[calc] 
[calc.set_memory() for calc in calcs]
nrg = [calc.potential_energy for calc in calcs]
Vasp.stop_if(None in nrg)
'''
plt.plot(range(len(Ne)), Ne, 'b-', label='NN prediction')
plt.scatter(range(len(nrg)), nrg, facecolor='none',
	   edgecolor='r', label='DFT prediction')

plt.xlim((0, len(Ne)))
plt.ylabel('Potential energy (eV)')


plt.xlabel('Time step')
plt.legend(loc=2)

plt.tight_layout()
plt.savefig('./figures/1-63md-2.png')
'''
#+END_SRC

*** slice relaxation
#+BEGIN_SRC python
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np
from vasp import Vasp

idset = []
with connect('database/db10/data.db') as db:
    for d in db.select(['type=md']):
    #        T = d.etime/3600.
        T = d.etime/3600
	Tn = d.NNtime
	if Tn > 800:
	    idset.append(d.id)

print idset
#+END_SRC

#+RESULTS:
: [846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 1509, 1510, 1511, 1512, 1513, 1514, 1515, 1516, 1517, 1518, 1519, 1520, 1521, 1522, 1523, 1524, 1525, 1528, 1529, 1530, 1532, 1534, 1536, 1538, 1540, 1542, 1543, 1545, 1547, 1549, 1550, 1552, 1553, 1555, 1557]



: [1526, 1527, 1531, 1533, 1535, 1537, 1539, 1541, 1544, 1546, 1548, 1551, 1554, 1556]

#+BEGIN_SRC python
from amp import Amp
from amp.descriptor import *
from amp.regression import *

from ase.db import connect

db = connect('./database/db10/data.db')
data = db.select(['etime > 60 * 3600'])

keys, cnt = {}, 0
for entry in data:
    cnt += 1
    for k, v in entry.key_value_pairs.iteritems():
        
        if k in keys:
            keys[k] += [v]
        else:
            keys[k] = [v]

print ('{0:15s} {1:15s} {2} calculations total'.format('keyword', 'value',cnt))

print('------------------------------------------------------')

for k, v in keys.iteritems():
    vals = list(set(v))
    if len(vals) <= 5:
        val = ", ".join(str(e) for e in vals)
        print('{0:15}: {1}'.format(k, val))

    else:
        val = ", ".join(str(e)[:5] for e in vals[:5])
        print('{0:15s}:{1}, etc...'.format(k, val))
#+END_SRC

#+RESULTS:
: keyword         value           0 calculations total
: ------------------------------------------------------

#+BEGIN_SRC python 
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np
from vasp import Vasp


T, Tn = [], []
#idset = [2250, 2251, 2252, 2253, 2254, 2255, 2256, 2257, 2258, 2259, 2260, 2261, 2262]
idset=[28]

db = connect('database/db10/data.db') 
for i in idset:
    for d in db.select(['id={}'.format(i)]):
        time = d.etime/3
        db.update(d.id, etime=time)


#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np
from vasp import Vasp

T, Tn = [], []
plt.figure()
numbers = set()
A = [2963, 2964, 2965, 2966, 2967, 2968, 2969, 2970, 2971, 2972, 2973, 2974, 2975, 2976, 2977, 2978, 2979, 2980, 2981, 2982, 2983, 2984, 2985, 2986, 2987, 2988, 2989, 2990, 2991, 2992, 2993, 2994, 2995, 2996, 2997, 2998, 2999]
db = connect('database/db10/data.db') 
for d in db.select(['id=A']):
    n = d.natoms
    T = d.etime/3600.
    Tn = d.NNtime
    numbers.add(n)
    if n < 3:
        plt.plot(T, Tn, 'bo')

    elif n >= 3 and n < 9:
        plt.plot(T, Tn,'ro')

    elif n >= 9 and n < 28:
        plt.plot(T, Tn, 'co')

    elif n>=28 and n< 48:
        plt.plot(T, Tn, 'mo')

    else:
        plt.plot(T, Tn, 'yo')

plt.xlabel('DFT calculation time (h)')
plt.ylabel('NN calculation time (ms)')
#plt.xlim([0,20])
#print len(T)
#plt.savefig('figures/time.png')
plt.show()

print numbers
#+END_SRC

#+RESULTS:
: set([])

#+BEGIN_SRC python
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np
from vasp import Vasp
import matplotlib.cm as cm
n, T, Tn = [], [], []
plt.figure()
numbers = set()
db = connect('database/db10/data.db') 
for d in db.select(['type=md','structure=bulk']):
    n += [d.natoms]
    T += [d.etime/3600.]
    Tn += [d.NNtime]

plt.scatter(T, Tn, c=n)
cb = plt.colorbar()
cb.set_label('number of atoms')
plt.xlim([0, 120])
plt.ylim([0, 1000])
plt.xlabel('DFT calculation time (h)')
plt.ylabel('NN calculation time (ms)')
plt.tight_layout()
plt.savefig('./figures/time-color.png')
#plt.show()
#+END_SRC

#+RESULTS:

[[./figures/time-color.png]]
*** DFT
#+BEGIN_SRC python :tangle example-dft.py
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase import Atoms, Atom
from ase.lattice.cubic import FaceCenteredCubic
from ase.visualize import view
import numpy as np
# VASPRC['queue.ppn'] = 4

# VASPRC['mode'] = 'run'
wd = './NDFT/bulk=fcc/type=time/node=30/supercell=344'

fcc = FaceCenteredCubic('Pd',
                        directions=[[0, 1, 1],
                                    [1, 0, 1],
                                    [1, 1, 0]],
                        latticeconstant = 3.939)


atoms = fcc.repeat([3, 4, 4])

calc = Vasp(wd,
            xc='pbe',
            encut=350,
            kpts = [4, 3, 3],
            nsw = 0,
            atoms = atoms)
#calc.set_memory()
# calc.calculate()
calc.write_input()
#calc.calculate()
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python 
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase import Atoms, Atom
from ase.lattice.cubic import FaceCenteredCubic
from ase.visualize import view
import numpy as np
from xml.etree.ElementTree import ParseError
from ase.visualize import view
import matplotlib.pyplot as plt

VASPRC['queue.ppn'] = 4
VASPRC['queue.men'] = '4GB'

energies = []
nrange = [1, 2, 3, 4]
krange = [12, 6, 4, 3]
t = []
N = []
for xk, xn in zip (krange, nrange):
    for yk, yn in zip (krange, nrange):
        for zk, zn in zip (krange, nrange):
	    #print ('supercell={}{}{}'.format(xn, yn, zn))
	    #print ('kgrid = {},{},{}'.format(xk, yk, zk))

	    fcc = FaceCenteredCubic('Pd',
                                    directions=[[0, 1, 1],
                                                [1, 0, 1],
                                                [1, 1, 0]],
				    latticeconstant = 3.939)


            atoms = fcc.repeat([xn, yn, zn])

            #view(atoms)
            wd = './NDFT/bulk=fcc/type=time/supercell={}{}{}'.format(xn, yn, zn)

	    k = [xk, yk, zk]


            try:
             #   print(k)
                calc = Vasp(wd,
                            xc='pbe',
                            encut=350,
                            kpts = k,
                            nsw = 0,
                            atoms = atoms)
                N += [len(atoms)]
                t += [calc.get_elapsed_time()]
              #  print(t)
            except(ParseError):
                pass
t = np.array(t)
t = np.log(t)
plt.plot(N, t, 'o')
plt.show()
#+END_SRC


#+BEGIN_SRC python 
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import time
#cells = [111, 112, 122, 222, 233, 333, 334, 344,444]
cells = [111, 222, 333, 444]
t,n, tn = [],[], []
t2 = []
calc1 = Amp(load = './networks/db10/18-18/checkpoint-parameters.json')

for cell in cells:
    wd = './NDFT/bulk=fcc/type=time/node=30/supercell={}'.format(cell)
    calc = Vasp(wd)
    t += [calc.get_elapsed_time()]
    atoms = calc.get_atoms()
    n += [len(atoms)]
    atoms.set_calculator(calc1)
    time1 = time.time()
    nrg1 = atoms.get_potential_energy()
    time2 = time.time()
    tn += [(time2-time1)]

    wd2 = './NDFT/bulk=fcc/type=time/supercell={}'.format(cell)
    calc = Vasp(wd2)
    t2 += [calc.get_elapsed_time()]
import numpy as np
n = np.array(n)
t = np.array(t)
tn = np.array(tn)
t2 = np.array(t2)
'''
X = np.column_stack([n, n**0])

XTX = np.dot(X.T, X)
XTt = np.dot(X.T, t)
p1 = np.dot(np.linalg.inv(XTX), XTt)
slope1, intercept1 = p1 # note the order in X

XTtn = np.dot(X.T, tn)
p2 = np.dot(np.linalg.inv(XTX), XTtn)
slope2, intercept2 = p2 # note the order in X
plt.plot(n, t, 'bo-', label = 'DFT time')
plt.plot(n, tn, 'ro-', label = 'NN time')

plt.plot(n, np.dot(X, p1), 'b--')
plt.plot(n, np.dot(X, p2), 'r--')
plt.yscale('log')
plt.xscale('log')
'''
plt.plot(n, t, 'bo-', label = 'DFT time')
plt.plot(n, tn, 'ro-', label = 'NN time')
plt.yscale('log')
plt.xscale('log')
#plt.plot(n, t2, 'go-')
plt.xlabel('number of atoms')
plt.ylabel('Calculation time (s)')
plt.legend(loc = 'best')
plt.savefig('figures/time-natom.png')
#+END_SRC

#+RESULTS:

[[./figures/time-natom.png]]


#+BEGIN_SRC python 
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import time
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
#cells = [111, 112, 122, 222, 233, 333, 334, 344,444]
#cells = [111, 222, 333, 444]
factor = range(10)
del factor[0]
t,n, tn = [],[], []
t2 = []
calc1 = Amp(load = './networks/db10/18-18/checkpoint-parameters.json')

for i in factor:
    fcc = FaceCenteredCubic('Pd',
                            directions=[[0, 1, 1],
                                        [1, 0, 1],
                                        [1, 1, 0]],
                            latticeconstant = 3.939)


    atoms = fcc.repeat([i, i, i])

    n += [len(atoms)]
    atoms.set_calculator(calc1)
    time1 = time.time()
    nrg1 = atoms.get_potential_energy()
    time2 = time.time()
    tn += [(time2-time1)/len(atoms)]

tn = np.array(tn)

plt.plot(n, tn, 'ro-', label = 'NN time')
plt.yscale('log')
plt.xscale('log')
#plt.plot(n, t2, 'go-')
plt.xlabel('number of atoms')
plt.ylabel('Calculation time (s)')
plt.legend(loc = 'best')
plt.savefig('figures/time-natoms.png')
#plt.show()
#+END_SRC

[[./figures/time-natoms.png]]
#+BEGIN_SRC python 
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import time
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np
#cells = [111, 112, 122, 222, 233, 333, 334, 344,444]
#cells = [111, 222, 333, 444]
factor = range(20)
del factor[0]
t,n, tn = [],[], []
t2 = []
calc1 = Amp(load = './networks/db10/18-18/checkpoint-parameters.json')

for i in factor:
    fcc = FaceCenteredCubic('Pd',
                            directions=[[0, 1, 1],
                                        [1, 0, 1],
                                        [1, 1, 0]],
                            latticeconstant = 3.939)


    atoms = fcc.repeat([i, i, i])

    n += [len(atoms)]
    atoms.set_calculator(calc1)
    time1 = time.time()
    nrg1 = atoms.get_potential_energy()
    time2 = time.time()
    tn += [(time2-time1)]

tn = np.array(tn)

plt.plot(n, tn, 'ro-', label = 'NN time')
plt.yscale('log')
plt.xscale('log')
#plt.plot(n, t2, 'go-')
plt.xlabel('number of atoms')
plt.ylabel('Calculation time (s)')
plt.legend(loc = 'best')
#plt.savefig('figures/time-scaled.png')
#plt.show()
#+END_SRC

#+RESULTS:

c[[./figures/time-scaled.png]]

#+BEGIN_SRC python 
from vasp import Vasp
import matplotlib.pyplot as plt
from amp import Amp
import time
from ase.lattice.cubic import FaceCenteredCubic
import numpy as np

lib = ['1_7', '1_11', '1_17', '1_26', '1_35', '1_47', '1_63']
factor = range(11)
del factor[0]
t,n, tn = [],[], []
t2 = []
calc1 = Amp(load = './networks/db10/18-18/checkpoint-parameters.json')

for i in lib:
    calc = Vasp('./NDFT/bulk=fcc/type=time/v_a={}/MD=15'.format(i))
    atoms = calc.get_atoms()
    n += [len(atoms)]
    t += [calc.get_elapsed_time()]
    atoms.set_calculator(calc1)
    time1 = time.time()
    nrg1 = atoms.get_potential_energy()
    time2 = time.time()
    tn += [(time2-time1)]

tn = np.array(tn)
#tn = tn * 1000

#plt.plot(n, tn, 'bo-', label='NN time (ms)')
print n
print t
print tn
plt.plot(n, tn, 'bo-', label='NN time (ms)')
plt.plot(n, t, 'ro-', label='DFT time (s)')
plt.legend(loc = 'best')
plt.xscale('log')
plt.yscale('log')
plt.xlim([min(n), max(n)])
plt.tight_layout()
plt.savefig('figures/dft-nn-scaled.png')
#+END_SRC

#+RESULTS:
: [7, 11, 17, 26, 35, 47, 63]
: [938.259, 1617.507, 2792.971, 4209.309, 7525.029, 11140.172, 15887.258]
: [ 0.11947584  0.16230106  0.23157191  0.34352183  0.46748304  0.63103104
:   0.85861421]

[[./figures/dft-nn-scaled.png]]

#+BEGIN_SRC python 
import numpy as np
from pycse import deriv, regress
import matplotlib.pyplot as plt
n = np.array([7, 11, 17, 26, 35, 47, 63])
t = np.array([938.259, 1617.507, 2792.971, 4209.309, 7525.029, 11140.172, 15887.258])
tn = np.array([0.11947584, 0.16230106, 0.23157191, 0.34352183,  0.46748304, 0.63103104, 0.85861421])

tn = tn 
x = np.log10(n)
y1 = np.log10(t)
y2 = np.log10(tn)

X = np.column_stack([x**0, x])

p1, pint1, se1 = regress(X, y1, 0.05)
p2, pint2, se2 = regress(X, y2, 0.05)

print p1
print p2
plt.plot(n, t, 'bo', label='DFT time (s)')
plt.plot(n, 10**(np.dot(X, p1)), 'b--')

plt.plot(n, tn, 'ro', label='NN time (ms)')
plt.plot(n, 10**(np.dot(X, p2)), 'r--')

plt.xscale('log')
plt.yscale('log')
plt.xlim([min(n), 100])
plt.legend(loc='best')
plt.xlabel('number of atoms')
plt.ylabel('Calculation time')
plt.savefig('figures/dft-nn.png')
#plt.show()
#+END_SRC

#+RESULTS:
: [ 1.85394405  1.29860083]
: [-1.7240061  0.9070408]

[[./figures/dft-nn.png]]

#+BEGIN_SRC python 
from ase.db import connect
import matplotlib.pyplot as plt
import numpy as np
from vasp import Vasp
import matplotlib.cm as cm
from pycse import deriv, regress
from amp import Amp
import time

n, T, Tn = [], [], []
plt.figure(figsize=(10,6))
numbers = set()
db = connect('database/db10/time/data.db') 
for d in db.select():
    n += [d.natoms]
    T += [d.etime/3600.]
    Tn += [d.NNtime]

plt.subplot(121)
plt.scatter(T, Tn, c=n)
cb = plt.colorbar()
cb.set_label('number of atoms')
plt.xlim([0, 10])
#plt.ylim([0, 1000])
plt.xlabel('DFT calculation time (h)')
plt.ylabel('NN calculation time (ms)')

lib = ['1_7', '1_11', '1_17', '1_26', '1_35', '1_47', '1_63']
factor = range(11)
del factor[0]
t,n, tn = [],[], []
t2 = []
calc1 = Amp(load = './networks/db10/18-18/checkpoint-parameters.json')

for i in lib:
    calc = Vasp('./NDFT/bulk=fcc/type=time/v_a={}/MD=15'.format(i))
    atoms = calc.get_atoms()
    n += [len(atoms)]
    t += [calc.get_elapsed_time()]
    atoms.set_calculator(calc1)
    time1 = time.time()
    nrg1 = atoms.get_potential_energy()
    time2 = time.time()
    tn += [(time2-time1)]

tn = np.array(tn)

x = np.log10(n)
y1 = np.log10(t)
y2 = np.log10(tn)

X = np.column_stack([x**0, x])

p1, pint1, se1 = regress(X, y1, 0.05)
p2, pint2, se2 = regress(X, y2, 0.05)

plt.subplot(122)
plt.plot(n, t, 'bo', label='DFT time (s)')
plt.plot(n, 10**(np.dot(X, p1)), 'b--')

plt.plot(n, tn, 'ro', label='NN time (s)')
plt.plot(n, 10**(np.dot(X, p2)), 'r--')

plt.xscale('log')
plt.yscale('log')
plt.xlim([min(n), 100])
plt.legend(loc='best')
plt.xlabel('number of atoms')
plt.ylabel('Calculation time')

plt.tight_layout()
plt.savefig('figures/time-subplot.png')
#+END_SRC

#+RESULTS:

[[./figures/time-subplot.png]]

* DB keywords
** DBkey0
#+BEGIN_SRC python
from vasp import Vasp

factor = [0.900, 0.950, 1.000, 1.050]

cells= ['222', '223', '233', '333', '334', '344', '444'] 

calcs = []
for cell in cells:

    for x in factor:
    
        wd = './NDFT/bulk=fcc/type=vacancy/vrelax=False/lattice=primitive/supercell={0}/factor={1:.3f}'.format(cell,x)
        #wd = './NDFT/bulk=fcc/type=vacancy/lattice=cubic/supercell={0}/factor={1:.3f}'.format(cell,x)
        calc = Vasp(wd)

        calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':0, 'structure':'bulk'}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []
for i in range(200):
    wd = './NDFT/bulk=fcc/type=md/order=md0/v_a=0_8/MD={0}'.format(i)

    calc = Vasp(wd)
    calcs += [calc]
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':0, 'structure':'bulk'}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
import numpy as np

factor = np.append(np.arange(0.85, 1.2, 0.01),
                   np.arange(1.2, 2.125, 0.05))


cells = ['fcc', 'bcc', 'hcp', 'sc', 'diam']
for cell in cells:

    for x in factor:
    
   
        wd = './NDFT/bulk={0}/type=eos/factor={1:.2f}'.format(cell,x)
        calc = Vasp(wd)

        calc.write_db('./database/ddb5/data.db', parser='=', overwrite=False, keys={'dbkey':0, 'structure':'bulk'}) 
#+END_SRC

#+RESULTS:

** DBkey1
**** 0:8
#+BEGIN_SRC python
from vasp import Vasp

for i in range(200):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=0_8/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':1, 'structure':'bulk'})  
#+END_SRC

#+RESULTS:

**** 1:7
#+BEGIN_SRC python
from vasp import Vasp

for i in range(51):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_7/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':1, 'structure':'bulk'})  
#+END_SRC

#+RESULTS:

**** 1:11
#+BEGIN_SRC python
from vasp import Vasp

for i in range(22):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_11/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':1, 'structure':'bulk'})  
#+END_SRC

#+RESULTS:

**** 1:17
#+BEGIN_SRC python
from vasp import Vasp

for i in range(38):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_17/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':1, 'structure':'bulk'})  
#+END_SRC

#+RESULTS:

**** 1:26
#+BEGIN_SRC python
from vasp import Vasp

for i in range(16):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_26/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':1, 'structure':'bulk'})  
#+END_SRC

#+RESULTS:

**** 1:35
#+BEGIN_SRC python
from vasp import Vasp

for i in range(10):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_35/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':1, 'structure':'bulk'})   
#+END_SRC

#+RESULTS:

**** 1:47
#+BEGIN_SRC python
from vasp import Vasp

for i in range(10):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_47/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':1, 'structure':'bulk'})   
#+END_SRC

#+RESULTS:

**** 1:63
#+BEGIN_SRC python
from vasp import Vasp

for i in range(10):        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md1/v_a=1_63/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':1, 'structure':'bulk'})  
#+END_SRC

#+RESULTS:

** DBkey2
#+BEGIN_SRC python
from vasp import Vasp
import numpy as np

factor = np.linspace(0, 0.04, 41)

for x in factor:
    wd = './NDFT/bulk=fcc/type=elastic/dirs=11/factor={:.3f}'.format(x)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})   
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
import numpy as np

factor = np.linspace(0, 0.04, 41)

for x in factor:
    wd = './NDFT/bulk=fcc/type=elastic/dirs=44/factor={:.3f}'.format(x)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp

for cell in ['222', '223', '233', '333']:

    for i in range(9):
        wd = './NDFT/bulk=fcc/type=neb/supercell={0}/image={1}'.format(cell, i)
        calc = Vasp(wd)
        calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []
a = [86, 87, 88, 90, 91, 92, 97, 98, 99, 100, 101, 106, 107, 108, 109, 111, 112, 116, 117, 118, 120, 121, 122, 123, 129, 130, 131, 132, 133, 134, 141, 142, 143, 144, 145, 150, 151, 152, 153, 176, 177, 178, 179, 180, 181, 182, 183, 184, 188, 189, 190, 191, 196, 197, 198, 199]
for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/MD={0}'.format(i)  
    calc = Vasp(wd)
    
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []
a = [0, 3, 7, 8, 11, 12, 20, 21, 28, 39, 43, 46, 50, 51, 53, 54, 57, 58, 59, 60, 64, 65, 66, 67, 68, 69, 71, 72, 73, 79, 80, 88, 91, 92, 98, 99, 101, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 118, 119, 120, 121, 122, 123, 124, 125, 127, 128, 129, 131, 132, 133, 134, 135, 136, 137, 138, 142, 143, 144, 145, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 184, 185, 186, 187, 188, 189, 190, 191, 192, 194, 195, 196, 197, 198, 199]
for i in a:  
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_11/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []
a =  [7, 43, 47, 49, 51, 55, 62, 66, 70, 74, 75, 79, 80, 81, 82, 88, 89, 90, 94, 95, 96, 97, 101, 102, 106, 109, 113, 114, 117, 118, 119, 123, 124, 125, 126, 127, 128, 131, 132, 134, 135, 136, 139, 140, 141, 142, 143, 145, 146, 147, 149, 150, 151, 155, 157, 158, 159, 160, 161, 162, 163, 165, 166, 167, 168, 169, 170, 172, 173, 174, 175, 176, 177, 178, 180, 181, 182, 183, 184, 185, 186, 187, 188, 190, 191, 192, 193, 194, 197, 198, 199]
for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_17/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []
a = [0, 2, 3, 4, 7, 8, 11, 12, 15, 16, 19, 20, 23, 24, 27, 28, 32, 36, 40, 41, 45, 46, 49, 52, 53, 56, 57, 60, 65, 67, 69, 75, 77, 79, 86, 87, 90, 91, 97, 108, 114, 116, 117, 118, 120, 124, 125, 128, 129, 130, 135, 136, 137, 138, 140, 142, 143, 144, 149, 150, 154, 155, 156, 160, 161, 164, 165, 167, 168, 169, 170, 171, 174, 179, 180, 181, 182, 183, 186, 187, 188, 190, 192, 193, 194, 197, 199]
for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_26/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})
#+END_SRC


#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 15, 16, 17, 18, 19, 20, 21, 23, 24, 25, 28, 29, 30, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 45, 46, 47, 49, 50, 51, 52, 53, 55, 56, 57, 58, 59, 60, 62, 63, 64, 65, 67, 68, 71, 72, 73, 76, 77, 78, 80, 81, 83, 84, 85, 88, 89, 90, 91, 92, 94, 95, 96, 97, 98, 99]

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_35/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []
for i in range(100):
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_47/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)
del a[9]
for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_63/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'}) 
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []

#a = range(0, 21)
#a = range (23, 50)
a = range(0, 50)
del a[11]
del a[21]
#print a

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=1/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})


#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=2/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=3/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
calcs = []

a = range (50)

for i in a:
    wd = './NDFT/bulk=fcc/type=md/order=md2/v_a=1_7/image=4/MD={0}'.format(i)

    calc = Vasp(wd)
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':2, 'structure':'bulk'})
#+END_SRC

#+RESULTS:

**** Surface
#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':2, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=relaxation/supercell=23/factor=1.00'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':2, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=relaxation/supercell=33/factor=1.00'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':2, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

** DBkey3
#+BEGIN_SRC python
from vasp import Vasp
for i in range(200):        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md0/v_a=0_20/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':3, 'structure':'surface'}) 
#+END_SRC

#+RESULTS:

** DBkey4
#+BEGIN_SRC python
from vasp import Vasp
A = [0, 2, 4, 5, 6, 7, 10, 11, 12, 13, 16, 17, 18, 19, 21, 24, 25, 26, 27, 28, 29, 30, 32, 33, 37, 38, 40, 41, 43, 44, 45, 46, 50, 52, 54, 55, 60, 61, 63, 64, 65, 66, 73, 74, 75, 76, 82, 87, 92, 93, 102, 103, 104, 107, 108, 113, 114, 119, 121, 123, 124, 128, 129, 133, 138, 139, 142, 145, 146, 147, 148, 149, 150, 154, 155, 158, 159, 160, 167, 170, 179, 180, 184, 189, 191, 193, 194, 195, 197, 198]
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md1/v_a=0_20/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':4, 'structure':'surface'}) 
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=22'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':4, 'structure':'surface'}) for A in images]
#+END_SRC
#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=23'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':4, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=33'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':4, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read
pos = ['fcc', 'hcp', 'bridge', 'top']
for cong in pos:
    wd = 'NDFT/surface=fcc111/type=adatom/supercell=22/site={}'.format(cong)
    images = read(wd + '/vasprun.xml', ':')
    calc = Vasp(wd)

    [calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':4, 'structure':'surface'}) for A in images] 

#+END_SRC

#+RESULTS:

** DBkey5
#+BEGIN_SRC python
from vasp import Vasp
A = range (50)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md2/v_a=0_20/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':5, 'structure':'surface'})  
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python

from vasp import Vasp
A = range (50)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md2/v_a=1_19/MD={}'.format(i))
    calc.write_db('./database/db5/data.db', parser='=', overwrite=False, keys={'dbkey':5, 'structure':'surface'})  

#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=34'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':4, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=44'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':4, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

*** trajectory

#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc111/type=vacancy/vrelax=False/supercell=22'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db5/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':4}) for A in images]
#+END_SRC

#+RESULTS:

** DBkey6

#+BEGIN_SRC python
from vasp import Vasp
A = range (100)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md3/v_a=1_19/MD={}'.format(i))
    calc.write_db('./database/db6/data.db', parser='=', overwrite=False, keys={'dbkey':6, 'structure':'surface'})  
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
A = range (50)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md3/v_a=1_29/MD={}'.format(i))
    calc.write_db('./database/db6/data.db', parser='=', overwrite=False, keys={'dbkey':6, 'structure':'surface'})  
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
A = range (20)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md3/v_a=1_44/MD={}'.format(i))
    calc.write_db('./database/db6/data.db', parser='=', overwrite=False, keys={'dbkey':6, 'structure':'surface'})  
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
A = range (50)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md3/adatom=fcc/MD={}'.format(i))
    calc.write_db('./database/db6/data.db', parser='=', overwrite=False, keys={'dbkey':6, 'structure':'surface'})  
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
A = range (50)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md3/adatom=hcp/MD={}'.format(i))
    calc.write_db('./database/db6/data.db', parser='=', overwrite=False, keys={'dbkey':6, 'structure':'surface'})  
#+END_SRC

** DBkey7
#+BEGIN_SRC python
from vasp import Vasp
for i in range(9):
    calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/class=top_fcc/image={}'.format(i))
    calc.write_db('./database/db7/data.db', parser='=', overwrite=False, keys={'dbkey':7, 'structure':'surface'})  

    calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/class=fcc_hcp/image={}'.format(i))
    calc.write_db('./database/db7/data.db', parser='=', overwrite=False, keys={'dbkey':7, 'structure':'surface'})  

    calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/class=hcp_top/image={}'.format(i))
    calc.write_db('./database/db7/data.db', parser='=', overwrite=False, keys={'dbkey':7, 'structure':'surface'})  

    calc = Vasp('NDFT/surface=fcc111/type=neb/class=vacancy/image={}'.format(i))
    calc.write_db('./database/db7/data.db', parser='=', overwrite=False, keys={'dbkey':7, 'structure':'surface'})  
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
A = range (50)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md4/adatom=ontop/MD={}'.format(i))
    calc.write_db('./database/db7/data.db', parser='=', overwrite=False, keys={'dbkey':7, 'structure':'surface'})  
#+END_SRC

#+RESULTS:


#+BEGIN_SRC python
from vasp import Vasp
A = range (20)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md4/v_a=1_19/MD={}'.format(i))
    calc.write_db('./database/db7/data.db', parser='=', overwrite=False, keys={'dbkey':7, 'structure':'surface'})  
#+END_SRC

** DBkey8
#+BEGIN_SRC python
from vasp import Vasp
A = range (20)
for i in A:        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md5/image=4/MD={}'.format(i))
    calc.write_db('./database/db8/data.db', parser='=', overwrite=False, keys={'dbkey':8, 'structure':'bulk'})  
#+END_SRC

#+RESULTS:
#+BEGIN_SRC python
from vasp import Vasp
A = range (20)
for i in A:        
    calc = Vasp('NDFT/bulk=fcc/type=md/order=md5/image=5/MD={}'.format(i))
    calc.write_db('./database/db8/data.db', parser='=', overwrite=False, keys={'dbkey':8, 'structure':'bulk'})  
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
A = range (25)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md5/site=fcc/MD={}'.format(i))
    calc.write_db('./database/db8/data.db', parser='=', overwrite=False, keys={'dbkey':8, 'structure':'surface'})  
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
A = range (25)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md5/site=hcp/MD={}'.format(i))
    calc.write_db('./database/db8/data.db', parser='=', overwrite=False, keys={'dbkey':8, 'structure':'surface'})  
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
A = range (25)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md5/site=bridge/MD={}'.format(i))
    calc.write_db('./database/db8/data.db', parser='=', overwrite=False, keys={'dbkey':8, 'structure':'surface'})  
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
from vasp import Vasp
A = range (25)
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md5/site=top/MD={}'.format(i))
    calc.write_db('./database/db8/data.db', parser='=', overwrite=False, keys={'dbkey':8, 'structure':'surface'})  
#+END_SRC

#+RESULTS:

** DBkey9
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

#VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 4
images = Trajectory('./database/db8/sur-211/MD.traj', 'r')

for i in range(25):
    calc = Vasp('NDFT/surface=fcc211/type=md/order=md6/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC


#+BEGIN_SRC python :results output org drawer
from vasp import Vasp

for i in range(25):
    calc = Vasp('NDFT/surface=fcc211/type=md/order=md6/MD={}'.format(i))
    calc.write_db('./database/db9/data.db', parser='=', overwrite=False, keys={'dbkey':9, 'structure':'surface'})
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

#+BEGIN_SRC python
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc211//type=relaxation/supercell=33'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db9/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':9, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

** DBkey10
#+BEGIN_SRC python :results output org drawer
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc211/type=vacancy/site=edge'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db10/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':10, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:
:RESULTS:
:END:


#+BEGIN_SRC python 
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc211/type=vacancy/site=middle'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db10/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':10, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python 
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc211/type=vacancy/site=terrace'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db10/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':10, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python 
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc211/type=adatom/site=0'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db10/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':10, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python 
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc211/type=adatom/site=1'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db10/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':10, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python 
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc211/type=adatom/site=2'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db10/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':10, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python 
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc211/type=adatom/site=3'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db10/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':10, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python 
from vasp import Vasp
from ase.io import read

wd = 'NDFT/surface=fcc211/type=adatom/site=4'

images = read(wd + '/vasprun.xml', ':')
calc = Vasp(wd)

[calc.write_db('./database/db10/data.db', atoms=A, parser='=', overwrite=False, keys={'dbkey':10, 'structure':'surface'}) for A in images]
#+END_SRC

#+RESULTS:

#+BEGIN_SRC python :results output org drawer
from vasp import Vasp

for i in range(9):
    calc = Vasp('NDFT/surface=fcc111/type=neb_nn/class=surf_vac/image={}'.format(i))
    calc.write_db('./database/db10/data.db', parser='=', overwrite=False, keys={'dbkey':10, 'structure':'surface'})
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

#+BEGIN_SRC python :results output org drawer
from vasp import Vasp

for i in range(9):
    calc = Vasp('NDFT/surface=fcc111/type=neb_nn/class=top_fcc/image={}'.format(i))
    calc.write_db('./database/db10/data.db', parser='=', overwrite=False, keys={'dbkey':10, 'structure':'surface'})
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

#+BEGIN_SRC python :results output org drawer
from vasp import Vasp

for i in range(9):
    calc = Vasp('NDFT/surface=fcc111/type=neb_nn/class=fcc_hcp/image={}'.format(i))
    calc.write_db('./database/db10/data.db', parser='=', overwrite=False, keys={'dbkey':10, 'structure':'surface'})
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

#+BEGIN_SRC python :results output org drawer
from vasp import Vasp

for i in range(9):
    calc = Vasp('NDFT/surface=fcc111/type=neb_nn/class=hcp_top/image={}'.format(i))
    calc.write_db('./database/db10/data.db', parser='=', overwrite=False, keys={'dbkey':10, 'structure':'surface'})
#+END_SRC

#+RESULTS:
:RESULTS:
:END:



* Diffusion study
** 3*3
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms
from ase import Atoms, Atom
VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 4
calc = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=33/factor=1.00')
slab = calc.get_atoms()

p = slab.positions

pfcc = (p[40] + p[41] + p[43])/3.0 + [0, 0, 2]
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(pfcc)

fcc = slab + add
constraint = FixAtoms(mask=[atom.tag > 0  for atom in fcc])
fcc.set_constraint(constraint)
#print fcc.get_tags()
#view(fcc)

calc = Vasp('NDFT/surface=fcc111/type=diffusion/position=fcc',
            xc = 'pbe',
            kpts=[5,5,1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=fcc)
calc.get_memory()
calc.calculate()

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=diffusion/position=fcc submitted: 1521532.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms
from ase import Atoms, Atom
VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 4
calc = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=33/factor=1.00')
slab = calc.get_atoms()

p = slab.positions

pfcc = (p[44] + p[41] + p[43])/3.0 + [0, 0, 2]
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(pfcc)

fcc = slab + add
constraint = FixAtoms(mask=[atom.tag > 0  for atom in fcc])
fcc.set_constraint(constraint)
#view(fcc)

calc = Vasp('NDFT/surface=fcc111/type=diffusion/position=hcp',
            xc = 'pbe',
            kpts=[5,5,1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=fcc)
calc.get_memory()
calc.calculate()

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=diffusion/position=hcp submitted: 1521533.gilgamesh.cheme.cmu.edu
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111
from ase.constraints import FixAtoms

VASPRC['queue.mem'] = '8GB'

ini = Vasp('NDFT/surface=fcc111/type=diffusion/position=fcc').get_atoms()
fin = Vasp('NDFT/surface=fcc111/type=diffusion/position=hcp').get_atoms()
images = [ini]
images += [ini.copy() for i in range(7)]
images += [fin]

neb = NEB(images)

neb.interpolate()

calc = Vasp('NDFT/surface=fcc111/type=diffusion/neb',
            xc='pbe',
            kpts=[5, 5, 1],
            encut=350,
            ibrion=1,
            nsw=90,
            spring=-5,
            atoms=images)

images, energies = calc.get_neb()

calc.stop_if(None in energies)

p = calc.plot_neb(show=False)
plt.savefig('./figures/diffusion-dft.png')
#+END_SRC

#+RESULTS:
: Optimization terminated successfully.
:          Current function value: -0.155544
:          Iterations: 15
:          Function evaluations: 30

[[./figures/diffusion-dft.png]]
** MD in 2*2
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db11/2*2MD')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function

from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms
from vasp import Vasp
from ase import Atom, Atoms

calc = Vasp("./../../../NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00")
slab = calc.get_atoms()

p = slab.positions

pfcc = (p[16] + p[17] + p[18])/3.0 + [0, 0, 2]
add = Atoms([Atom("Pd")])
add.translate(-add.get_center_of_mass())
add.translate(pfcc)

atoms = slab + add
constraint = FixAtoms(mask=[atom.tag > 0  for atom in atoms])
atoms.set_constraint(constraint)

atoms.set_calculator(Amp(load="./../../../networks/db10/18-18/checkpoint-parameters.json"))

dyn = Langevin(atoms, 1 * units.fs, 1700 * units.kB, 0.002)

def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./1700-1e5.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(10000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=168:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1522622.gilgamesh.cheme.cmu.edu

** MD in 3*3
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db11/3*3MD')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function

from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms
from vasp import Vasp
from ase import Atom, Atoms

calc = Vasp("./../../../NDFT/surface=fcc111/type=relaxation/supercell=33/factor=1.00")
slab = calc.get_atoms()

p = slab.positions

pfcc = (p[40] + p[41] + p[43])/3.0 + [0, 0, 2]
add = Atoms([Atom("Pd")])
add.translate(-add.get_center_of_mass())
add.translate(pfcc)

atoms = slab + add
constraint = FixAtoms(mask=[atom.tag > 0  for atom in atoms])
atoms.set_constraint(constraint)

atoms.set_calculator(Amp(load="./../../../networks/db10/18-18/checkpoint-parameters.json"))

dyn = Langevin(atoms, 5 * units.fs, 1000 * units.kB, 0.002)


def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=5)

traj = Trajectory("./MD.traj", "w", atoms)
dyn.attach(traj.write, interval=5)

dyn.run(5000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=168:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1521540.gilgamesh.cheme.cmu.edu

** step 2e4 
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

wd = os.path.join(home, './database/db11/2e4steps')

if not os.path.exists(wd):
    os.makedirs(wd)

os.chdir(wd)
home=os.getcwd()


run_md = '''#!/usr/bin/env python
from __future__ import print_function

from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms
from vasp import Vasp
from ase import Atom, Atoms

calc = Vasp("./../../../NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00")
slab = calc.get_atoms()

p = slab.positions

pfcc = (p[16] + p[17] + p[18])/3.0 + [0, 0, 2]
add = Atoms([Atom("Pd")])
add.translate(-add.get_center_of_mass())
add.translate(pfcc)

atoms = slab + add
constraint = FixAtoms(mask=[atom.tag > 0  for atom in atoms])
atoms.set_constraint(constraint)

atoms.set_calculator(Amp(load="./../../../networks/db10/18-18/checkpoint-parameters.json"))

dyn = Langevin(atoms, 1 * units.fs, 800 * units.kB, 0.002)

def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory("./800.traj", "w", atoms)
dyn.attach(traj.write, interval=10)

dyn.run(20000)
'''

cmd = '''#!/bin/bash
#PBS -N {0}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=168:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format('800')

with open('submit.py', 'w') as f:
    f.write(run_md)
os.chmod('submit.py', 0777)

with open('submit.sh', 'w') as f:
    f.write(cmd)

subprocess.call(['qsub', 'submit.sh'])
time.sleep(5)
os.unlink('submit.sh')
os.chdir(wd)
#+END_SRC

#+RESULTS:
: 1522653.gilgamesh.cheme.cmu.edu

** step 2e5 

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()
#for n in [800, 900, 1100, 1200, 1300, 1400, 1500]:
#for n in [1600]:
for n in [1400]:
    wd = 'database/db11/2e5-12/{0}-2-1st'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)
    os.chdir(wd)

    run_amp = """#!/usr/bin/env python
from __future__ import print_function

from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms
from vasp import Vasp
from ase import Atom, Atoms

calc = Vasp('./../../../../NDFT/surface=fcc111/type=relaxation/supercell=22/factor=1.00')
slab = calc.get_atoms()

p = slab.positions

pfcc = (p[16] + p[17] + p[18])/3.0 + [0, 0, 2]
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(pfcc)

atoms = slab + add
constraint = FixAtoms(mask=[atom.tag > 0  for atom in atoms])
atoms.set_constraint(constraint)

atoms.set_calculator(Amp(load='./../../../../networks/db12/18-18/checkpoint-parameters.json'))

dyn = Langevin(atoms, 1 * units.fs, {} * units.kB, 0.002)

def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory('MD.traj', 'w', atoms)
dyn.attach(traj.write, interval=10)

dyn.run(200000)
""".format(n)

    cmd = '''#!/bin/bash
#PBS -N {}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=168:00:00
#PBS -l mem=200MB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

    with open('submit.py', 'w') as f:
        f.write(run_amp)
    os.chmod('submit.py', 0777)

    with open('submit.sh', 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', 'submit.sh'])
    time.sleep(2)
    os.unlink('submit.sh')
    os.chdir(home)
#+END_SRC

#+RESULTS:
: 1536617.gilgamesh.cheme.cmu.edu

** 3*3slabs
#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()
#20, 24, 25
for n in [800, 900, 1000, 1100, 1200, 1300, 1400, 1500]:
#for n in [1600]:
    wd = 'database/db11/33slabs/{0}'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)
    os.chdir(wd)

    run_amp = """#!/usr/bin/env python
from __future__ import print_function

from ase.md.langevin import Langevin
from ase.io.trajectory import Trajectory
from ase import units
from amp import Amp
from ase.constraints import FixAtoms
from vasp import Vasp
from ase import Atom, Atoms

calc = Vasp('./../../../../NDFT/surface=fcc111/type=relaxation/supercell=33/factor=1.00')
slab = calc.get_atoms()

p = slab.positions

pfcc = (p[40] + p[41] + p[43])/3.0 + [0, 0, 2]
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(pfcc)

atoms = slab + add
constraint = FixAtoms(mask=[atom.tag > 0  for atom in atoms])
atoms.set_constraint(constraint)

atoms.set_calculator(Amp(load='./../../../../networks/db10/18-18/checkpoint-parameters.json'))

dyn = Langevin(atoms, 1 * units.fs, {} * units.kB, 0.002)

def printenergy(a=atoms):
    epot = a.get_potential_energy() / len(a)
    ekin = a.get_kinetic_energy() / len(a)
    
dyn.attach(printenergy, interval=10)

traj = Trajectory('MD.traj', 'w', atoms)
dyn.attach(traj.write, interval=10)

dyn.run(100000)
""".format(n)

    cmd = '''#!/bin/bash
#PBS -N {}
#PBS -l nodes=1:ppn=1
#PBS -l walltime=168:00:00
#PBS -l mem=1GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

    with open('submit.py', 'w') as f:
        f.write(run_amp)
    os.chmod('submit.py', 0777)

    with open('submit.sh', 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', 'submit.sh'])
    time.sleep(2)
    os.unlink('submit.sh')
    os.chdir(home)
#+END_SRC

#+RESULTS:
: 1523502.gilgamesh.cheme.cmu.edu
: 1523503.gilgamesh.cheme.cmu.edu
: 1523504.gilgamesh.cheme.cmu.edu
: 1523505.gilgamesh.cheme.cmu.edu
: 1523506.gilgamesh.cheme.cmu.edu
: 1523507.gilgamesh.cheme.cmu.edu
: 1523508.gilgamesh.cheme.cmu.edu
: 1523509.gilgamesh.cheme.cmu.edu

** MSD
mean-square displacement

#+BEGIN_SRC python 
from ase.io.trajectory import Trajectory
import numpy as np
from ase.io import read
from ase.visualize import view
import matplotlib.pyplot as plt
from pycse import regress
#images = Trajectory('trajectory/db10/333.traj@-9', 'r')
#images = read('database/db11/2*2MD/1fs.traj@::')
#images = read('database/db11/2e4steps/1000.traj@::')
#images = read('database/db11/2e5steps/1500.traj@::')
images = read('database/db11/2e5-12/1500/MD.traj@:1000:')
r2 = [0]
total = range(len(images))
del total[0]
#print total
#total = [1]
'''
for i in total:
    p0 = images[0].positions[20]
    p1 = images[i].positions[20]
    dist = (p0[0]-p1[0])**2 + (p0[1]-p1[1])**2 + (p0[2]-p1[2])**2
    r2.append(dist)
'''
for i in total:
    p0 = images[i-1].positions[20]
    p1 = images[i].positions[20]
    dist = np.linalg.norm(p1-p0)**2
    r2.append(dist+r2[-1])

time = range(len(r2))
del time[0]
time = np.array(time)*10
del r2[0]

D = r2/time

#x = np.log10(time)
#y = np.log10(r2)

X = np.column_stack([time, time**0])

X = np.column_stack([time])
p, pint, se = regress(X, r2, 0.05)
print p
plt.plot(time, np.dot(X, p), label='fit')

plt.plot(time, r2)
plt.minorticks_on()
plt.xlim([min(time), max(time)])
plt.xlabel('time (fs)')
plt.ylabel('MSD (\AA^2)')
#plt.ylabel(
#plt.xscale('log')
#plt.yscale('log')
plt.show()
#plt.savefig('figures/2e5fs.png')
#+END_SRC

#+RESULTS:
: [  8.95705442e-05]

[[./figures/2e5fs.png]]


#+BEGIN_SRC python 
from ase.io.trajectory import Trajectory
import numpy as np
from ase.io import read
from ase.visualize import view
import matplotlib.pyplot as plt
from pycse import regress

#images = read('database/db11/2*2MD/1fs.traj@::')
#images = read('database/db11/2e4steps/1000.traj@::')
#images = read('database/db11/2e5steps/1000.traj@::')
images = read('database/db11/33slabs/1000/MD.traj@440::')
r2 = [0]
total = range(len(images))
del total[0]

for i in total:
    #p0 = images[0].positions[20]
    #p1 = images[i].positions[20]
    p0 = images[i-1].positions[45]
    p1 = images[i].positions[45]
    #dist = np.linalg.norm(p1-p0)**2
    dist = (p0[0]-p1[0])**2 + (p0[1]-p1[1])**2 + (p0[2]-p1[2])**2
    r2.append(r2[i-1] + dist)
    #r2.append(dist)
time = range(len(r2))
del time[0]
time = np.array(time)*10
del r2[0]

D = r2/time

#x = np.log10(time)
#y = np.log10(r2)

X = np.column_stack([time, time**0])
p, pint, se = regress(X, r2, 0.05)
print p
plt.plot(time, np.dot(X, p), label='fit')

plt.plot(time, r2,'o')
#plt.plot(time,1e-6* time**2)
#plt.plot(time,1e-3* time)
plt.minorticks_on()
plt.xlim([min(time), max(time)])
plt.xlabel('time (fs)')
plt.ylabel('MSD (\AA^2)')
#plt.ylabel(
#plt.xscale('log')
#plt.yscale('log')
plt.show()
#plt.savefig('figures/2e5fs.png')
#+END_SRC

#+RESULTS:
: [ 0.00020606  0.01552462]

*** Average
#+BEGIN_SRC python 
from ase.io.trajectory import Trajectory
import numpy as np
from ase.io import read
from ase.visualize import view
import matplotlib.pyplot as plt
from pycse import regress

mdset = ['1st', '3rd', '4th','5th', '6th', '7th'] #800K 800-1100
#mdset = ['1st', '3rd', '4th','5th', '6th', '7th','8th'] #900K 700-100
#mdset = ['1st','3rd', '4th','5th', '6th', '7th'] #1000K 1000-1300
#mdset = ['1st', '2nd', '3rd', '4th','5th', '7th', '8th'] #1100K 700-1000
#mdset = ['1st', '2nd', '3rd', '4th','5th', '6th', '7th'] #1300K
#mdset = ['1st', '2nd', '3rd', '5th','6th', '7th', '8th'] #1500K
#mdset = ['1st', '2nd', '3rd', '5th', '4th', '6th', '7th', '8th']
#mdset = ['2nd', '3rd', '4th','5th','6th','8th'] #1400K 1000-1300
msd = np.zeros(300)
for n, p in enumerate(mdset):
    
    images = read('database/db11/2e5-12/800-{}/MD.traj@750:1050:'.format(p))
    r2 = [0]
    total = range(len(images))
    del total[0]

    for i in total:
        p0 = images[i-1].positions[20]
        p1 = images[i].positions[20]
        dist = np.linalg.norm(p1-p0)**2
        r2.append(dist+r2[-1])
    r2 = np.array(r2)
    msd = r2 + msd

time = range(len(r2))

time = np.delete(time, 0)
time = np.array(time) * 10

msd = np.delete(msd, 0)
ave = np.array(msd)/len(mdset)
#print ave.size
D = ave/time

X = np.column_stack([time, time**0])
p, pint, se = regress(X, ave, 0.05)
print p
plt.plot(time, np.dot(X, p), label='fit')

plt.plot(time, ave)
plt.minorticks_on()
plt.xlim([min(time), max(time)])
plt.xlabel('time (fs)')
plt.ylabel('MSD (\AA^2)')
plt.savefig('figures/msd-ave-2.png')
#+END_SRC

#+RESULTS:
: [ 0.0001369  -0.00925769]

[[./figures/msd-ave.png]

[[./figures/msd-ave-2.png]]

*** 33
#+BEGIN_SRC python 
from ase.io.trajectory import Trajectory
import numpy as np
from ase.io import read
from ase.visualize import view
import matplotlib.pyplot as plt
#images = Trajectory('trajectory/db10/333.traj@-9', 'r')
#images = read('database/db11/3*3MD/MD.traj@::')
images = read('database/db11/33slabs/1000/MD.traj@::')
r2 = [0]
total = range(len(images))
del total[0]
#print total

for i in total:
    p0 = images[i-1].positions[45]
    p1 = images[i].positions[45]
    #dist = np.linalg.norm(p1-p0)**2
    dist = (p0[0]-p1[0])**2 + (p0[1]-p1[1])**2 + (p0[2]-p1[2])**2
    r2.append(r2[i-1] + dist)

time = np.array(range(len(r2)))
time = (time + 1)*5


D = r2/(6*time)
plt.plot(time, r2, 'o')
plt.plot(time, 1e-4*time)
plt.plot(time, 1e-4*time **2)
#plt.plot(time, D,'o')

plt.xscale('log')
plt.yscale('log')
plt.show()
#+END_SRC

#+RESULTS:

** Compile
#+tblname: tab-2e4
| Temperature(K) |        D |
|----------------+----------|
|            800 | 0.000125 |
|            900 |  0.00014 |
|           1000 | 0.000115 |
|           1200 |   0.0002 |
|           1400 |  0.00032 |
|           1600 |  0.00042 |

#+tblname: tab-2e5
| Temperature(K) |       D |
|----------------+---------|
|            800 |    9e-5 |
|            900 | 1.15e-4 |
|           1000 | 2.25e-4 |
|           1100 |         |
|           1200 |  2.2e-4 |
|           1300 |    3e-4 |
|           1400 |  2.3e-4 |
|           1500 |    2e-4 |
|           1600 |  3.2e-4 |


#+BEGIN_SRC python 
from ase.io.trajectory import Trajectory
import numpy as np
from ase.io import read
from ase.visualize import view
import matplotlib.pyplot as plt
from pycse import regress

#mdset = ['1st', '3rd', '4th', '5th', '6th']
mdset = ['1st', '2nd', '3rd', '4th', '5th', '6th', '7th', '8th']
#mdset = ['1st', '2nd', '3rd', '4th', '6th', '7th', '8th']
Tset = ['800', '900','1000', '1100', '1200', '1300', '1500']
#Tset = ['900', '1000']

for T in Tset:
    msd = np.zeros(1200)
    for n, p in enumerate(mdset):
    
        images = read('database/db11/2e5-12/{0}-{1}/MD.traj@:1200:'.format(T,p))
        r2 = [0]
        total = range(len(images))
        del total[0]

        for i in total:
            p0 = images[i-1].positions[20]
            p1 = images[i].positions[20]
            dist = np.linalg.norm(p1-p0)**2
            r2.append(dist+r2[-1])
        r2 = np.array(r2)
        msd = r2 + msd

    time = range(len(r2))
    time = np.delete(time, 0)
    time = np.array(time) * 10

    msd = np.delete(msd, 0)
    ave = np.array(msd)/8

    D = ave/time

    X = np.column_stack([time, time**0])
    #X = np.column_stack([time])
    p, pint, se = regress(X, ave, 0.05)
    #print p
    #plt.plot(time, np.dot(X, p), label='fit')

    plt.plot(time, ave, label = '{}'.format(T))
plt.legend(loc='best')
plt.minorticks_on()
plt.xlim([min(time), max(time)])
plt.xlabel('time (fs)')
plt.ylabel('MSD (\AA^2)')

plt.savefig('figures/msd-comp.png')
#+END_SRC

#+RESULTS:

[[./figures/msd-comp.png]]

#+BEGIN_SRC python 
from ase.io.trajectory import Trajectory
import numpy as np
from ase.io import read
from ase.visualize import view
import matplotlib.pyplot as plt
from pycse import regress

mdset= [ ['1st', '3rd', '4th','5th', '6th', '7th'], #800
         ['1st', '3rd', '4th','5th', '6th', '7th','8th'], #900
         ['1st', '2nd', '3rd', '4th','5th', '6th', '7th', '8th'], #1000
         ['1st', '2nd', '3rd', '4th','5th', '7th','8th'],#1100k
         ['1st', '2nd', '3rd', '4th','5th', '6th', '7th','8th'], #1200k
         ['1st', '2nd', '3rd', '4th','5th', '6th', '7th'], #1300k
	 [ '2nd', '3rd', '4th','5th','6th','8th'], #1400k
         ['1st', '2nd', '3rd', '5th','6th', '7th', '8th']] #1500K
start = [750, 900, 900, 600, 700, 700, 1200, 1100]
Tset = np.array([800, 900, 1000, 1100, 1200, 1300, 1400, 1500])
cmap = plt.get_cmap('gnuplot')
Diff = []
plt.figure()
plt.subplot(121)
for t,T in enumerate(Tset):
    msd = np.zeros(300)
    s = start[t]
    md = mdset[t]
    for n, p in enumerate(md):
        images = read('database/db11/2e5-12/{0}-{1}/MD.traj@{2}:{3}:'.format(T,p,s, (s+300)))
        r2 = [0]
        total = range(len(images))
        del total[0]

        for i in total:
            p0 = images[i-1].positions[20]
            p1 = images[i].positions[20]
            dist = np.linalg.norm(p1-p0)**2
            r2.append(dist+r2[-1])
        r2 = np.array(r2)
        msd = r2 + msd

    time = range(len(r2))

    time = np.delete(time, 0)
    time = np.array(time) * 10

    msd = np.delete(msd, 0)
    ave = np.array(msd)/len(md)
    D = ave/time

    X = np.column_stack([time, time**0])
    p, pint, se = regress(X, ave, 0.05)
    Diff.append(p[0])
    color = cmap(t/8.0)
    plt.plot(time, np.dot(X, p), '-', c=color )
    plt.plot(time, ave, '--', c=color, label='{0}K'.format(T))
plt.legend(loc='best')
plt.minorticks_on()
plt.xlim([min(time), max(time)])
plt.ylim([0, 1.1])
plt.xlabel('Time (fs)')
plt.ylabel('MSD ($\AA^2$)')
print Diff

plt.subplot(122)
Diff= np.array(Diff)/1e5/4
Diff = np.log(Diff)
Tinv = 1.0/Tset*1000
plt.plot(Tinv, Diff,'o')
from scipy import stats
slope, inter, r, p, std = stats.linregress(Tinv, Diff)
plt.plot(Tinv, slope*Tinv+inter, 'r')
plt.text(0.80, -21.0, '$lnD={0:.2f}/T - {1:.2f}$'.format(slope*1000, abs(inter)))
plt.text(0.90, -21.06, '$R^2={0:.3f}$'.format(r**2))
plt.text(0.90, -21.12, '$E={0:.3f} eV$'.format(abs(slope)*8.314*0.01036)) # unit conversion
plt.xlim([0.6, 1.4])
plt.xlabel('1000/T')
plt.ylabel('lnD')
plt.tight_layout()
plt.savefig('figures/msd-comp-2.png')
#+END_SRC

#+RESULTS:
: [0.00013690266343445153, 0.0001559320455600443, 0.00019653901073960687, 0.00021425216030867278, 0.0002432725787630781, 0.00028216392918559082, 0.00029029674672402604, 0.00033685123576374191]

[[./figures/msd-comp-2.png]]


#+BEGIN_SRC python :results output org drawer
colo = ['b', 'g', 'r', 'c', 'm', 'y']
import matplotlib.pyplot as plt
x = [0, 1]
y = [0, 1]
for i, co in enumerate(colo):
    plt.plot(x, y, '{}--'.format(colo[i]))

plt.show()
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

* 12th DFT 
** 2*2 high energy configurations
#+BEGIN_SRC python :results output org drawer
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp

calc1 = Amp(load = './networks/db10/24-24/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db10/18-18/checkpoint-parameters.json')
#traj = Trajectory('./database/db11/2e5steps/1200.traj')
#traj = read('database/db11/2e5steps/1200.traj@2200:2500:')
E1, E2 = [], []

for atoms in traj:
    atoms.set_calculator(calc1)
    E1.append(atoms.get_potential_energy()/len(atoms))

for atoms in traj:
    atoms.set_calculator(calc2)
    E2.append(atoms.get_potential_energy()/len(atoms))

plt.plot(range(len(E1)), E1, 'b-' ,label='NN1')
plt.plot(range(len(E2)), E2, 'r--',label='NN2')
#plt.xlim([0,200])
plt.legend()
plt.xlabel('MD Steps')
plt.ylabel('Energies eV')
#plt.ylim([-5.1, -2])
plt.show()
#plt.savefig('./figures/MD225-3.png')
#+END_SRC

#+RESULTS:
:RESULTS:
:END:

#+BEGIN_SRC python :results output org drawer
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp

calc1 = Amp(load = './networks/db10/24-24/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db10/18-18/checkpoint-parameters.json')
traj = Trajectory('./database/db11/2e5steps/1400.traj')
#traj = read('database/db11/2e5steps/1200.traj@2200:2500:')
ind = []
for i in range(len(traj)):
    atoms = traj[i]
    E1 = atoms.get_potential_energy()/len(atoms)
    atoms.set_calculator(calc1)
    E2 = atoms.get_potential_energy()/len(atoms)
    if abs(E1-E2) > 0.03:
        ind += [i]

print ind

#+END_SRC

#+RESULTS:
:RESULTS:
[]
:END:

#+BEGIN_SRC python :results output org drawer
ind =[1424, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1448, 1449, 1450, 1451, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2282, 2283, 2284, 2285, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2696, 2697, 2698, 2699, 2700, 2701, 2702, 2710, 2711, 2712, 2713, 2714, 2715, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749, 2750, 2751, 2756, 2757, 2758, 2759, 2760, 2761, 2766, 2767, 2768, 2769, 2770, 2771, 2779, 2780, 2781, 2782, 2794, 2795, 2796, 2797, 2798, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817]
print len(ind)
#+END_SRC

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 4
images = Trajectory('./database/db11/2e5steps/1200.traj', 'r')

A = [1424, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1448, 1449, 1450, 1451, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2282, 2283, 2284, 2285, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2696, 2697, 2698, 2699, 2700, 2701, 2702, 2710, 2711, 2712, 2713, 2714, 2715, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749, 2750, 2751, 2756, 2757, 2758, 2759, 2760, 2761, 2766, 2767, 2768, 2769, 2770, 2771, 2779, 2780, 2781, 2782, 2794, 2795, 2796, 2797, 2798, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817]
for i in A:
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md6/study=diffusion/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC


#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 4
images = Trajectory('./database/db11/2e5steps/1200.traj', 'r')
En, E = [], []
A = [1424, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1448, 1449, 1450, 1451, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2282, 2283, 2284, 2285, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2696, 2697, 2698, 2699, 2700, 2701, 2702, 2710, 2711, 2712, 2713, 2714, 2715, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749, 2750, 2751, 2756, 2757, 2758, 2759, 2760, 2761, 2766, 2767, 2768, 2769, 2770, 2771, 2779, 2780, 2781, 2782, 2794, 2795, 2796, 2797, 2798, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817]
for i in A:
    image = images[i]
    En += [image.get_potential_energy()]
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md6/study=diffusion/MD={}'.format(i))
    calc.set_memory()
    E += [calc.potential_energy]

import matplotlib.pyplot as plt
plt.plot(range(len(E)), E, label='DFT')
plt.plot(range(len(En)), En, label = 'NN')
plt.legend(loc='best')
plt.savefig('figures/MD-diffusion.png')
#+END_SRC

#+RESULTS:

[[./figures/MD-diffusion.png]]
** write db
#+BEGIN_SRC python
from vasp import Vasp
A = [1424, 1431, 1432, 1433, 1434, 1435, 1436, 1437, 1438, 1439, 1440, 1441, 1442, 1443, 1444, 1448, 1449, 1450, 1451, 2158, 2159, 2160, 2161, 2162, 2163, 2164, 2216, 2217, 2218, 2219, 2220, 2221, 2222, 2223, 2224, 2225, 2226, 2227, 2228, 2236, 2237, 2238, 2239, 2240, 2241, 2242, 2243, 2244, 2245, 2282, 2283, 2284, 2285, 2287, 2288, 2289, 2290, 2291, 2292, 2293, 2294, 2295, 2435, 2436, 2437, 2438, 2439, 2440, 2441, 2442, 2444, 2445, 2446, 2447, 2448, 2449, 2450, 2451, 2452, 2453, 2454, 2455, 2489, 2490, 2491, 2492, 2493, 2494, 2495, 2496, 2505, 2506, 2507, 2508, 2509, 2510, 2511, 2512, 2513, 2514, 2515, 2516, 2696, 2697, 2698, 2699, 2700, 2701, 2702, 2710, 2711, 2712, 2713, 2714, 2715, 2718, 2719, 2720, 2721, 2722, 2723, 2724, 2725, 2726, 2727, 2731, 2732, 2733, 2734, 2735, 2736, 2737, 2738, 2739, 2740, 2742, 2743, 2744, 2745, 2746, 2747, 2748, 2749, 2750, 2751, 2756, 2757, 2758, 2759, 2760, 2761, 2766, 2767, 2768, 2769, 2770, 2771, 2779, 2780, 2781, 2782, 2794, 2795, 2796, 2797, 2798, 2801, 2802, 2803, 2804, 2805, 2806, 2807, 2808, 2809, 2810, 2811, 2812, 2813, 2814, 2815, 2816, 2817]
for i in A:        
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md6/study=diffusion/MD={}'.format(i))
    calc.write_db('./database/db12/data.db', parser='=', overwrite=False, keys={'dbkey':12, 'structure':'surface'})  
#+END_SRC

#+RESULTS:

** 3*3 adatom neb
#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms
from ase import Atoms, Atom

#VASPRC['queue.mem'] = '8GB'
VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 4

calc = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=33/factor=1.00')
slab = calc.get_atoms()

#slab = fcc111('Pd', size=(2, 2, 5), a = 3.939,  vacuum=6.0)
#end = slab.copy()
p = slab.positions

pfcc = (p[40] + p[41] + p[43])/3.0 + [0, 0, 2]
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(pfcc)

fcc = slab + add
constraint = FixAtoms(mask=[atom.tag > 0  for atom in fcc])
fcc.set_constraint(constraint)
#print fcc.get_tags()
#view(fcc)

calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/supercell=33/position=fcc',
            xc = 'pbe',
            kpts=[5,5,1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=fcc)
calc.get_memory()
calc.calculate()
#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=neb/fixed=True/supercell=33/position=fcc submitted: 1524701.gilgamesh.cheme.cmu.edu

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.neb import NEB
import matplotlib.pyplot as plt
from ase.visualize import view
from ase.lattice.surface import fcc111, add_adsorbate
from ase.constraints import FixAtoms
from ase import Atoms, Atom

#VASPRC['queue.mem'] = '8GB'
VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 4

calc = Vasp('NDFT/surface=fcc111/type=relaxation/supercell=33/factor=1.00')
slab = calc.get_atoms()

#slab = fcc111('Pd', size=(2, 2, 5), a = 3.939,  vacuum=6.0)
#end = slab.copy()
p = slab.positions

pfcc = (p[40] + p[42] + p[43])/3.0 + [0, 0, 2]
add = Atoms([Atom('Pd')])
add.translate(-add.get_center_of_mass())
add.translate(pfcc)

fcc = slab + add
constraint = FixAtoms(mask=[atom.tag > 0  for atom in fcc])
fcc.set_constraint(constraint)
#print fcc.get_tags()
#view(fcc)

calc = Vasp('NDFT/surface=fcc111/type=neb/fixed=True/supercell=33/position=hcp',
            xc = 'pbe',
            kpts=[5,5,1],
            encut=350,
            ibrion=2,
            isif=2,
            nsw=25,
            atoms=fcc)
calc.get_memory()
calc.calculate()

#+END_SRC

#+RESULTS:
: /home-research/tianyug1/Research/Bulk/NDFT/surface=fcc111/type=neb/fixed=True/supercell=33/position=hcp submitted: 1524702.gilgamesh.cheme.cmu.edu

* Training
#+BEGIN_SRC python
from ase.db import connect
import os
import random
import numpy as np

db = connect('./database/db12/data.db')

n = db.count()
n_train = int(round(n * 0.9))

n_ids =  np.array(range(n)) + 1

# This will sudo-randomly select 10% of the calculations
# Which is useful for reproducing our results.
random.seed(256)
train_samples = random.sample(n_ids, n_train)
valid_samples = set(n_ids) - set(train_samples)

db.update(list(train_samples), train_set=True)
db.update(list(valid_samples), train_set=False)

#+END_SRC

#+RESULTS:

#+BEGIN_SRC python
import os
import subprocess
import time

home = os.getcwd()

for n in [18, 20, 24, 25]:

    wd = 'networks/db12/{0}-{0}/'.format(n)

    if not os.path.exists(wd):
        os.makedirs(wd)
    os.chdir(wd)

    run_amp = """#!/usr/bin/env python
from amp import Amp
from amp.descriptor import Gaussian
from amp.regression import NeuralNetwork
from ase.db import connect
from amp import SimulatedAnnealing

db = connect('../../../database/db12/data.db')

images = []
for d in db.select('train_set=True'):
    atoms = db.get_atoms(d.id)
    del atoms.constraints
    images += [atoms]

calc = Amp(label='./',
	   dblabel='../../',
	   descriptor=Gaussian(cutoff=6.5),
	   regression=NeuralNetwork(hiddenlayers=(2, {})))

calc.train(images=images,
	   data_format='db',
	   cores=6,
	   energy_goal=1e-3,
	   force_goal=1e-1,
	   global_search=SimulatedAnnealing(temperature=70,
					    steps=50),
	   extend_variables=False)
""".format(n)

    cmd = '''#!/bin/bash
#PBS -N {}
#PBS -l nodes=1:ppn=6
#PBS -l walltime=168:00:00
#PBS -l mem=40GB
#PBS -joe
cd $PBS_O_WORKDIR
./submit.py
#end'''.format(wd)

    with open('submit.py', 'w') as f:
        f.write(run_amp)
    os.chmod('submit.py', 0777)

    with open('submit.sh', 'w') as f:
        f.write(cmd)

    subprocess.call(['qsub', 'submit.sh'])
    time.sleep(2)
    os.unlink('submit.sh')
    os.chdir(home)
#+END_SRC

#+RESULTS:
: 1524266.gilgamesh.cheme.cmu.edu
: 1524267.gilgamesh.cheme.cmu.edu
: 1524268.gilgamesh.cheme.cmu.edu
: 1524269.gilgamesh.cheme.cmu.edu

* 13rd DFT

#+BEGIN_SRC python
from ase.io.trajectory import Trajectory
import numpy as np
from jasp import *
import matplotlib.pyplot as plt
from amp import Amp

calc1 = Amp(load = './networks/db12/24-24/checkpoint-parameters.json')
calc2 = Amp(load = './networks/db12/18-18/checkpoint-parameters.json')
traj = Trajectory('./database/db11/2e5-12/1000/MD.traj')
#traj = read('database/db11/2e5steps/1200.traj@2200:2500:')
ind = []
for i in range(len(traj)):
    atoms = traj[i]
    atoms.set_calculator(calc1)
    E1 = atoms.get_potential_energy()/len(atoms)
    atoms.set_calculator(calc2)
    E2 = atoms.get_potential_energy()/len(atoms)
    if abs(E1-E2) > 0.03:
        ind += [i]

print ind
#+END_SRC

#+RESULTS:
: []


1300K
#+BEGIN_EXAMPLE
[1741, 1742, 1743, 1744, 1745, 1768, 1909, 1910, 1911, 1912, 1955, 1956, 1957, 1958, 2019, 2020, 2021, 2022, 2060, 2061, 2062, 2063, 2064, 2065, 2099, 2100, 2101, 2102, 2103]
#+END_EXAMPLE

1400K
#+BEGIN_EXAMPLE
[1640, 1641, 1642, 1816, 1817, 1818, 1819, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1893, 1894, 1895, 1896, 1897, 1899, 1900, 1902, 1903, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 2085, 2086, 2087, 2188, 2189]
#+END_EXAMPLE

1500K
#+BEGIN_EXAMPLE
[2631, 2633, 2705, 2706, 2707, 2780, 2781, 2782, 2829, 2830, 2831, 2832, 2863, 2900, 2901, 2902, 2903, 2973, 2974, 2975, 3178, 3179, 3261]
#+END_EXAMPLE

#+BEGIN_SRC python :results output org drawer
A = [1640, 1641, 1642, 1816, 1817, 1818, 1819, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1893, 1894, 1895, 1896, 1897, 1899, 1900, 1902, 1903, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 2085, 2086, 2087, 2188, 2189]

print len(A)
#+END_SRC

#+RESULTS:
:RESULTS:
114
:END:

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 4
images = Trajectory('./database/db11/2e5-12/1300/MD.traj', 'r')

A = [1741, 1742, 1743, 1744, 1745, 1768, 1909, 1910, 1911, 1912, 1955, 1956, 1957, 1958, 2019, 2020, 2021, 2022, 2060, 2061, 2062, 2063, 2064, 2065, 2099, 2100, 2101, 2102, 2103]
for i in A:
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md7/study=diffusion/T=1300/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 4
images = Trajectory('./database/db11/2e5-12/1300/MD.traj', 'r')

A = [1640, 1641, 1642, 1816, 1817, 1818, 1819, 1852, 1853, 1854, 1855, 1856, 1857, 1858, 1859, 1860, 1861, 1862, 1863, 1864, 1865, 1866, 1867, 1868, 1869, 1870, 1871, 1872, 1873, 1874, 1875, 1876, 1877, 1878, 1879, 1880, 1881, 1883, 1884, 1885, 1886, 1887, 1888, 1889, 1890, 1891, 1893, 1894, 1895, 1896, 1897, 1899, 1900, 1902, 1903, 1906, 1907, 1908, 1909, 1910, 1911, 1912, 1913, 1914, 1915, 1916, 1917, 1918, 1919, 1920, 1921, 1922, 1923, 1924, 1925, 1926, 1927, 1928, 1929, 1930, 1931, 1932, 1934, 1935, 1936, 1937, 1938, 1939, 1940, 1941, 1942, 1943, 1944, 1945, 1946, 1947, 1948, 1949, 1950, 1951, 1952, 1954, 1955, 1956, 1957, 1958, 1959, 1960, 1961, 2085, 2086, 2087, 2188, 2189]
for i in A:
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md7/study=diffusion/T=1400/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC

#+BEGIN_SRC python
from vasp import Vasp
from vasp.vasprc import VASPRC
from ase.io.trajectory import Trajectory

VASPRC['queue.walltime'] = '24:00:00'
VASPRC['queue.ppn'] = 4
images = Trajectory('./database/db11/2e5-12/1300/MD.traj', 'r')

A = [2631, 2633, 2705, 2706, 2707, 2780, 2781, 2782, 2829, 2830, 2831, 2832, 2863, 2900, 2901, 2902, 2903, 2973, 2974, 2975, 3178, 3179, 3261]
for i in A:
    calc = Vasp('NDFT/surface=fcc111/type=md/order=md7/study=diffusion/T=1500/MD={}'.format(i),
                xc='pbe',
                kpts=[9, 9, 1],
                encut=350,
                nsw=0,
                atoms=images[i])
    calc.set_memory()
    calc.potential_energy
#+END_SRC

